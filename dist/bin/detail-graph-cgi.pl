use warnings;
no warnings "deprecated";
use strict;
use Date::Parse;
use File::Basename;
use RRDp;
use POSIX qw(strftime);

#use File::Glob ':glob';
use CGI::Carp qw(fatalsToBrowser);
use JSON qw(decode_json);
use Data::Dumper;
use File::Temp qw(tempfile);
use File::Glob qw(bsd_glob GLOB_TILDE);

use HostCfg;
use XoruxEdition;

use XenServerDataWrapperOOP;
use XenServerGraph;
use XenServerMenu;

use NutanixDataWrapperOOP;
use NutanixGraph;
use NutanixMenu;

use AWSDataWrapperOOP;
use AWSGraph;
use AWSMenu;

use GCloudDataWrapperOOP;
use GCloudGraph;
use GCloudMenu;

use AzureDataWrapperOOP;
use AzureGraph;
use AzureMenu;

use KubernetesDataWrapperOOP;
use KubernetesGraph;
use KubernetesMenu;

use OpenshiftDataWrapperOOP;
use OpenshiftGraph;
use OpenshiftMenu;

use CloudstackDataWrapperOOP;
use CloudstackGraph;
use CloudstackMenu;

use ProxmoxDataWrapperOOP;
use ProxmoxGraph;
use ProxmoxMenu;

use DockerDataWrapperOOP;
use DockerGraph;
use DockerMenu;

use FusionComputeDataWrapperOOP;
use FusionComputeGraph;
use FusionComputeMenu;

use OVirtDataWrapper;
use OVirtGraph;
use OVirtMenu;

use OracleDBDataWrapper;
use OracleDBGraph;
use OracleDBMenu;

use PostgresDataWrapper;
use PostgresGraph;
use PostgresMenu;

use SQLServerDataWrapper;
use SQLServerGraph;
use SQLServerMenu;

use Db2DataWrapper;
use Db2Graph;
use Db2Menu;

use OracleVmDataWrapperOOP;
use OracleVmGraph;
use OracleVmMenu;

use PowercmcGraph;
use PowerMenu;

my $acl;
my $use_sql;
my $xormon = 0;
my $SERV   = {};
my $CONF   = {};

my $alarm           = 0;
my $graph_path      = "";
my $graph_hours     = 0;           # $email_graph variable from alrt.pl --> EMAIL_GRAPH from alert.cfg
my $graph_un        = 10;          # if 0 then do not graph UN values
my $color_un        = "#d0d0d0";
my $hmc_iops_divide = 1;

if ( $#ARGV > 0 && $ARGV[0] =~ m/alarm/ ) {

  # it is called from alrt.pl to generate a graph for alarming
  $graph_path  = $ARGV[1];
  $graph_hours = $ARGV[2];
  $alarm       = 1;

  #print "Graph creation : detail-graph-cgi.pl: $ARGV[0] $graph_path \n";
}

# new system of keeping VMs
my $all_vmware_VMs = "vmware_VMs";
my $all_hyperv_VMs = "hyperv_VMs";

#
### global definitions
#
my $picture              = "";                    # holds picture immediately after RRD graph finished
my $pic_col_orig         = "F7FCF8";              # if need to change in $cmd strings
my $DEBUG                = $ENV{DEBUG};
my $errlog               = $ENV{ERRLOG};
my $basedir              = $ENV{INPUTDIR};
my $bindir               = $ENV{BINDIR};
my $rrdtool              = $ENV{RRDTOOL};
my $pic_col              = $ENV{PICTURE_COLOR};
my $step                 = $ENV{SAMPLE_RATE};
my $STEP_HEA             = $ENV{STEP_HEA};
my $hea                  = $ENV{HEA};
my $width                = 400;
my $height               = 150;
my $width_trend          = $width * 2 + 128;      # 93 pixels for 1 X axiss legend and Tobi promo + 50 table space
my $detail_multipication = 3;                     # detail pop up will be 3 times bigger
my $entitle              = 0;                     # default, show entitlement
my $filter_max_lansan    = 1000000000000;         # 100GB/sec, filter values above as this is most probably caused by a counter reset (lpar restart)
if ( defined $ENV{FILTER_MAX_LANSAN} ) { $filter_max_lansan = $ENV{FILTER_MAX_LANSAN}; }
my $filter_max_iops = 10000000;                   # 1M IOPS filter values above as this is most probably caused by a counter reset (lpar restart)
if ( defined $ENV{FILTER_MAX_IOPS} ) { $filter_max_iops = $ENV{FILTER_MAX_IOPS}; }
my $filter_max_paging = 500000000;                # 500MB/sec, filter values above as this is most probably caused by a counter reset (lpar restart)
if ( defined $ENV{FILTER_MAX_PAGING} ) { $filter_max_paging = $ENV{FILTER_MAX_PAGING}; }
my $cpu_max_filter = 100;                         # max 10k peak in % is allowed (in fact it cann by higher than 1k now when 1 logical CPU == 0.1 entitlement
if ( defined $ENV{CPU_MAX_FILTER} ) { $cpu_max_filter = $ENV{CPU_MAX_FILTER}; }
my $request_method = "GET";
if ( defined $ENV{REQUEST_METHOD} ) { $request_method = $ENV{REQUEST_METHOD}; }

my $tmpdir = "$basedir/tmp";
if ( defined $ENV{TMPDIR_LPAR} ) {
  $tmpdir = $ENV{TMPDIR_LPAR};
}

# pastel colors for graph areas
my ( $pastel_red, $pastel_green, $pastel_blue, $pastel_yellow ) = ( "#FF7777", "#77FF77", "#77CCFF", "#FFFF77" );

my $delimiter = "XORUX";    # this is for rrdtool print lines for clickable legend

my $rrd_legend = "table";
if ( -f "$tmpdir/xorux_test_orig.txt" ) {
  $rrd_legend = "orig";
}
if ( -f "$tmpdir/xorux_test_both.txt" ) {
  $rrd_legend = "both";
}
if ( -f "$tmpdir/xorux_test_table.txt" ) {
  $rrd_legend = "table";
}
if ( !defined $ENV{HTTP_USER_AGENT} ) {
  $rrd_legend = "orig";
}
else {
  if ( defined $ENV{DEMO} && ( $ENV{DEMO} == 1 ) ) {
  }
  else {
    if ( $ENV{HTTP_USER_AGENT} =~ /MSIE 8.0/ ) {
      $rrd_legend = "orig";
    }
  }
}

### graph or graphv
my $graph_cmd = "graph";
if ( -f "$tmpdir/graphv" ) {
  $graph_cmd = "graphv";    # if exists - call this function
}

### right-axis option (rrdtool <1.2015 do not have it)
my $yes_right_axis = 0;
if ( -f "$tmpdir/graph-right-axis" ) {
  $yes_right_axis = 1;
}

my $png_end_heading = "\n";    # this or graphv dimensions
my $html_heading    = "";

my $NMON  = "--NMON--";
my $AS400 = "--AS400--";

###  font definitions
my $font_def_normal   = "--font=DEFAULT:7:";
my $font_tit_normal   = "--font=TITLE:9:";
my $font_def_dashbo   = "--font=DEFAULT:6:";
my $font_tit_dashbo   = "--font=TITLE:7:";
my $font_def_popup    = "--font=DEFAULT:10:";
my $font_tit_popup    = "--font=TITLE:13:";
my $font_def_hist     = "--font=DEFAULT:8:";
my $font_tit_hist     = "--font=TITLE:10:";
my $font_def_reporter = "--font=DEFAULT:7:";
my $font_tit_reporter = "--font=TITLE:7:";

my $font_def = $font_def_normal;
my $font_tit = $font_tit_normal;

my $wrkdir = $basedir . "/data";

if ( defined $ENV{NMON_EXTERNAL} ) { $wrkdir .= $ENV{NMON_EXTERNAL} }

# if this file exists & contains UNIX time, graph CPU_ready from this time, otherwise not limited
my $CPU_ready_time_file = "$wrkdir/" . "$all_vmware_VMs/" . "CPU_ready_time.txt";

#$DEBUG=2;
open( OUT, ">> $errlog" ) if $DEBUG == 2;

# get QUERY_STRING
use Env qw(QUERY_STRING);

timing_debug($QUERY_STRING);

#$QUERY_STRING .= ":.";
#print STDERR "140 detail-graph-cgi.pl \$QUERY_STRING $QUERY_STRING\n"; # if $DEBUG == 2 ;
#print STDERR "$QUERY_STRING\n\n\n";

my @keep_color_mem = "";
my @keep_color_ams = "";

sub urlencode {
  my $s = shift;
  $s =~ s/([^a-zA-Z0-9!~*()'\''-])/sprintf("%%%02X", ord($1))/ge;
  return $s;
}

sub urldecode {
  my $s = shift;
  $s =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
  $s =~ s/\+/ /g;
  return $s;
}

my $buffer;

if ( defined $request_method ) {
  if ( lc $request_method eq "post" ) {
    read( STDIN, $buffer, $ENV{'CONTENT_LENGTH'} );
  }
  else {
    $buffer = $ENV{'QUERY_STRING'};
  }
}

# hash containing URL parameters. Use like this: $params{server}
my %params = %{ Xorux_lib::parse_url_params($buffer) };

if ( !exists( $params{platform} ) ) {
  $params{platform} = "not defined";
}
if ( !exists( $params{d_platform} ) ) {
  $params{d_platform} = "";
}

#print STDERR Dumper \%params;

# assign values from %params for back compatibility
my $host       = $params{host};
my $server     = $params{server};
my $lpar       = $params{lpar};
my $item       = $params{item};
my $time       = $params{time};
my $type_sam   = $params{type_sam};
my $detail     = $params{detail};
my $upper      = $params{upper};
my $amax       = $params{entitle};
my $start_unix = $params{sunix};
my $end_unix   = $params{eunix};
my $height_new = $params{height};
my $width_new  = $params{width};
my $none       = $params{none};

if ( !defined $host )       { $host       = ""; }
if ( !defined $server )     { $server     = ""; }
if ( !defined $lpar )       { $lpar       = ""; }
if ( !defined $item )       { $item       = ""; }
if ( !defined $time )       { $time       = ""; }
if ( !defined $type_sam )   { $type_sam   = ""; }
if ( !defined $detail )     { $detail     = ""; }
if ( !defined $upper )      { $upper      = ""; }
if ( !defined $amax )       { $amax       = ""; }
if ( !defined $start_unix ) { $start_unix = ""; }
if ( !defined $end_unix )   { $end_unix   = ""; }
if ( !defined $width_new )  { $width_new  = ""; }
if ( !defined $none )       { $none       = ""; }

if ( defined $params{platform} && lc( $params{platform} ) eq "power" ) {
  my $old_url_params = PowerMenu::url_new_to_old( \%params );
  $host     = $old_url_params->{params}{host}   if ( defined $old_url_params->{params}{host}   && $old_url_params->{params}{host} ne '' );
  $server   = $old_url_params->{params}{server} if ( defined $old_url_params->{params}{server} && $old_url_params->{params}{server} ne '' );
  $lpar     = $old_url_params->{params}{lpar}   if ( defined $old_url_params->{params}{lpar} ) && $old_url_params->{params}{lpar} ne '';
  $item     = $old_url_params->{params}{item}   if ( defined $old_url_params->{params}{item} ) && $old_url_params->{params}{item} ne '';
  $type_sam = "m";
}

if ( $params{overview_power} ) { $width = 900; }

$upper = "" if !defined $upper;

# print STDERR "156 detail-graph-cgi.pl host-$host:server-$server:lpar-$lpar:item-$item:time-$time:type_sam-$type_sam:detail-$detail:upper-$upper:amax-$amax:s_unix-$start_unix:end_unix-$end_unix:$height_new:$width_new\n" ;

my $heading_png = "Content-type: image/png\nCache-Control: max-age=60, must-revalidate\n";
my $first_error = 0;

if ( $alarm == 0 ) {

  # only for CGI-BIN purposes
  if ( $item =~ m/xport/ ) {

    # It should be here to do not influence normal report when XML is not in Perl
    require "$bindir/xml.pl";

    # use XML::Simple; --> it has to be in separete file
    print "Content-type: application/octet-stream\n";
  }
  else {
    # normal picture stuff
    #    print "Content-type: image/png\n";
    #    print "Cache-Control: max-age=60, public\n\n"; # workaround for caching on Chrome
    #    print "Cache-Control: max-age=60, must-revalidate\n"; # workaround for caching on Chrome
  }
}

# no URL decode here, as it goes immediately into URL again
# --PH , yes URL decode must be here!!!

# workaround for slash in server name
# for incoming from ext-nmon or from extern query call
my $slash_alias = "∕";    #hexadec 2215 or \342\210\225
$server =~ s/slashslash/$slash_alias/g;

# $host =~ s/\+/ /g; # '+' can be in name since 4.81

# $server =~ s/\+/ /g; # '+' can be in name since 4.81
$server =~ s/\//&&1/g;    #slash workaround
my $acl_item = $lpar;

# $lpar =~ s/\+/ /g; # '+' can be in name since 4.81
$lpar =~ s/\//&&1/g;      #slash workaround
$lpar =~ s/ \[.*\]//g;    # remove alias info
my $wpar = 0;
if ( $lpar =~ m/--WPAR--/ ) {
  $wpar = 1;
}
$lpar =~ s/--WPAR--/\//g;    # WPAR delimiter replace

if ( defined $time && isdigit($time) == 1 ) {

  # since 4.66 there is passed step through hist reports
  $step = $time;
}
if ( defined($type_sam) && !$type_sam eq '' ) {
  $type_sam = 'm' if $type_sam eq 'x';    # came from global hist rep
}

if ( $time !~ m/^d$/ ) {

  # slow down everything except daily graph to let it show as the first one
  select( undef, undef, undef, 0.15 );
}

#my $no_legend = "COMMENT: "; # do not use "COMMENT:\" \"";
my $no_legend = "--interlaced";    # just nope string , it is deprecated anyway

#my $full_size="--full-size-mode";
#--no-gridfit
if ( defined $detail && isdigit($detail) == 0 ) {
  $detail = 0;
}

#overview ibmi graphs
if ( $detail == 22 && defined $params{overview_power} ) {
  $width = $width_trend;
}

if ( $detail == 2 ) {

  # dashboard size
  if ( defined $height_new ) {
    $height = $height_new;
  }
  elsif ( defined $ENV{DASHB_RRDHEIGHT} ) {
    $height = $ENV{DASHB_RRDHEIGHT};
  }
  else {
    $height = 50;
  }
  if ( defined $width_new ) {
    $width = $width_new;
  }
  elsif ( defined $ENV{DASHB_RRDWIDTH} ) {
    $width = $ENV{DASHB_RRDWIDTH};
  }
  else {
    $width = 120;
  }
  $font_def  = $font_def_dashbo;
  $font_tit  = $font_tit_dashbo;
  $no_legend = "--no-legend";
}

if ( $detail == 1 ) {
  $font_def = $font_def_popup;
  $font_tit = $font_tit_popup;
}

my $super_detail = 0;    # instead of detail 3
if ( $detail == 3 ) {
  $super_detail = 3;

  # customer size
  if ( defined $ENV{CUSTOMER_RRDHEIGHT} ) {
    $height = $ENV{CUSTOMER_RRDHEIGHT};
  }
  else {
    $height = 150;
  }
  if ( defined $ENV{CUSTOMER_RRDWIDTH} ) {
    $width = $ENV{CUSTOMER_RRDWIDTH};
  }
  else {
    $width = 550;
  }

  #$font_def =  $font_def_dashbo;
  #$font_tit =  $font_tit_dashbo;
  $no_legend = "--no-legend";
  $detail    = 2;               # same as dashboard
}

if ( $detail == 0 ) {
  if ( defined $ENV{CUSTOMER_RRDHEIGHT} ) {
    $height = $ENV{CUSTOMER_RRDHEIGHT};
  }
  if ( defined $ENV{CUSTOMER_RRDWIDTH} ) {
    $width = $ENV{CUSTOMER_RRDWIDTH};
  }
}

#my $disable_rrdtool_tag = "COMMENT: ";
my $disable_rrdtool_tag = "--interlaced";    #just nope string, it is deprecated anyway
my $rrd_ver             = $RRDp::VERSION;
if ( isdigit($rrd_ver) && $rrd_ver > 1.34 ) {

  # graphv is supported since rrdtool-1.3rc5
  $disable_rrdtool_tag = "--disable-rrdtool-tag";
  $width_trend         = $width_trend - 15;         # trends must be wider due to 2 x promo
}

# entitle, show (0) or do not show (1) LPAR entitlement (DTE Energy extension)
if ( $time =~ m/entitle=/ ) {
  $entitle = $time;                                 # entitle is on $time possition for graph details where upper is not used
}
if ( $upper =~ m/entitle=/ ) {
  $entitle = $upper;                                # just to be sure
}
if ( defined($amax) && !$amax eq '' && $amax =~ m/entitle=/ ) {
  $entitle = $amax;                                 # just to be sure
}

# $entitle =~ s/entitle=//;
$entitle = $amax;

if ( !defined $entitle || $entitle eq "" ) {
  $entitle = 0;
}

# my $name_out = "lpar2rrd-$host-$server-$lpar-$item-$time-$type_sam-$$.png";
# use tempfile instead as the file is automatically unlinked when the process is finished
( my $fh, my $name_out ) = tempfile( UNLINK => 1 );
if ( $item eq "lpm" ) {
  $name_out = "lpar2rrd-$host-$server-$lpar-$item-$time-$type_sam-$$.png";
  $name_out =~ s/;//g;              # ";" cannot be in the path
  $name_out =~ s/\///g;             # "/" cannot be in the path
  $name_out =~ s/^/\/var\/tmp\//;

}

# print STDERR "427 \$name_out $name_out\n";

# $name_out =~ s/;//g;                                # ";" cannot be in the path
# $name_out =~ s/\///g;                               # "/" cannot be in the path
# $name_out =~ s/^/\/var\/tmp\//;

if ( $host eq '' || $server eq '' || $lpar eq '' ) {
  error( "One of passed args: hmc/server/lpar is null ($QUERY_STRING) " . __FILE__ . ":" . __LINE__ );
  exit(1);
}

###   if VMWARE
my $vmware        = 0;
my %unix_commands = ();    # used for jobs for transport sometimes very long cmds to html legend table

# print STDERR "397 detail-graph-cgi.pl test vmware or hyperv for $wrkdir / $server / $host/ \$item $item   (vmware.txt or hyperv.txt)\n";
$vmware = 1 if ( -f "$wrkdir/$server/$host/vmware.txt" );
$vmware = 1 if $server eq "vmware_VMs";
if ( !$vmware ) {
  my @files = bsd_glob "$wrkdir/$server/*/vmware.txt";
  $vmware = 1 if ( defined $files[0] && ( $files[0] ne "" ) && index( $files[0], "vmware.txt" ) != -1 );

  # print STDERR "295 files tested @files\n";
}
if ($vmware) {
  $params{platform}   = "VMware";
  $params{d_platform} = "VMware";
}

my $power      = 0;
my $power_conf = HostCfg::getHostConnections("IBM Power Systems");
foreach my $alias ( keys %{$power_conf} ) {
  if ( $power_conf->{$alias}{host} eq $host ) {
    $power = 1;
  }
}

# workaround to avoid other tech's (=unwanted) branches, although Power, Solaris and perhaps others still remain
my $hyperv        = 0;
my $hitachi       = 0;
my $xenserver     = 0;
my $nutanix       = 0;
my $solaris       = 0;
my $aws           = 0;
my $ovirt         = 0;
my $oraclevm      = 0;
my $oracledb      = 0;
my $postgres      = 0;
my $db2           = 0;
my $sqlserver     = 0;
my $gcloud        = 0;
my $azure         = 0;
my $kubernetes    = 0;
my $openshift     = 0;
my $cloudstack    = 0;
my $proxmox       = 0;
my $docker        = 0;
my $fusioncompute = 0;
my $powercmc      = 0;

if ( $server =~ /^Hitachi$/ ) {
  $hitachi = 1;
  $vmware  = $hyperv = 0;
}
elsif ( $host =~ /^XenServer$/ ) {
  $xenserver = 1;
  $vmware    = $hyperv = 0;
}
elsif ( $host =~ /^Nutanix$/ ) {
  $nutanix = 1;
  $vmware  = $hyperv = 0;
}
elsif ( $host =~ /^AWS$/ ) {
  $aws    = 1;
  $vmware = $hyperv = 0;
}
elsif ( $host =~ /^GCloud$/ ) {
  $gcloud = 1;
  $vmware = $hyperv = 0;
}
elsif ( $host =~ /^Azure$/ ) {
  $azure  = 1;
  $vmware = $hyperv = 0;
}
elsif ( $host =~ /^Kubernetes$/ ) {
  $kubernetes = 1;
  $vmware     = $hyperv = 0;
}
elsif ( $host =~ /^Openshift$/ ) {
  $openshift = 1;
  $vmware    = $hyperv = 0;
}
elsif ( $host =~ /^Cloudstack$/ ) {
  $cloudstack = 1;
  $vmware     = $hyperv = 0;
}
elsif ( $host =~ /^Proxmox$/ ) {
  $proxmox = 1;
  $vmware  = $hyperv = 0;
}
elsif ( $host =~ /^Docker$/ ) {
  $docker = 1;
  $vmware = $hyperv = 0;
}
elsif ( $host =~ /^FusionCompute$/ ) {
  $fusioncompute = 1;
  $vmware        = $hyperv = 0;
}
elsif ( $host =~ /^oVirt$/ ) {
  $ovirt  = 1;
  $vmware = $hyperv = 0;
}
elsif ( $item =~ /^oracledb_/ ) {
  $oracledb = 1;
  $vmware   = $hyperv = 0;
}
elsif ( $item =~ /^postgres_/ ) {
  $postgres = 1;
  $vmware   = $hyperv = 0;
}
elsif ( $item =~ /^sqlserver_/ ) {
  $sqlserver = 1;
  $vmware    = $hyperv = 0;
}
elsif ( $item =~ /^db2_/ ) {
  $db2    = 1;
  $vmware = $hyperv = 0;
}
elsif ( $host =~ /^OracleVM$/ ) {
  $oraclevm = 1;
  $vmware   = $hyperv = 0;
}
elsif ( $host =~ /^PowerCMC$/ ) {
  $powercmc = 1;
  $vmware   = $hyperv = 0;
}
elsif ( $params{d_platform} ) {
  if ( $params{d_platform} eq "solaris" ) {
    $solaris = 1;
    $vmware  = $hyperv = 0;
  }
  elsif ( $params{d_platform} eq "VMware" ) {
    $vmware = 1;
    $hyperv = 0;
  }
}

# following test must be after platform test
# seems platform can be vmware but hyperv=1 for windows tabs in VMs vmware, (platform is used by ACL)
if ( $server =~ /^windows/ ) {
  $hyperv = 1;
  $vmware = 0;
}
$server =~ s/\&\&1/\//g;

# print STDERR "521 \$vmware $vmware \$hyperv $hyperv \$server $server\n";
# item as4job_xxx is called with none=<rrd filename of job to graph in detail>
# not used with historical reports
my $as4job;
if ( $item =~ /^as4job/ ) {
  $as4job     = $none;
  $start_unix = "";
  $as4job =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
}

# item powlin_job is called with none=<job pid to graph in detail>
# not used with historical reports
my $powlin_job;
if ( $item =~ /^powlin_job/ ) {
  $powlin_job = $none;
  $start_unix = "";
  $powlin_job =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
}

# item powlin_mem is called with none=<job pid to graph in detail>
# not used with historical reports
my $powlin_mem;
if ( $item =~ /^powlin_mem/ ) {
  $powlin_mem = $none;
  $start_unix = "";
  $powlin_mem =~ s/\%([A-Fa-f0-9]{2})/pack('C', hex($1))/seg;
}

# parameters called only from historical reports, normally they are NULL
if ( !$start_unix eq '' ) {
  $start_unix =~ s/sunix=//;
}
if ( !$end_unix eq '' ) {
  $end_unix =~ s/eunix=//;
}
if ( !$height_new eq '' && ( $detail == 0 || $detail == 9 || $detail == 7 ) ) {
  $height_new =~ s/height=//;
  if ( isdigit($height_new) > 0 ) {
    $height = $height_new;    #replace HEIGHT by passed one
  }
}
if ( !$width_new eq '' && ( $detail == 0 || $detail == 9 || $detail == 7 ) ) {
  $width_new =~ s/width=//;
  if ( isdigit($width_new) > 0 ) {
    $width = $width_new;      #replace WIDTH by passed one
  }
}

if ( $alarm == 1 ) {
  $name_out = $graph_path;
}

if ( $detail == 1 ) {
  $width       = $width * $detail_multipication;
  $width_trend = $width_trend * $detail_multipication;
  $height      = $height * $detail_multipication;

  # trend pop up size
  if ( defined $item && $item =~ m/^trend|trend$/ ) {
    $width = $width_trend;
  }
}
if ( $detail < 2 ) {
  if ( defined $height_new && $height_new ne '' && defined $width_new && $width_new ne '' ) {
    $height_new =~ s/height=//;
    $width_new  =~ s/width=//;
    if ( isdigit($height_new) > 0 && isdigit($width_new) > 0 ) {
      $height = $height_new;    #replace HEIGHT by passed one
      $width  = $width_new;     #replace WIDTH by passed one
                                # according width change fonts
      if ( $width < 800 ) {     # same as hist rep
        $font_def_popup = $font_def_hist;
        $font_tit_popup = $font_tit_hist;
        $font_def       = $font_def_hist;
        $font_tit       = $font_tit_hist;
      }
    }
  }
}

# detail for graphs created by Reporter
if ( $detail == 10 ) {
  $font_def = $font_def_reporter;
  $font_tit = $font_tit_reporter;
  if ( defined $height_new && isdigit($height_new) && defined $width_new && isdigit($width_new) ) {
    $height_new =~ s/height=//;
    $width_new  =~ s/width=//;
    $height      = $height_new;
    $width       = $width_new;
    $width_trend = $width;
  }
}

### test ACL ###
if ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq "Xormon" ) {
  require ACLx;
  require PowerDataWrapper;
  require SolarisDataWrapper;

  #my ($SERV, $CONF) = PowerDataWrapper::init();
  my $SERV;
  my $CONF;

  $acl    = ACLx->new();
  $xormon = 1;
  my $test_acl = 1;    # on some occasion -> do not test

  # find the corresponding object in ACL/database, based on the provided URL (as if translating it to the new format, see Menu.pm)
  # needed: hw_type (~ 'platform'), subsystem (from 'page_type'), object_item (~ 'id')

  my ( $acl_hw_type, $acl_item_id ) = ( '', '' );
  if ($xenserver) {
    $acl_hw_type = 'XENSERVER';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($ovirt) {
    $acl_hw_type = 'OVIRT';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($nutanix) {
    $acl_hw_type = 'NUTANIX';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($proxmox) {
    $acl_hw_type = 'PROXMOX';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($fusioncompute) {
    $acl_hw_type = 'FUSIONCOMPUTE';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($aws) {
    $acl_hw_type = 'AWS';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($gcloud) {
    $acl_hw_type = 'GCLOUD';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($azure) {
    $acl_hw_type = 'AZURE';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($kubernetes) {
    $acl_hw_type = 'KUBERNETES';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($openshift) {
    $acl_hw_type = 'OPENSHIFT';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($cloudstack) {
    $acl_hw_type = 'CLOUDSTACK';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($docker) {
    $acl_hw_type = 'DOCKER';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($oracledb) {
    $acl_hw_type = 'ORACLEDB';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : OracleDBDataWrapper::get_uuid($server);
  }
  elsif ($postgres) {
    $acl_hw_type = 'POSTGRES';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($sqlserver) {
    $acl_hw_type = 'SQLSERVER';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($db2) {
    $acl_hw_type = 'DB2';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($oraclevm) {
    $acl_hw_type = 'ORACLEVM';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($powercmc) {
    $acl_hw_type = 'POWERCMC';
    $acl_item_id = ( $server eq 'nope' ) ? $lpar : $server;
  }
  elsif ($power) {    # set $acl_hw_type and $acl_item_id for ACL
    ( $SERV, $CONF ) = ( Storable::retrieve("$basedir/tmp/servers_conf.storable"), Storable::retrieve("$basedir/tmp/power_conf.storable") );
    my $url_new     = '';
    my $url_new_tmp = Xorux_lib::url_old_to_new( $ENV{QUERY_STRING} );
    $url_new = $url_new_tmp if ( defined $url_new_tmp );
    ( undef, $url_new ) = split( "\\?", $url_new ) if ( $url_new =~ m/\?/ );
    my $params = Xorux_lib::parse_url_params($url_new);

    $acl_hw_type = 'POWER';
    $acl_item_id = $params->{id};
  }
  elsif ($vmware) {    # set $acl_hw_type and $acl_item_id for ACL
    my $url_new = '';
    my $env_qs  = $ENV{QUERY_STRING};
    if ( $env_qs !~ /d_platform=VMware/ ) {
      $env_qs .= "&d_platform=VMware";
    }
    if ( $env_qs =~ /host=no_hmc&server=Linux/ || $env_qs =~ /item=trendvm/ ) {
      $test_acl = 0;    # do not test acl if linux tabs mapped to vmware VM
    }
    else {
      my $url_new_tmp = Xorux_lib::url_old_to_new( $env_qs . "&acl=acl" );

      #    print STDERR "746 detail-graph-cgi.pl \$url_new_tmp $url_new_tmp\n";
      $url_new = $url_new_tmp if ( defined $url_new_tmp );
      ( undef, $url_new ) = split( "\\?", $url_new ) if ( $url_new =~ m/\?/ );
      my $params = Xorux_lib::parse_url_params($url_new);

      #     print STDERR Dumper ("752",$params);

      $acl_hw_type = 'VMWARE';
      $acl_item_id = $params->{id};
    }
  }
  elsif ($hyperv) {
    my $url_new     = '';
    my $url_new_tmp = Xorux_lib::url_old_to_new( $ENV{QUERY_STRING} . "&platform=hyperv&acl=acl" );

    #    print STDERR "758 detail-graph-cgi.pl \$url_new_tmp $url_new_tmp\n";
    $url_new = $url_new_tmp if ( defined $url_new_tmp );
    ( undef, $url_new ) = split( "\\?", $url_new ) if ( $url_new =~ m/\?/ );
    my $params = Xorux_lib::parse_url_params($url_new);

    #     print STDERR Dumper ("761 ,$url_new,",$params);

    $acl_hw_type = 'WINDOWS';
    $acl_item_id = ( exists $params->{id} ) ? $params->{id} : $url_new;
  }
  elsif ($solaris) {
    my $url_new = '';

    #print STDERR " $ENV{QUERY_STRING}\n";
    my $url_new_tmp = Xorux_lib::url_old_to_new( $ENV{QUERY_STRING} . "&platform=solaris&acl=acl" );

    #print STDERR "776 detail-graph-cgi.pl \$url_new_tmp $url_new_tmp\n";
    $url_new = $url_new_tmp if ( defined $url_new_tmp );
    ( undef, $url_new ) = split( "\\?", $url_new ) if ( $url_new =~ m/\?/ );
    my $params = Xorux_lib::parse_url_params($url_new);

    # print STDERR Dumper ("780",$params);
    $acl_hw_type = 'SOLARIS';
    $acl_item_id = $params->{id};
  }
  else {
    # TODO
    # next virtualization ???
  }

  my $aclitem;
  if ( $item =~ m/^custom/ ) {
    $aclitem = { hw_type => "CUSTOM GROUPS", item_id => $lpar };
  }
  else {
    $aclitem = { hw_type => $acl_hw_type, item_id => $acl_item_id, match => 'granted' };

    # allow partial Totals
    $aclitem->{match} = 'exists' if ( $item =~ m/aggr$/ || ( $item =~ m/power_/ && $lpar =~ m/totals/ ) );
  }

  if ( $test_acl && !$acl->isGranted($aclitem) ) {
    $aclitem->{label} = $host;
    my $str = join( ', ', map {"$_=>$aclitem->{$_}"} keys %{$aclitem} );
    error( "ACL: object not allowed for user: $acl->{uid}: $str " . __FILE__ . ':' . __LINE__ );
    exit(1);
  }
}
else {
  use ACL;    # use module ACL.pm
  my $acl    = ACL->new;
  my $useacl = $acl->useACL();

  if ( $useacl && !$vmware && !defined $ENV{NMON_EXTERNAL} && $alarm != 1 ) {    #NMON grapher if always free, the same with alerting

    my $acl_source = $server;
    my $acl_platform;
    my $acl_subsys;
    if ( $item =~ /^custom/ ) {
      $acl_source = $lpar;
      $acl_subsys = "CUSTOM";
    }
    elsif ($vmware) {
      $acl_subsys   = "VM";
      $acl_platform = "VMWARE";
    }
    elsif ($ovirt) {
      $acl_platform = "OVIRT";
      $acl_subsys   = "OVIRTVM";
    }
    elsif ($xenserver) {
      $acl_platform = "XENSERVER";
      $acl_subsys   = "XENVM";
    }
    elsif ($nutanix) {
      $acl_platform = "NUTANIX";
      $acl_subsys   = "NUTANIXVM";
    }
    elsif ($proxmox) {
      $acl_platform = "PROXMOX";
      $acl_subsys   = "PROXMOXVM";
    }
    elsif ($fusioncompute) {
      $acl_platform = "FUSIONCOMPUTE";
      $acl_subsys   = "FUSIONCOMPUTEVM";
    }
    elsif ( $server eq "Linux--unknown" ) {
      $acl_source   = "Linux";
      $acl_platform = "LINUX";
      $acl_subsys   = "SERVER";
    }
    elsif ($hyperv) {
      $acl_platform = "HYPERV";
    }
    elsif ($oraclevm) {
      $acl_platform = "ORACLEVM";
    }
    elsif ( $item =~ /^oracledb_/ ) {
      $acl_platform = "ORACLEDB";
    }
    elsif ( $item =~ /^postgres_/ ) {
      $acl_platform = "POSTGRES";
    }
    elsif ( $item =~ /^db2_/ ) {
      $acl_platform = "DB2";
    }
    elsif ( $item =~ /^sqlserver_/ ) {
      $acl_platform = "SQLSERVER";
    }
    elsif ($solaris) {
      $acl_platform = "SOLARIS";
    }
    elsif ($aws) {
      $acl_platform = 'AWS';
    }
    elsif ($gcloud) {
      $acl_platform = 'GCLOUD';
    }
    elsif ($azure) {
      $acl_platform = 'AZURE';
    }
    elsif ($kubernetes) {
      $acl_platform = 'KUBERNETES';
    }
    elsif ($openshift) {
      $acl_platform = 'OPENSHIFT';
    }
    elsif ($cloudstack) {
      $acl_platform = 'CLOUDSTACK';
    }
    elsif ($docker) {
      $acl_platform = 'DOCKER';
    }
    elsif ( $server =~ /--unknown$/ || $host eq "no_hmc" ) {
      $acl_source =~ s/--unknown//;
      $acl_platform = "UNMANAGED";
      $acl_subsys   = "SERVER";
    }
    else {
      $acl_platform = "POWER";
      $acl_subsys   = "LPAR";
      if ( $item =~ /^pool|^trendpool|^shpool|^trendshpool|^poolagg|^lparagg/ ) {
        $acl_item   = $lpar;
        $acl_subsys = "POOL";
      }
    }
    if ( $acl_item =~ /--NMON--$/ ) {
      $acl_item =~ s/--NMON--//;
    }

    # warn "$acl_platform, $acl_subsys, $acl_source, $acl_item, test ACL \n";
    if ( !$acl->canShow( $acl_platform, $acl_subsys, $acl_source, $acl_item ) ) {    #  ACL::canShow vrací 0 jestliže nevyhovuje ani jedna z ACL definicí
      error( "ACL: not allowed for user " . $acl->getUser() . " $acl_platform, $acl_subsys, $acl_source, $acl_item, $item " . __FILE__ . ":" . __LINE__ );
      exit(1);
    }
  }
}

# start RRD via a pipe
RRDp::start "$rrdtool";

timing_debug("rrdtool start");

# keep here green - yellow - red - blue ...
my @color     = ( "#FF0000", "#0000FF", "#8fcc66", "#00FFFF", "#FFA500", "#00FF00", "#808080", "#FF00FF", "#800080", "#FDD017", "#0000A0", "#3BB9FF", "#008000", "#800000", "#C0C0C0", "#ADD8E6", "#F778A1", "#800517", "#736F6E", "#F52887", "#C11B17", "#5CB3FF", "#A52A2A", "#FF8040", "#2B60DE", "#736AFF", "#1589FF", "#98AFC7", "#8D38C9", "#307D7E", "#F6358A", "#151B54", "#6D7B8D", "#33cc33", "#FF0080", "#F88017", "#2554C7", "#00a900", "#D4A017", "#306EFF", "#151B8D", "#9E7BFF", "#EAC117", "#99cc00", "#15317E", "#6C2DC7", "#FBB917", "#86b300", "#15317E", "#254117", "#FAAFBE", "#357EC7", "#4AA02C", "#38ACEC" );
my $color_max = 53;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # 0 - 53 is 54 colors

#my @table_out = "";
my @table_out = ();                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     # KZ: must be empty array
my $ret       = create_graph( $host, $server, $lpar, $item, $time, $name_out, $type_sam, $upper, $alarm, $graph_hours, $amax, $start_unix, $end_unix, $entitle );

# close RRD pipe
RRDp::end;

if ( $alarm == 0 && $ret == 1 && $item !~ m/xport/ ) {
  timing_debug("print_png");
  print_png($name_out);
}

close(OUT) if $DEBUG == 2;
timing_debug("exit");

exit(0);

sub create_graph {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $item        = shift;
  my $time        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $upper       = shift;
  my $alarm       = shift;
  my $graph_hours = shift;
  my $amax        = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $entitle     = shift;
  my $text        = "";
  my $done        = 0;
  my $sriov_log_port_list;

  if ( -f "$basedir/data/$server/$host/sriov_log_port_list.json" ) {
    $sriov_log_port_list = read_json("$basedir/data/$server/$host/sriov_log_port_list.json");
  }
  if    ( ( $item =~ m/power_lan/ || $item =~ m/power_san/ || $item =~ m/power_sas/ || $item =~ m/power_hea/ ) && ( $lpar !~ m/totals/ ) ) { graph_power_adapters2( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item ); $done = 1; }
  elsif ( $item =~ m/power_sri/ && $lpar !~ m/totals/ ) {
    graph_these_rrd_files( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item, "rasrm", $sriov_log_port_list );
    $done = 1;
  }
  elsif ( $lpar =~ m/lan-totals/ && $item =~ m/power_lan/ ) { graph_power_adapters_agg2( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item, "ralm" );  $done = 1; }
  elsif ( $lpar =~ m/hea-totals/ && $item =~ m/power_hea/ ) { graph_power_adapters_agg2( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item, "rahm" );  $done = 1; }
  elsif ( $lpar =~ m/sri-totals/ && $item =~ m/power_sri/ ) { graph_power_adapters_agg2( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item, "rasrm" ); $done = 1; }
  elsif ( $lpar =~ m/san-totals/ && $item =~ m/power_san/ ) { graph_power_adapters_agg2( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item, "rasm" );  $done = 1; }
  elsif ( $lpar =~ m/sas-totals/ && $item =~ m/power_sas/ ) { graph_power_adapters_agg2( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item, "rapm" );  $done = 1; }
  elsif ( $item =~ m/^lpar$/ )                              { graph_lpar( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $super_detail ); $done = 1; }
  elsif ( $item =~ /^pool-total$/ || $item =~ /^pool-total-max$/ ) {    #demo workaround. Delete after demo data are available
    if ( defined $ENV{DEMO} && $ENV{DEMO} && 0 ) {
      if ( $item =~ m/^pool-total$/ )     { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item ); $done = 1; }
      if ( $item =~ m/^pool-total-max$/ ) { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item ); $done = 1; }
    }
    else {
      if ( $item =~ m/^pool-total$/ )     { graph_power_total( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item ); $done = 1; }
      if ( $item =~ m/^pool-total-max$/ ) { graph_power_total( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item ); $done = 1; }
    }
  }
  elsif ( $item =~ m/^pool-total$/ && $lpar eq 'total' ) { graph_power_total( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item );         $done = 1; }
  elsif ( $item =~ m/^pool-total-max$/ )                 { graph_power_total( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item );         $done = 1; }
  elsif ( $item =~ m/^power-total$/ )                    { graph_power_servers_total( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item ); $done = 1; }
  elsif ( $item =~ m/^power-total-max$/ )                { graph_power_servers_total( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item ); $done = 1; }
  elsif ( $item =~ m/^power_vcpu$/ )                     { graph_power_vcpu( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item );          $done = 1; }
  elsif ( $item =~ m/^power_vcpu_trend$/ )               { graph_power_vcpu_trend( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $item );    $done = 1; }
  elsif ( $item =~ m/^pool$/ )                           { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                       $done = 1; }
  elsif ( $item =~ m/^pool-max$/ )                       { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                       $done = 1; }
  elsif ( $item =~ m/^clustcpu$/ )                       { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                       $done = 1; }
  elsif ( $item =~ m/^rpcpu$/ )                          { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                       $done = 1; }
  elsif ( $item =~ m/^shpool$/ )                         { graph_shpool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                     $done = 1; }
  elsif ( $item =~ m/^shpool-max$/ )                     { graph_shpool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                     $done = 1; }
  elsif ( $item =~ m/custom_cpu_trend/ )                 { graph_custom_trend( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group" );                       $done = 1; }
  elsif ( $item =~ m/custom$/ )                          { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group" );                             $done = 1; }
  elsif ( $item =~ m/customxport$/ )                     { graph_custom_xport( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group" );                       $done = 1; }
  elsif ( $item =~ m/custommem$/ )                       { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-mem" );     $done = 1; }
  elsif ( $item =~ m/customosmem$/ )                     { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-mem-os" );  $done = 1; }
  elsif ( $item =~ m/customoslan$/ )                     { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-lan-os" );  $done = 1; }
  elsif ( $item =~ m/customossan1$/ )                    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-san1-os" ); $done = 1; }
  elsif ( $item =~ m/customossan2$/ )                    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-san2-os" ); $done = 1; }
  elsif ( $item =~ m/customdisk$/ )                      { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-disk" );    $done = 1; }
  elsif ( $item =~ m/customnet$/ )                       { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-net" );     $done = 1; }
  elsif ( $item =~ m/customvmmemactive$/ )               { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-vmmem" );   $done = 1; }
  elsif ( $item =~ m/customvmmemconsumed$/ )             { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-vmmem" );   $done = 1; }
  elsif ( $item =~ m/custom_esxi_cpu$/ )                 { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-cpu" );     $done = 1; }
  elsif ( $item =~ m/custom_linux_mem$/ )                { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-mem" );     $done = 1; }
  elsif ( $item =~ m/custom_linux_lan$/ )                { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-lan-os" );  $done = 1; }
  elsif ( $item =~ m/custom_linux_san1$/ )               { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-san1-os" ); $done = 1; }
  elsif ( $item =~ m/custom_linux_cpu$/ )                { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-cpu" );     $done = 1; }
  elsif ( $item =~ m/^cpu-linux$/ )                      { graph_cpu_linux( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Custom groups for XenServer
  # hint: the $item inside the graph is the beginning of the `filename.cmd` (part before $lpar$)
  elsif ( $item =~ m/custom-xenvm-cpu-percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-cpu-percent" ); $done = 1; }
  elsif ( $item =~ m/custom-xenvm-cpu-cores$/ )   { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-cpu-cores" );   $done = 1; }
  elsif ( $item =~ m/custom-xenvm-memory-used$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-memory-used" ); $done = 1; }
  elsif ( $item =~ m/custom-xenvm-memory-free$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-memory-free" ); $done = 1; }
  elsif ( $item =~ m/custom-xenvm-vbd$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-vbd" );         $done = 1; }
  elsif ( $item =~ m/custom-xenvm-vbd-iops$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-vbd-iops" );    $done = 1; }
  elsif ( $item =~ m/custom-xenvm-vbd-latency$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-vbd-latency" ); $done = 1; }
  elsif ( $item =~ m/custom-xenvm-lan$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-xenvm-lan" );         $done = 1; }

  # end Custom groups for XenServer

  # Custom groups for Nutanix
  # hint: the $item inside the graph is the beginning of the `filename.cmd` (part before $lpar$)
  elsif ( $item =~ m/custom-nutanixvm-cpu-percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-cpu-percent" ); $done = 1; }
  elsif ( $item =~ m/custom-nutanixvm-cpu-cores$/ )   { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-cpu-cores" );   $done = 1; }
  elsif ( $item =~ m/custom-nutanixvm-memory-used$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-memory-used" ); $done = 1; }
  elsif ( $item =~ m/custom-nutanixvm-memory-free$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-memory-free" ); $done = 1; }
  elsif ( $item =~ m/custom-nutanixvm-vbd$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-vbd" );         $done = 1; }
  elsif ( $item =~ m/custom-nutanixvm-vbd-iops$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-vbd-iops" );    $done = 1; }
  elsif ( $item =~ m/custom-nutanixvm-vbd-latency$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-vbd-latency" ); $done = 1; }
  elsif ( $item =~ m/custom-nutanixvm-lan$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-nutanixvm-lan" );         $done = 1; }

  # end Custom groups for Nutanix

  # Custom groups for Proxmox
  elsif ( $item =~ m/custom-proxmoxvm-cpu$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-proxmoxvm-cpu" );         $done = 1; }
  elsif ( $item =~ m/custom-proxmoxvm-cpu-percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-proxmoxvm-cpu-percent" ); $done = 1; }
  elsif ( $item =~ m/custom-proxmoxvm-memory-used$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-proxmoxvm-memory-used" ); $done = 1; }
  elsif ( $item =~ m/custom-proxmoxvm-memory-free$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-proxmoxvm-memory-free" ); $done = 1; }
  elsif ( $item =~ m/custom-proxmoxvm-data$/ )        { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-proxmoxvm-data" );        $done = 1; }
  elsif ( $item =~ m/custom-proxmoxvm-net$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-proxmoxvm-net" );         $done = 1; }

  # end Custom groups for Proxmox

  # Custom groups for Kubernetes Node
  elsif ( $item =~ m/custom-kubernetesnode-cpu$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnode-cpu" );         $done = 1; }
  elsif ( $item =~ m/custom-kubernetesnode-cpu-percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnode-cpu-percent" ); $done = 1; }
  elsif ( $item =~ m/custom-kubernetesnode-memory$/ )      { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnode-memory" );      $done = 1; }
  elsif ( $item =~ m/custom-kubernetesnode-data$/ )        { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnode-data" );        $done = 1; }
  elsif ( $item =~ m/custom-kubernetesnode-iops$/ )        { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnode-iops" );        $done = 1; }
  elsif ( $item =~ m/custom-kubernetesnode-net$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnode-net" );         $done = 1; }

  # end Custom groups for Kubernetes Node

  # Custom groups for Kubernetes Namespace
  elsif ( $item =~ m/custom-kubernetesnamespace-cpu$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnamespace-cpu" );    $done = 1; }
  elsif ( $item =~ m/custom-kubernetesnamespace-memory$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-kubernetesnamespace-memory" ); $done = 1; }

  # end Custom groups for Kubernetes Namespace

  # Custom groups for Openshift
  elsif ( $item =~ m/custom-openshiftnode-cpu$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnode-cpu" );         $done = 1; }
  elsif ( $item =~ m/custom-openshiftnode-cpu-percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnode-cpu-percent" ); $done = 1; }
  elsif ( $item =~ m/custom-openshiftnode-memory$/ )      { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnode-memory" );      $done = 1; }
  elsif ( $item =~ m/custom-openshiftnode-data$/ )        { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnode-data" );        $done = 1; }
  elsif ( $item =~ m/custom-openshiftnode-iops$/ )        { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnode-iops" );        $done = 1; }
  elsif ( $item =~ m/custom-openshiftnode-net$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnode-net" );         $done = 1; }

  # end Custom groups for Openshift

  # Custom groups for Openshift Namespace
  elsif ( $item =~ m/custom-openshiftnamespace-cpu$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnamespace-cpu" );    $done = 1; }
  elsif ( $item =~ m/custom-openshiftnamespace-memory$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-openshiftnamespace-memory" ); $done = 1; }

  # end Custom groups for Openshift Namespace

  # Custom groups for FusionCompute
  elsif ( $item =~ m/custom-fusioncomputevm-cpu-percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-cpu-percent" ); $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-cpu$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-cpu" );         $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-mem-percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-mem-percent" ); $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-mem-free$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-mem-used" );    $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-mem-used$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-mem-free" );    $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-data$/ )        { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-data" );        $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-disk-ios$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-disk-ios" );    $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-disk-ticks$/ )  { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-disk-ticks" );  $done = 1; }
  elsif ( $item =~ m/custom-fusioncomputevm-net$/ )         { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-fusioncomputevm-net" );         $done = 1; }

  # end Custom groups for FusionCompute

  # Custom groups for oVirt
  elsif ( $item =~ m/custom_ovirt_vm_cpu_percent$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-ovirtvm-cpu-percent" ); $done = 1; }
  elsif ( $item =~ m/custom_ovirt_vm_cpu_core$/ )    { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-ovirtvm-cpu-core" );    $done = 1; }
  elsif ( $item =~ m/custom_ovirt_vm_memory_used$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-ovirtvm-memory-used" ); $done = 1; }
  elsif ( $item =~ m/custom_ovirt_vm_memory_free$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-ovirtvm-memory-free" ); $done = 1; }

  # elsif ( $item =~ m/custom-ovirtvm-lan$/){ graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-ovirtvm-lan" ); $done = 1; }
  # end Custom groups for oVirt
  # Custom groups for Solaris
  elsif ( $item =~ m/custom_solaris_cpu$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-solaris-zone-cpu_used" );   $done = 1; }
  elsif ( $item =~ m/custom_solaris_mem$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-solaris-zone-phy_mem_us" ); $done = 1; }

  # end Custom groups for Solaris
  # Custom groups for OracleVM
  elsif ( $item =~ m/custom_orvm_vm_cpu$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-orvm-cpu-cores" ); $done = 1; }
  elsif ( $item =~ m/custom_orvm_vm_mem$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-orvm-mem-used" );  $done = 1; }

  # end Custom groups for OracleVM
  # Custom groups for Hyperv
  elsif ( $item =~ m/custom_hyperv_cpu$/ ) { graph_custom( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, "custom-group-hyperv-cpu" ); $done = 1; }

  # end Custom groups for Hyperv
  elsif ( $item =~ m/^lparagg$/ )                                            { graph_lparagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^multicluster$/ )                                       { graph_lparagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^trend$/ )                                              { graph_trend( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail );                                               $done = 1; }
  elsif ( $item =~ m/^trendpool$/ || $item =~ m/^trendpool-total$/ )         { graph_trend_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail );                                          $done = 1; }
  elsif ( $item =~ m/^trendpool-max$/ || $item =~ m/^trendpool-total-max$/ ) { graph_trend_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail );                                          $done = 1; }
  elsif ( $item =~ m/^trendshpool$/ )                                        { graph_trend_shpool( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail );                                        $done = 1; }
  elsif ( $item =~ m/^trendshpool-max$/ )                                    { graph_trend_shpool( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail );                                        $done = 1; }
  elsif ( $item =~ m/^poolagg$/ )                                            { graph_poolagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^clustpow$/ )                                           { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );    $done = 1; }
  elsif ( $item =~ m/^esxipow$/ )                                            { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );    $done = 1; }
  elsif ( $item =~ m/^clustmem$/ )                                           { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );    $done = 1; }
  elsif ( $item =~ m/^rpmem$/ )                                              { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );    $done = 1; }
  elsif ( $item =~ m/^dsmem$/ )                                              { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );    $done = 1; }
  elsif ( $item =~ m/^memalloc$/ )                                           { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );    $done = 1; }
  elsif ( $item =~ m/^trendmemalloc$/ )                                      { graph_trendmemalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );                                 $done = 1; }
  elsif ( $item =~ m/^memaggreg$/ )                                          { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );   $done = 1; }
  elsif ( $item =~ m/^memams$/ )                                             { graph_amsaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );   $done = 1; }
  elsif ( $item =~ m/^wpar_mem$/ )                                           { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );   $done = 1; }
  elsif ( $item =~ m/^wpar_cpu$/ )                                           { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );   $done = 1; }
  elsif ( $item =~ m/^ams/ )                                                 { graph_ams( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/lpm/ )                                                  { graph_lpm( $host, $server, $lpar, $time, $name_out, $type_sam, $detail );                                                         $done = 1; }
  elsif ( $item =~ m/^hea/ )                                                 { graph_hea( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                          $done = 1; }
  elsif ( $item =~ m/^oscpu/ )                                               { graph_oscpu( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                        $done = 1; }
  elsif ( $item =~ m/^queue_cpu/ )                                           { graph_cpuqueue( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                     $done = 1; }
  elsif ( $item =~ m/^hmccpu/ )                                              { graph_oscpu( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                        $done = 1; }
  elsif ( $item =~ m/^lan/ )                                                 { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^error_lan$/ )                                          { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^san1/ )                                                { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^san2/ )                                                { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^san_resp/ )                                            { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^error_san$/ )                                          { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^sea/ )                                                 { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^packets/ )                                             { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^pagingagg/ )                                           { graph_osmem_agg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $amax, $start_unix, $end_unix );              $done = 1; }
  elsif ( $item =~ m/^jobs$/ )                                               { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $amax, $start_unix, $end_unix );              $done = 1; }
  elsif ( $item =~ m/^jobs_mem/ )                                            { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $amax, $start_unix, $end_unix );              $done = 1; }
  elsif ( $item =~ m/^powlin_job/ )                                          { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $amax, $start_unix, $end_unix, $powlin_job ); $done = 1; }
  elsif ( $item =~ m/^powlin_mem/ )                                          { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $amax, $start_unix, $end_unix, $powlin_mem ); $done = 1; }
  elsif ( $item =~ m/^wlm-cpu/ )                                             { graph_lparagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );      $done = 1; }
  elsif ( $item =~ m/^wlm-mem/ )                                             { graph_lparagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );      $done = 1; }
  elsif ( $item =~ m/^wlm-dkio/ )                                            { graph_lparagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );      $done = 1; }

  #  elsif ( $item =~ m/^tps/ ) {         graph_tps_lparagg ($host,$server,$lpar,$time,$name_out,$type_sam,$detail,$item); $done=1;}
  elsif ( $item =~ m/^pg2/ )           { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^hmcpgs/ )        { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^slan/ )          { graph_ent_sum( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^ssan1/ )         { graph_ent_sum( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^ssan2/ )         { graph_ent_sum( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^ssea/ )          { graph_ent_sum( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^ame/ )           { graph_ame_mem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^codused$/ )      { graph_cod_used( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );                 $done = 1; }
  elsif ( $item =~ m/^codunreport$/ )  { graph_cod_unreport( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );             $done = 1; }
  elsif ( $item =~ m/^mem$/ )          { graph_osmem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );          $done = 1; }
  elsif ( $item =~ m/^mem_trend$/ )    { graph_osmem_trend( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );    $done = 1; }
  elsif ( $item =~ m/^hmcmem$/ )       { graph_osmem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );          $done = 1; }
  elsif ( $item =~ m/^hmccount$/ )     { graph_hmccount( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );       $done = 1; }
  elsif ( $item =~ m/^pg1$/ )          { graph_paging( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );         $done = 1; }
  elsif ( $item =~ m/^hyppg1$/ )       { graph_paging( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );         $done = 1; }
  elsif ( $item =~ m/^hyppg2$/ )       { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^multihmclpar$/ ) { graph_multihmclpar( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );   $done = 1; }
  elsif ( $item =~ m/^clustlpar$/ )    { graph_multihmclpar( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );   $done = 1; }
  elsif ( $item =~ m/^clustlpardy$/ )  { graph_multihmclpar( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );   $done = 1; }
  elsif ( $item =~ m/^clustlan$/ )     { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^rplpar$/ )       { graph_multihmclpar( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );   $done = 1; }

  #  elsif ( $item =~ m/^multihmc$/ ) { graph_multihmc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^multihmc$/ && $vmware ) { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^multihmc$/ )            { graph_multihmc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                     $done = 1; }
  elsif ( $item =~ m/^multihmc_tot$/ )        { graph_multihmc_tot( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                 $done = 1; }

  #  elsif ( $item =~ m/^clustser$/ ) { graph_multihmc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^clustser$/ )       { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );               $done = 1; }
  elsif ( $item =~ m/^clustser_power$/ ) { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );               $done = 1; }
  elsif ( $item =~ m/^vcenter_power$/ )  { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );               $done = 1; }
  elsif ( $item =~ m/^vmw-mem$/ )        { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^vmw-disk/ )        { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^vmw-iops/ )        { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                                 $done = 1; }
  elsif ( $item =~ m/^ds-vmiops/ )       { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                                 $done = 1; }
  elsif ( $item =~ m/^vmw-net/ )         { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^vmw-swap$/ )       { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^vmw-comp$/ )       { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^vmw-vmotion$/ )    { graph_vm_vmotion( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^vmdisk/ )          { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^hdisk_io/ )        { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^vmnet/ )           { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^dsrw/ )            { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^dsarw/ )           { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^dslat/ )           { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^vmw-proc/ )        { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^vmw-ready/ )       { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^trendcluster$/ )   { graph_trendcluster( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );                                $done = 1; }
  elsif ( $item =~ m/^trendrp$/ )        { graph_trendcluster( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );                                $done = 1; }
  elsif ( $item =~ m/^trendvm/ )         { graph_trendcluster( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );                                $done = 1; }    # trendvmem too
  elsif ( $item =~ m/^trendrpmem/ )      { graph_trendcluster( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );                                $done = 1; }
  elsif ( $item =~ m/^trendclmem/ )      { graph_trendcluster( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours );                                $done = 1; }
  elsif ( $item =~ m/^dstrag_/ )         { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }

  # LINUX IOPS/DATA/LATENCY
  elsif ( $item =~ m/^total_iops$/ )    { graph_linux_io( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^total_data$/ )    { graph_linux_io( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^total_latency$/ ) { graph_linux_io( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # AS400 section
  elsif ( $item =~ m/^S0200ASPJOB/ )  { graph_AS400_jobs( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^ASP/ )          { graph_AS400_jobs( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^ADDR/ )         { graph_AS400_jobs( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^size$/ )        { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^res$/ )         { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^threads$/ )     { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^faults$/ )      { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^pages$/ )       { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^job_cpu$/ )     { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^waj$/ )         { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^disk_io$/ )     { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^disks$/ )       { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^disk_busy$/ )   { graph_memaggreg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^cap_/ )         { graph_aspmem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                  $done = 1; }
  elsif ( $item =~ m/^data_as$/ )     { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                                      $done = 1; }
  elsif ( $item =~ m/^iops_as$/ )     { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                                      $done = 1; }
  elsif ( $item =~ m/^as4job/ )       { graph_as4job( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail, $graph_hours, $entitle, $start_unix, $end_unix, $as4job ); $done = 1; }
  elsif ( $item =~ m/^asp_cap$/ )     { graph_aspcap( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail, $graph_hours, $entitle, $start_unix, $end_unix );          $done = 1; }
  elsif ( $item =~ m/^data_ifcb$/ )   { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                                      $done = 1; }
  elsif ( $item =~ m/^paket_ifcb$/ )  { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                                      $done = 1; }
  elsif ( $item =~ m/^dpaket_ifcb$/ ) { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                                      $done = 1; }
  elsif ( $item =~ m/^dsk_svc_as$/ )  { graph_aspmem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                  $done = 1; }
  elsif ( $item =~ m/^dsk_wait_as$/ ) { graph_aspmem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                  $done = 1; }
  elsif ( $item =~ m/^dsk_latency$/ ) { graph_aspmem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );                  $done = 1; }

  # HYPERV section
  elsif ( $item =~ m/^hyp-disk/ )     { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^hyp-net/ )      { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^hyp-mem$/ )     { graph_osmem( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                      $done = 1; }
  elsif ( $item =~ m/^hyp-cpu/ )      { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^hyp-vmotion$/ ) { graph_vm_vmotion( $host, $server, $lpar, $time, $name_out, $type_sam, $upper, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^lfd_cat_/ )     { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );           $done = 1; }
  elsif ( $item =~ m/^hyp_clustser/ ) { frame_multi( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );              $done = 1; }
  elsif ( $item =~ m/^hdt_data/ )     { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^hdt_io/ )       { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                                   $done = 1; }
  elsif ( $item =~ m/^hdt_latency/ ) {
    graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );
    $done = 1;
  }
  elsif ( $item =~ m/^lfd_dat/ )     { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }
  elsif ( $item =~ m/^lfd_io/ )      { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }
  elsif ( $item =~ m/^csv_cat_/ )    { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^csv_dat/ )     { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }
  elsif ( $item =~ m/^csv_io/ )      { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }
  elsif ( $item =~ m/^lfd_lat/ )     { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }
  elsif ( $item =~ m/^csv_lat/ )     { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }
  elsif ( $item =~ m/^cpuqueue/ )    { graph_cpuqueue( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                  $done = 1; }
  elsif ( $item =~ m/^cpu_process/ ) { graph_cpuqueue( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                  $done = 1; }

  # S2D section
  elsif ( $item =~ m/^phys_disk/ )        { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }
  elsif ( $item =~ m/^s2dvol_capacity$/ ) { graph_memalloc( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^s2dvol/ )           { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                         $done = 1; }

  # S2D agregate
  elsif ( $item =~ m/^s2d_volume_agr_/ )    { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                          $done = 1; }
  elsif ( $item =~ m/^s2d_volume_capagr$/ ) { graph_s2d_volumes( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^error_aggr$/ )        { graph_error_agg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );   $done = 1; }

  # SOLARIS 11 section
  elsif ( $item =~ m/^solaris_zone_cpu|^solaris_zone_os_cpu|^solaris_zone_mem|^solaris_zone_net/ ) { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                        $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_cpu|^solaris_ldom_mem/ )                                        { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );                        $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_net/ )                                                          { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_vnet/ )                                                         { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_san1/ )                                                         { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_san2/ )                                                         { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_san_resp/ )                                                     { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_sum/ )                                                          { graph_ent_sum( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                  $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_pack/ )                                                         { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^san_no_ldom1/ )                                                              { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^san_no_ldom2/ )                                                              { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^san_no_ldom3/ )                                                              { graph_ent( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $item, $start_unix, $end_unix );                      $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_agg_c/ )                                                        { graph_ldomagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^solaris_ldom_agg_m/ )                                                        { graph_ldomagg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^solaris_pool$/ )                                                             { graph_pool( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix );    $done = 1; }

  # SOLARIS 10 section
  elsif ( $item =~ m/^s10_g_cpu|^s10_g_mem/ ) { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^s10_z_cpu|^s10_z_mem/ ) { graph_vmw_disk( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # SOLARIS NMON section
  #elsif ( $item =~ m/^total_iops$/ { graph_linux_io( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ m/^sarmon_san/ )     { graph_sanmon( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, $item ); $done = 1; }
  elsif ( $item =~ m/^sarmon_iops/ )    { graph_sanmon( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, $item ); $done = 1; }
  elsif ( $item =~ m/^sarmon_latency/ ) { graph_sanmon( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, $item ); $done = 1; }

  # Hitachi section
  elsif ( $item =~ m/^system/ )                                   { graph_hitachi_percentages( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );  $done = 1; }
  elsif ( $item =~ m/^cpu-percentages/ )                          { graph_hitachi_percentages( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );  $done = 1; }
  elsif ( $item =~ m/^(hitachi-lan|hitachi-san)$/ )               { graph_hitachi_adapters( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );     $done = 1; }
  elsif ( $item =~ m/^(hitachi-lan-totals|hitachi-san-totals)$/ ) { graph_hitachi_adapters_agg( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # XenServer section
  elsif ( $item =~ m/^xen-(host|disk|lan|vm)/ && $item !~ m/^xen-(.*)-aggr$/ ) { graph_xenserver( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^xen-(host|vm|pool|disk|lan)-(.*)-aggr$/ )                { graph_xenserver_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Nutanix section
  elsif ( $item =~ m/^nutanix-(host|disk|lan|vm)/ && $item !~ m/^nutanix-(.*)-aggr$/ ) { graph_nutanix( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^nutanix-(host|vm|pool|disk|lan)-(.*)-aggr$/ )                    { graph_nutanix_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # AWS section
  elsif ( $item =~ m/^aws-(ec2|ebs|rds|api|lambda)/ && $item !~ m/^aws-(.*)-aggr$/ ) { graph_aws( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^aws-(ec2|ebs|rds|api|lambda|region)-(.*)-aggr$/ )              { graph_aws_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # GCloud section
  elsif ( $item =~ m/^gcloud-(compute|database)/ && $item !~ m/^gcloud-(.*)-aggr$/ && $item !~ m/^gcloud-compute-(overview|running|stopped)/ ) { graph_gcloud( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^gcloud-(compute)-(.*)-aggr$/ || $item =~ m/^gcloud-compute-(overview|running|stopped)/ )                                 { graph_gcloud_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Azure section
  elsif ( $item =~ m/^azure-(vm|app)/ && $item !~ m/^azure-(.*)-aggr$/ && $item !~ m/^azure-(.*)-aggr-res$/ ) { graph_azure( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^azure-(vm|region)-(.*)-aggr$/ || $item =~ m/^azure-(vm|region)-(.*)-aggr-res$/ )        { graph_azure_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Kubernetes section
  elsif ( $item =~ m/^kubernetes-(node|pod|container|namespace)/ && $item !~ m/^kubernetes-(.*)-aggr$/ ) { graph_kubernetes( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^kubernetes-(node|pod|container|namespace|pod-container)-(.*)-aggr$/ )              { graph_kubernetes_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Openshift section
  elsif ( $item =~ m/^openshift-(node|pod|container|namespace)/ && $item !~ m/^openshift-(.*)-aggr$/ )                   { graph_openshift( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^openshift-(node|project-pod|project-container|namespace|container|pod|pod-container)-(.*)-aggr$/ ) { graph_openshift_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Cloudstack section
  elsif ( $item =~ m/^cloudstack-(host|instance|volume|primaryStorage)/ && $item !~ m/^cloudstack-(.*)-aggr$/ ) { graph_cloudstack( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^cloudstack-(host|instance|volume|primaryStorage)-(.*)-aggr$/ )                            { graph_cloudstack_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Proxmox section
  elsif ( $item =~ m/^proxmox-(node|vm|lxc|storage)/ && $item !~ m/^proxmox-(.*)-aggr$/ ) { graph_proxmox( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^proxmox-(node|vm|lxc|storage)-(.*)-aggr$/ )                         { graph_proxmox_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # Docker section
  elsif ( $item =~ m/^docker-(container|volume)/ && $item !~ m/^docker-(.*)-aggr$/ )       { graph_docker( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^docker-(total-container|container|total-volume|volume)-(.*)-aggr$/ ) { graph_docker_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  # FusionCompute section
  elsif ( $item =~ m/^fusioncompute-(host|vm|cluster|datastore)/ && $item !~ m/^fusioncompute-(.*)-aggr$/ ) { graph_fusioncompute( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }
  elsif ( $item =~ m/^fusioncompute-(host|vm|cluster|datastore)-(.*)-aggr$/ )                               { graph_fusioncompute_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }

  #oVirt section
  elsif ( $item =~ /^ovirt_(storage_domain|storage_domains_total|host_nic|vm|cluster|host)_aggr.*$/ ) { graph_ovirt_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ /^ovirt_(host|host_nic|vm|disk|storage_domain)_.*$/ )                              { graph_ovirt( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }

  #OracleDB section
  elsif ( $item =~ /^oracledb/ ) {
    my $dashboard = defined $params{dashboard} ? $params{dashboard} : 0;
    if ( $item =~ m/^oracledb_(Wait_class_Main|Services|configuration_Total|host_metrics|hosts_Total|configuration_DBTotal)/ or $host =~ m/^aggregated/ ) {
      graph_oracledb_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, $dashboard );
      $done = 1;
    }
    else {
      graph_oracledb( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix, $dashboard );
      $done = 1;
    }
  }

  #PostgreSQL section
  elsif ( $item =~ /^postgres/ ) {
    if ( $item =~ /_a_/ ) {
      graph_dbs_legend( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      $done = 1;
    }
    else {
      graph_postgres_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      $done = 1;
    }
  }

  #SQLServer section
  elsif ( $item =~ /^sqlserver/ ) {
    if ( $item =~ /_a_/ ) {
      graph_dbs_legend( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      $done = 1;
    }
    else {
      graph_sqlserver_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      $done = 1;
    }
  }

  #Power CMC section
  #powercmc

  elsif ( $item =~ /^powercmc/ ) {

    # DETAIL_GRAPH_CGI.PL: HOST PowerCMC, SERVER 0254, LPAR pep2_pool, TIME w, NAME_OUT /tmp/qYdDItmOP7, TYPE_SAM , DETAIL 9, START_UNIX , END_UNIX  at /home/lpar2rrd/lpar2rrd/bin/detail-graph-cgi.pl line 1481.
    #warn "DETAIL_GRAPH_CGI.PL: HOST $host, SERVER $server, LPAR $lpar, TIME $time, NAME_OUT $name_out, TYPE_SAM $type_sam, DETAIL $detail, START_UNIX $start_unix, END_UNIX $end_unix";
    if ( $item =~ /_a_/ ) {
      $done = 1;
    }
    else {
      #PowercmcGraph::graph_powercmc_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      graph_powercmc_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      $done = 1;
    }
  }

  #DB2 section
  elsif ( $item =~ /^db2/ ) {
    if ( $item =~ /_a_/ ) {
      graph_dbs_legend( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      $done = 1;
    }
    else {
      graph_db2_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
      $done = 1;
    }
  }

  # OracleVM section
  elsif ( $item =~ /^ovm_(vm|server)_aggr.*$|^ovm_(vm|server)_total.*|^ovm_(vm|serverpools)_total.*$/ ) { graph_oraclevm_totals( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix ); $done = 1; }
  elsif ( $item =~ /^ovm_(vm|server)_.*$/ )                                                             { graph_oraclevm( $host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );        $done = 1; }

  if ( $done == 0 ) {
    error( "Graph error : Not found \"item\": $item : $QUERY_STRING " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  return 1;
}

# read tmp/menu.txt
sub read_menu {
  my $menu_ref = shift;
  open( FF, "<$tmpdir/menu.txt" ) || error( "can't open $tmpdir!menu.txt: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
  @$menu_ref = (<FF>);
  close(FF);
  return;
}

# Print the png out
sub print_png {
  my $name_out = shift;

  if ( $picture eq "" ) {    # for some 'complex' item it is already filled
    if ( !-f "$name_out" ) {
      error( "Graph rrdtool error : print_png : file does not exist : $name_out " . __FILE__ . ":" . __LINE__ );
    }
  }
  ## following was only for IE8, we do not support on our demo since 5.08
  #if ( defined $ENV{DEMO} && ( $ENV{DEMO} == 1 ) ) {
  #  my $name_out_8 = "$name_out" . ".png";
  #  `convert "$name_out" -colors 256 PNG8:"$name_out_8";`;
  #  ` mv "$name_out_8" "$name_out"`;
  #  # print STDERR "convert in use for $name_out\n";
  #} ## end if ( defined $ENV{DEMO...})

  if ( $graph_cmd eq "graph" ) {
    if ( $detail == 9 ) {
      $detail = 0;
    }
  }

  if ( $detail != 1 ) {

    #  if ($detail == 9) {
    $html_heading =~ s/\d\d:\d\d:\d\d.*\d\d\.\d\d\d\d//;
  }

  #print STDERR "650 \$detail $detail \$rrd_legend ,$rrd_legend, \@table_out ,@table_out, \$item ,$item,\n";

  #  if ( @table_out > 1 && ($detail < 1 || $detail == 9) && ( $rrd_legend ne "orig" ) ) {
  # KZ: @table_out > 0 --> html legent contains data lines
  # KZ: scalar(@table_out) == 0 && $no_legend eq "--no-legend" --> html legent doesn't contain data lines, but it has to be send also as an object even when there is nothing in the legend...
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend ne "orig" && ( scalar(@table_out) > 0 || ( scalar(@table_out) == 0 && $no_legend eq "--no-legend" ) ) ) {
    $heading_png =~ s/image\/png/application\/json/;
    print "$heading_png";
    if ( $html_heading ne "" ) {
      chomp $png_end_heading;
      chomp $png_end_heading;
      if ( $png_end_heading !~ "X-RRD" ) {
        $png_end_heading = "X-RRDGraph-Properties::::::" . "$png_end_heading";    # fake
                                                                                  # $png_end_heading = "X-RRDGraph-Properties: 65:15:400:150:1474287623:1505823623:"."$png_end_heading";
      }
      $png_end_heading = "$png_end_heading:" . encode_base64( $html_heading, "" ) . "\n\n";
    }
    print "$png_end_heading";    # for graphv possibility
                                 # print STDERR "651 \$heading_png ,$heading_png, \$png_end_heading ,$png_end_heading,\n";
    if ( $picture eq "" ) {
      $picture = do {
        local $/ = undef;
        open my $fh, "<", $name_out || error( "Cannot open  $name_out: $!" . __FILE__ . ":" . __LINE__ ) && return 0;
        <$fh>;
      };
    }
    my $encoded_pict = encode_base64( $picture, "" );
    $encoded_pict = "data:image/png;base64,$encoded_pict";
    my $table_one_string  = "@table_out";
    my $encoded_table_out = encode_base64( $table_one_string, "" );

    my $lll = length $encoded_pict;
    my $llx = length $encoded_table_out;

    #print STDERR "length encoded pict is $lll\n";
    #print STDERR "length encoded table is $llx\n";

    print "{\"img\":\"$encoded_pict\", \"table\": \"$encoded_table_out\"}";

  }
  else {
    print "$heading_png";

    # print STDERR "685 \$heading_png ,$heading_png, \$html_heading ,$html_heading,\n";
    if ( $html_heading ne "" ) {
      chomp $png_end_heading;
      chomp $png_end_heading;
      $png_end_heading = "$png_end_heading:" . encode_base64( $html_heading, "" ) . "\n\n";

      #$png_end_heading = "$png_end_heading:$html_heading\n\n";
    }
    if ( $png_end_heading !~ "X-RRD" ) {
      $png_end_heading = "X-RRDGraph-Properties::::::" . "$png_end_heading";    # fake
                                                                                # $png_end_heading = "X-RRDGraph-Properties: 65:15:400:150:1474287623:1505823623:"."$png_end_heading";
    }
    if ( $detail == 1 || $html_heading eq "" ) {
      print "\n";
    }
    else {
      print "$png_end_heading";                                                 # for graphv possibility
                                                                                # print STDERR "696 \$item $item no table \$png_end_heading ,$png_end_heading, \$html_heading ,$html_heading,\n";
    }

    open( PNG, "< $name_out" ) || error( "Cannot open  $name_out: $!" . __FILE__ . ":" . __LINE__ ) && return 0;
    binmode(PNG);
    while ( read( PNG, $b, 4096 ) ) {
      print "$b";
    }
    close(PNG);
  }

  if ( -f "$name_out" ) {
    unlink("$name_out");
  }
  return 1;
}

# error handling
sub error {
  my $text     = shift;
  my $act_time = localtime();
  my $basedir  = $ENV{INPUTDIR};
  chomp($text);

  #print "ERROR          : $text : $!\n";
  print STDERR "$act_time: $host:$server:$lpar:$item:$time:$type_sam:$detail:$upper : $text \n";

  if ( $alarm == 1 ) {
    print "$act_time: $text : $!\n";
    return 1;
  }
  my $base64 = encode_base64( $text, '' );
  print "X-XoruX-Error: $base64\n";

  print "\n";    # print missing enter to finish header HTTP
                 # print error picture to check error-cgi.log or web error log
  if ( $text =~ /ACL: not allowed/ && -f "$basedir/html/acl_error.png" ) {
    open( PNG, "< $basedir/html/acl_error.png" );

    # || error("Cannot open  $basedir/html/error.png: $!".__FILE__.":".__LINE__) && return 0;
  }
  else {
    open( PNG, "< $basedir/html/error.png" )

      #|| error("Cannot open  $basedir/html/error.png: $!".__FILE__.":".__LINE__) && return 0;
  }
  binmode(PNG);
  while ( read( PNG, $b, 4096 ) ) {
    print "$b";
  }
  close(PNG);

  # print STDERR "err png printed \n";
  return 1;
}

sub ret_graph_param {

  # for graphv returns
  #  "X-RRDGraph-Properties: $graph_left:$graph_top:$graph_width:$graph_height:$graph_start:$graph_end\n\n"
  # for graph returns
  #  "\n"
  # if exist print lines containing $delimiter -> prepares @table_out for clickable legend
  # if defined second parameter > Updated time for LAN SAN1 SAN2 SEA & others for clickable legend

  my $answ = shift;

  # print STDERR 938,substr($answ,0,19),"\$answ\n";
  my $updated       = shift;
  my $iops          = shift;
  my $rest_api_type = shift;
  if ( !defined($rest_api_type) ) {
    $rest_api_type = "";
  }
  if ( !defined($iops) || $iops eq '' ) {

    # Linux standalones reports Frames
    $iops = "IOPS";
  }

  if ( !defined $updated ) {    # line Updated
    $updated = "";
  }

  my $graphv_line = "";         # end of HTML heading
  my $test_item   = "graph_";
  my @rrd_result;
  if ( $answ =~ /0x[0-9a-fA-F]{5,}/ ) {
    @rrd_result = split( '\n', $$answ );
  }
  else {
    @rrd_result = split( '\n', $answ );
  }

  # print STDERR "571 \@rrd_result @rrd_result\n";

  for (@rrd_result) {s/\"//g};               # filtr
  for (@rrd_result) {s/print\[.*\] =//g};    #  1st part of print line in newer rrd versions

  my @rrd_print = grep {/$delimiter/} @rrd_result;     #print lines for legend
                                                       # print STDERR "578 rrdprint @rrd_print\n";
  my @matches   = grep {/^$test_item/} @rrd_result;    # for zoom

  my $param_num = @matches;

  #if ( $param_num > 0 && $param_num != 6 ) {
  #  print STDERR "cmd graphv did not give 6 graph_ params, gave $param_num " . __FILE__ . ":" . __LINE__ . "\n";
  #  print STDERR "Answer rrdtool => $answ:\n";
  #  print STDERR Dumper $answ;

  # return $graphv_line;   # let it go on, 5 params is maybe enough so lets try
  #}
  if (@matches) {
    my %zparams;
    my $param_present;
    foreach my $pair (@matches) {
      my ( $key, $value ) = split( " = ", $pair );
      if ( defined $key && defined $value ) {
        $zparams{$key} = $value * 1;
      }
    }

    # print STDERR Dumper \%zparams;
    {
      no warnings 'uninitialized';
      $graphv_line = "X-RRDGraph-Properties: $zparams{graph_left}:$zparams{graph_top}:$zparams{graph_width}:$zparams{graph_height}:$zparams{graph_start}:$zparams{graph_end}";
    }
    $graphv_line .= "\n\n";
  }
  else {
    $graphv_line .= "\n";
  }

  #print STDERR "994 \$item $item \$html_heading $html_heading \$test_item $test_item \@rrd_print @rrd_print\n";
  #print STDERR "\$graphv_line $graphv_line\n";

  #
  #now prepare HTML table for clickable legend for pool, shared pool, hmctotals ... etc
  #

  if ( @rrd_print < 1 ) {
    return "$graphv_line";
  }
  my $item_ret = "";

  # print STDERR "766 detail-graph-cgi.pl \@rrd_print @rrd_print\n";
  # print STDERR "\$rrd_print[0] $rrd_print[0]\n";
  ( undef, $item_ret, undef ) = split( "$delimiter", $rrd_print[0] );

  # print STDERR "\$item_ret $item_ret\n";

  if ( defined $item_ret && $item_ret =~ /poolagg/ || $item_ret =~ /lparagg/ || $item_ret =~ /multihmcframe/ || $item_ret =~ /multicluster/ || $item_ret =~ /solaris_ldom_agg_c/ || $item_ret =~ /solaris_ldom_agg_m/ | $item_ret =~ /custom_solaris_cpu/ || $item_ret =~ /custom_solaris_mem/ || $item_ret =~ /s2d_vol_cap/ ) {    # || $item_ret =~ /custom_hyperv_cpu/
    my $units = "cores";
    $units = "GHz  " if $vmware && $item_ret !~ /multihmcframe/;
    my $platform = "";
    if ($xormon) {
      $platform = "&platform=VMware" if $vmware;
    }

    my $headline_in_html_legend = "Utilization in CPU $units";
    if ( $item_ret =~ /solaris_ldom_agg_m|custom_solaris_mem/ ) {
      $headline_in_html_legend = "Used memory in GB";
    }
    elsif ( $item_ret =~ /s2d_vol_cap/ ) {
      $headline_in_html_legend = "Used capacity[TB]";
    }
    elsif ( $item_ret =~ "multihmcframepower" ) {
      $headline_in_html_legend = "Power usage [kW] ";
    }

    # prepare HTML table for pool, shared pool, hmctotals - server
    my $line1 = "";
    my $line2 = "";
    if ( $item_ret =~ /custom_solaris_cpu|custom_solaris_mem/ ) {

      #$line1 = "<table class=\"tablesorter tablegend\" data-sortby='4'>
      $line1 = "<p class='custom0'>$headline_in_html_legend</p>
      <table class=\"tablesorter tablegend\" data-sortby='4'>
      <thead>
      <tr>
      <th>&nbsp;</th>
      <th class=\"sortable header toleft\">Zone</th>
      <th class=\"sortable header toleft\">LDOM/CDOM/Global zone</th>
      <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
      <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
      </thead>
      <tbody>";
      $line2 = "    <tr>
      <td class=\"legsq\">xorux_lpar_color</td>
      <td class=\"clickabletd\">xorux_lpar_name</td>
      <td class=\"clickabletd\">xorux_server_name</td>
      <td>xorux_lpar_avg</td>
      <td>xorux_lpar_max</td>
      </tr>";
    }
    else {
      $line1 = "<table class=\"tablesorter tablegend\" data-sortby='4'>
      <thead>
      <tr>
      <th>&nbsp;</th>
      <th class=\"sortable header toleft\">$headline_in_html_legend:</th>
      <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
      <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
      </thead>
      <tbody>";
      $line2 = "    <tr>
      <td class=\"legsq\">xorux_lpar_color</td>
      <td class=\"clickabletd\">xorux_lpar_name</td>
      <td>xorux_lpar_avg</td>
      <td>xorux_lpar_max</td>
      </tr>";
    }
    my $line2_tcpu = "<tfoot> <tr>
    <td class=\"legsq\">#888888</td>
    <td class=\"toleft\">Total available</td>
        <td></td>
        <td>xorux_lpar_max</td>
      </tr></tfoot>";
    my $line2_tcpu_act = "";

    # MAX values for HMC totals -> server
    my $line2_cpu_max = "<tfoot> <tr>
        <td class=\"legsq\">#0088FF</td>
        <td class=\"toleft\">Total max</td>
        <td></td>
        <td>xorux_lpar_max</td>
      </tr></tfoot>";
    my $line2_cpu_max_act = "";

    my $line3 = "  </tbody>  </table>";
    push @table_out, $line1;
    my $avg_sum = 0;
    my $max_sum = 0;
    while ( my $print_line = shift(@rrd_print) ) {
      if ( index( $print_line, "MAXTCPU" ) ne -1 ) {    #CPUs total available in pools
        $line2_tcpu_act = $line2_tcpu;
        ( my $maxtcpu, undef ) = split( "MAX", $print_line );

        #        $line2_tcpu_act =~ s/xorux_lpar_max/$maxtcpu/;
        if ( $item_ret =~ "multihmcframepower" ) {
          $line2_tcpu_act =~ s/xorux_lpar_max/$max_sum/;
          $line2_tcpu_act =~ s/available//;

          #          $line2_tcpu_act =~ s/<td class=\"legsq\">#888888<\/td>//;
          $line2_tcpu_act =~ s/<td><\/td>/<td>$avg_sum<\/td>/;
          $line2_tcpu_act =~ s/legsq/toleft/;
          $line2_tcpu_act =~ s/#888888//;
        }
        else {
          $line2_tcpu_act =~ s/xorux_lpar_max/$maxtcpu/;
        }
        next;
      }
      if ( index( $print_line, "MAXCPUMAX" ) ne -1 ) {    #MAX values from pool.xrm
        $line2_cpu_max_act = $line2_cpu_max;
        ( my $maxtcpu, undef ) = split( "MAX", $print_line );
        $line2_cpu_max_act =~ s/xorux_lpar_max/$maxtcpu/;
        next;
      }
      my $line2_act = $line2;

      # print STDERR time." line1160-$print_line\n";
      ( my $average, undef, my $lpar_space, my $color, my $rrd_file_all ) = split( " $delimiter ", $print_line );
      $print_line = shift(@rrd_print);

      # print STDERR "1788 \$print_line $print_line\n";
      ( my $max, undef ) = split( "$delimiter", $print_line );
      if ( !defined $rrd_file_all ) {    #if not in 1st line > try second
        ( undef, $rrd_file_all ) = split( "$delimiter", $print_line );
      }
      my @pathx        = split( "/", $rrd_file_all );
      my $hmc_t        = @pathx[ @pathx - 2 ];
      my $lpar_id_file = @pathx[ @pathx - 1 ];

      my $server_t = "";
      if ( $item_ret =~ /custom_solaris_cpu|custom_solaris_mem/ ) {
        $hmc_t = "Solaris";
        $lpar_space =~ s/\s+//g;
        $server_t = @pathx[ @pathx - 3 ];
      }
      elsif ( $item_ret =~ /s2d_vol_cap/ ) {
        $server_t = $host;
      }
      else {
        $server_t = @pathx[ @pathx - 3 ];
      }
      my $lpar_space_show = $lpar_space;
      $lpar_space_show =~ s/&&1/\//g;
      my $lpar_url = $lpar_space_show;

      # $lpar_url =~ s/ /\+/g;
      # $lpar_url =~ s/([^A-Za-z0-9\+-_])/sprintf("%%%02X", ord($1))/seg; # PH: keep it is it is exactly!!!
      # $lpar_url =~ s/\#/%23/g;
      $lpar_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;
      if ( $hmc_t eq "ZONE" ) {
        $hmc_t           = "Solaris";
        $lpar_space_show = $server_t;
      }    ##### LDOM name

      my $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=lpar&entitle=0&none=none&d_platform=$params{d_platform}\">$lpar_space_show</a>";
      if ( $item_ret =~ /custom_solaris_cpu|custom_solaris_mem/ ) {
        $server_t   = urlencode($server_t);
        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=solaris_zone_cpu&entitle=0&none=none\">$lpar_space_show</a>";
        $server_t   = urldecode($server_t);
      }
      if ( $item_ret =~ /s2d_vol_cap/ ) {

        #print STDERR "$hmc_t $host $server\n";
        #$query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$host&server=$server&lpar=none&item=volume&entitle=0&none=none&d_platform=$params{d_platform}\">$lpar_space_show</a>";
        my $clu_name = $host;
        $server_t = $host;
        $clu_name =~ s/^cluster_//g;
        my $vol_id = $clu_name . "_vol_" . $lpar_url;

        #print STDERR "$vol_id\n";
        $query_lpar = "<a href=\"?platform=hyperv&item=volume&cluster=$clu_name&host=$host&name=$lpar_url&id=$vol_id\">$lpar_space_show</a>";
      }
      if ( $item_ret =~ /solaris_ldom_agg_c|solaris_ldom_agg_m/ ) {
        $server_t = urlencode($server_t);
        my $item_url = "";
        if ( $item_ret =~ /solaris_ldom_agg_c/ ) {
          $item_url = "solaris_zone_cpu";
        }
        else { $item_url = "solaris_zone_mem" }

        #$query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=$item_url&entitle=0&none=none&d_platform=$params{d_platform}$platform\">$lpar_space_show</a>";
        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=$item_url&time=d&type_sam=m&detail=1&entitle=0&d_platform=$params{d_platform}$platform&none=none\">$lpar_space_show</a>";

        #$query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=solaris_zone_cpu&entitle=0&none=none\">$lpar_space_show</a>";
      }
      if ( $item_ret =~ /multihmcframe/ ) {
        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=pool&item=pool&entitle=0&none=none&d_platform=$params{d_platform}$platform\">$lpar_space_show</a>";
        if ($hyperv) {

          #$query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=windows/$server_t&lpar=pool&item=pool&entitle=0&none=none\">$lpar_space_show</a>";
          # actually it is server
          $query_lpar = "<a href=\"?platform=hyperv&item=host&domain=$server_t&name=$hmc_t&host=host\">$lpar_space_show</a>";
        }
      }
      if ( $item_ret =~ /multicluster/ ) {
        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=cluster&item=cluster&square_item=clustcpu\">$lpar_space_show</a>";

        # print STDERR "692 $lpar_space_show\n";
      }

      if ($hitachi) {
        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$server_t&server=$hmc_t&lpar=$lpar_url&item=lpar&entitle=0&none=none\">$lpar_space_show</a>";
      }
      if ($hyperv) {    #|| ($item_ret =~ /custom_hyperv_cpu/ )) left_curly
                        # print STDERR "1235 \$item_ret ,$item_ret, \$hmc_t $hmc_t \$server_t $server_t \$lpar_space_show $lpar_space_show \$lpar_id_file $lpar_id_file\n";
        $item_ret =~ s/^\s+|\s+$//g;
        if ( index( $item_ret, "lparagg" ) > -1 ) {    #($item_ret =~ /lparagg/) left_curly
          my $lpar_id = $lpar_id_file;
          $lpar_id =~ s/\.rrm//;
          my @menu;
          read_menu( \@menu );
          my @matches = grep { /^L/ && /$lpar_id/ } @menu;

          # print STDERR "1242 @matches\n";
          if ( !@matches || scalar @matches < 1 ) {
            next;

            #error( "no menu.txt item for \$lpar_id $lpar_id " . __FILE__ . ":" . __LINE__ );
            #return;
          }

          # print STDERR "1248 @matches\n";
          # L:ad.xorux.com:HVNODE01:CBD9D469-A221-4228-816F-3860110150AD:hvlinux01:/lpar2rrd-cgi/detail.sh?host=HVNODE01&server=windows/domain_ad.xorux.com&lpar=CBD9D469-A221-4228-816F-3860110150AD&item=lpar&entitle=0&gui=1&none=none:MSNET-HVCL::H
          # L:ad.int.xorux.com:HYPERV:3138F59F-11AD-46FB-951C-9C147C98896C:XoruX-master:/lpar2rrd-cgi/detail.sh?host=HYPERV&server=windows/domain_ad.int.xorux.com&lpar=3138F59F-11AD-46FB-951C-9C147C98896C&item=lpar&entitle=0&gui=1&none=none:::H
          #
          ( undef, my $domain, my $x_server, undef, my $x_lpar, undef, my $hyp_cluster, undef ) = split( ":", $matches[0] );

          if ( defined $hyp_cluster && $hyp_cluster ne "" ) {
            $query_lpar = "<a href=\"?platform=hyperv&item=vm&cluster=$hyp_cluster&host=$x_server&name=$x_lpar&id=$lpar_id\">$lpar_space_show</a>";
          }
          else {
            $query_lpar = "<a href=\"?platform=hyperv&item=vm&domain=$domain&host=$x_server&name=$x_lpar&id=$lpar_id\">$lpar_space_show</a>";
          }

          # new wave solution
          #
          # HOST/VM
          # platform=hyperv&item=vm&domain=ad.int.xorux.com&host=HYPERV&name=XoruX-master
          # if vm is in cluster then cluster is instead of domain
        }
      }
      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      if ( $item_ret =~ "multihmcframepower" ) {
        $avg_sum += $average;
        $max_sum += $max;
      }
      $line2_act =~ s/xorux_lpar_name/$query_lpar/;
      if ( $item_ret =~ /custom_solaris_cpu|custom_solaris_mem/ ) {
        $line2_act =~ s/xorux_server_name/$server_t/;
        $line2_act =~ s/total/-/g;
      }
      $line2_act =~ s/xorux_lpar_color/$color/;
      push @table_out, $line2_act;
    }
    if ( $line2_tcpu_act ne "" ) {
      push @table_out, $line2_tcpu_act;
    }
    if ( $line2_cpu_max_act ne "" ) {
      push @table_out, $line2_cpu_max_act;
    }
    push @table_out, $line3;

    #print STDERR "1067 @table_out\n";
    #prepare file with table
    #my $sss = "/tmp/tableeeee_out.html";
    #open (FF, ">$sss");
    #print FF "@table_out\n";
    #close (FF);
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /vmw-vmotion/ || $item_ret =~ /hyp-vmotion/ ) ) {
    my $line1 = "<table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"toleft\">VM</th>
        <th class=\"sortable header toleft\">server</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2 = "    <tr>
      <td class=\"legsq\">xorux_lpar_color</td>
      <td class=\"toleft\">xorux_lpar_name</td>
      <td class=\"clickabletd\">xorux_server_name</td>
      <td>xorux_lpar_avg</td>
      <td>xorux_lpar_max</td>
      </tr>";
    my $line4_updated = "";
    if ( $updated =~ "Updated" ) {
      $line4_updated = " <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>";
    }
    push @table_out, $line1;

    my ( $average, $server_space, $lpar_space, $color, $host, $server );
    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2;
      ( $average, undef, $server_space, $lpar_space ) = split( " $delimiter ", $print_line );
      $print_line = shift(@rrd_print);
      ( my $max, $color, $host, $server ) = split( " $delimiter ", $print_line );

      my $lpar_space_show   = $lpar_space;
      my $server_space_show = $server_space;
      $lpar_space_show   =~ s/&&1/\//g;
      $server_space_show =~ s/&&1/\//g;
      my $lpar_url     = $lpar_space_show;
      my $query_lpar   = $lpar_space_show;
      my $server_url   = $server_space_show;
      my $query_server = $server_space_show;

      $server_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;

      $query_server = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$host&server=$server&lpar=pool&item=pool&entitle=0&none=none&d_platform=$params{d_platform}\">$server_space_show</a>";

      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      $line2_act =~ s/xorux_server_name/$query_server/;
      $line2_act =~ s/xorux_lpar_name/$query_lpar/;
      $line2_act =~ s/xorux_lpar_color/$color/;

      push @table_out, $line2_act;
    }
    my $tbody_end = "</tbody>";
    push @table_out, $tbody_end;

    my $total_lines_to_print = "<tfoot>" . $line4_updated . "</tfoot></table>";
    push @table_out, $total_lines_to_print;

    # print STDERR "@table_out\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /memaggreg_waj/ || $item_ret =~ "memaggreg_cpu" || $item_ret =~ /memaggreg_disk/ ) ) {    # other memaggreg_... see following if
                                                                                                                                     # prepare table for memqaggreg

    my $line1_memaggreg = "<table class=\"tablesorter tablegend\" data-sortby='6 7'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">Jobname Jobno</th>
  <th class=\"sortable header toleft\">User</th>
  <th class=\"sortable header toleft\">Type&nbsp;&nbsp;</th>
  <th class=\"sortable header\">AvrgRun&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;</th>
  <th class=\"sortable header toleft\">Function</th>
  <th class=\"sortable header toleft\">Status&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2_memaggreg = "    <tr>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td class=\"toleft\">Subsystem</td>
  <td class=\"toleft\">User</td>
  <td class=\"toleft\">Type</td>
  <td>xorux_lpar_tavg</td>
  <td>xorux_lpar_avg</td>
  <td>xorux_lpar_max</td>
  <td class=\"toleft\">Function</td>
  <td class=\"toleft\">Status</td>
      </tr>";

    my $line3_memaggreg = "  </tbody>  </table>";

    my $line3_memaggreg_day = " </tbody>
    <tfoot>
      <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
    </tfoot> </table>\n";

    push @table_out, $line1_memaggreg;

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_memaggreg;
      ( my $average, undef, my $lpar_space ) = split( " $delimiter ", $print_line );

      #( $lpar_space, my $user, my $upid ) = split( " ", $lpar_space );
      my $upid = substr $lpar_space, 20;
      my $user = substr $lpar_space, 10, 10;
      $lpar_space = substr $lpar_space, 0, 10;
      $print_line = shift(@rrd_print);
      ( my $max, my $color, my $subtype, my $function, my $status, my $filename ) = split( " $delimiter ", $print_line );
      $print_line = shift(@rrd_print);
      ( my $avrgt, undef ) = split( " $delimiter ", $print_line );
      $avrgt = "0.00" if $avrgt =~ /NaNQ/;

      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_tavg/$avrgt/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      $filename  =~ s/\.mmc$//;
      $line2_act =~ s/>xorux_lpar_color/ data-job=\"$filename\">xorux_lpar_color/;
      $line2_act =~ s/xorux_lpar_color/$color/;
      $line2_act =~ s/Subsystem/$lpar_space $upid/;
      $line2_act =~ s/Type/$subtype/;
      $line2_act =~ s/User/$user/;
      $line2_act =~ s/Function/$function/;
      $line2_act =~ s/Status/$status/;
      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_memaggreg_day =~ s/COMMENT://;
      $line3_memaggreg_day =~ s/\\//g;
      push @table_out, $line3_memaggreg_day;
    }
    else {
      push @table_out, $line3_memaggreg;
    }

    # push  @table_out, $line3_memaggreg;
    # print STDERR "\@table_out @table_out\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ "memaggreg_jobcpu" ) ) {    # CPUTOT jobs, other memaggreg_... see following if
                                                                       # prepare table for memaggreg
    my $line1_memaggreg = "<table class=\"tablesorter tablegend\" data-sortby='5 6'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">Job PID&nbsp;&nbsp;</th>
  <th class=\"sortable header toleft\">User&nbsp;&nbsp;</th>
  <th class=\"sortable header\">AvrgRun&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header toleft\">Command</th>
      </tr>
    </thead>
    <tbody>";
    my $line2_memaggreg = "    <tr>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td class=\"toleft\">Subsystem</td>
  <td class=\"toleft\">User</td>
  <td>xorux_lpar_tavg</td>
  <td>xorux_lpar_avg</td>
  <td>xorux_lpar_max</td>
  <td class=\"toleft\">Function</td>
      </tr>";

    my $line3_memaggreg = "  </tbody>  </table>";

    my $line3_memaggreg_day = " </tbody>
    <tfoot>
      <td colspan=\"6\" class=\"tdupdated toleft\">$updated</td>
    </tfoot> </table>\n";

    push @table_out, $line1_memaggreg;

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_memaggreg;
      ( my $average, undef, my $lpar_space ) = split( " $delimiter ", $print_line );

      # ($lpar_space, my $user) = split(" ",$lpar_space);
      $print_line = shift(@rrd_print);

      # ( my $max, my $color, my $user, my $function, my $filename ) = split( " $delimiter ", $print_line );
      ( my $max, my $color, my $user, my $filename ) = split( " $delimiter ", $print_line );
      $print_line = shift(@rrd_print);
      ( my $avrgt, undef ) = split( " $delimiter", $print_line );
      $avrgt = "0.00" if $avrgt =~ /[Nn]a[Nn]/;

      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_tavg/$avrgt/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      $filename  =~ s/\.mmc$//;
      $line2_act =~ s/>xorux_lpar_color/ data-job=\"$filename\">xorux_lpar_color/;
      $line2_act =~ s/xorux_lpar_color/$color/;
      $line2_act =~ s/Subsystem/$lpar_space/;

      #$line2_act =~ s/Type/$subtype/;
      $line2_act =~ s/User/$user/;
      $filename  =~ s/\.cfg$//;
      my $function = $unix_commands{$filename};

      # print STDERR "1138 \$filename $filename\n";
      $function = "not_defined" if !defined $function;
      $line2_act =~ s/Function/$function/;
      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_memaggreg_day =~ s/COMMENT://;
      $line3_memaggreg_day =~ s/\\//g;
      push @table_out, $line3_memaggreg_day;
    }
    else {
      push @table_out, $line3_memaggreg;
    }

    # push  @table_out, $line3_memaggreg;
    # print STDERR "\@table_out @table_out\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /memaggreg_rq_disks/ || $item_ret =~ /memaggreg_busy_disks/ ) ) {    # other memaggreg_... see following if
                                                                                                                # prepare table for memaggreg
    my $line1_memaggreg = "<table class=\"tablesorter tablegend\" data-sortby='5 6'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">Disk serial</th>
  <th class=\"sortable header toleft\">ASP</th>
  <th class=\"sortable header\">AvrgRun&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2_memaggreg = "    <tr>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td class=\"toleft\">Subsystem</td>
  <td class=\"toleft\">User</td>
  <td>xorux_lpar_tavg</td>
  <td>xorux_lpar_avg</td>
  <td>xorux_lpar_max</td>
      </tr>";

    my $line3_memaggreg = "  </tbody>  </table>";

    my $line3_memaggreg_day = " </tbody>
    <tfoot>
      <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
    </tfoot> </table>\n";

    push @table_out, $line1_memaggreg;

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_memaggreg;
      ( my $average, undef, my $lpar_space ) = split( " $delimiter ", $print_line );
      ( $lpar_space, my $user, my $upid ) = split( " ", $lpar_space );
      $print_line = shift(@rrd_print);
      ( my $max, my $color, my $subtype, my $function, my $status, my $filename ) = split( " $delimiter ", $print_line );
      $print_line = shift(@rrd_print);
      ( my $avrgt, undef ) = split( " $delimiter ", $print_line );
      $avrgt = "0.00" if $avrgt =~ /NaNQ/;

      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_tavg/$avrgt/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      $filename  =~ s/\.mmc$//;
      $line2_act =~ s/>xorux_lpar_color/ data-job=\"$filename\">xorux_lpar_color/;
      $line2_act =~ s/xorux_lpar_color/$color/;
      $line2_act =~ s/Subsystem/$lpar_space/;
      $line2_act =~ s/User/$user/;
      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_memaggreg_day =~ s/COMMENT://;
      $line3_memaggreg_day =~ s/\\//g;
      push @table_out, $line3_memaggreg_day;
    }
    else {
      push @table_out, $line3_memaggreg;
    }

    # push  @table_out, $line3_memaggreg;
    # print STDERR "\@table_out @table_out\n";
    return $graphv_line;
  }

  if ( defined $item_ret && $item_ret =~ /dstrag_/ ) {    # other memaggreg_... see following if
                                                          # prepare table for memaggreg
    my $is_max1 = "";
    my $is_max2 = "";

    #my $is_type1 = "";
    #my $is_type2 = "";
    my $allocated_0 = "VMware alias";
    my $allocated   = "";

    $allocated = 'Datastore name &nbsp;&nbsp;&nbsp;&nbsp; [GB]'     if $item_ret =~ /dstrag_used/;
    $allocated = 'Datastore name'                                   if $item_ret =~ /dstrag_iops/;
    $allocated = 'Datastore name &nbsp;&nbsp;&nbsp;&nbsp; [MB/sec]' if $item_ret =~ /dstrag_data/;

    $is_max1 = "<th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>";
    $is_max2 = "<td>xorux_lpar_max</td>";

    my $line1_memaggreg = "<table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$allocated_0</th>
  <th class=\"sortable header toleft\">$allocated</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  $is_max1
      </tr>
    </thead>
    <tbody>";
    my $line2_memaggreg = "    <tr>
  <td class=\"legsq noclick\">xorux_lpar_color</td>
  <td class=\"toleft\">xorux_alias_name</td>
  <td class=\"clickabletd\">xorux_datastore_name</td>
  <td>xorux_lpar_avg</td>
  $is_max2
      </tr>";

    my $line3_memaggreg = "  </tbody>  </table>";

    my $line3_memaggreg_day = " </tbody>
    <tfoot>
      <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
    </tfoot> </table>\n";

    push @table_out, $line1_memaggreg;

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_memaggreg;

      # print STDERR "1056 \$print_line $print_line\n";
      ( my $average, undef, my $alias_name, my $datastore_name, my $color ) = split( " $delimiter ", $print_line );
      $print_line = shift(@rrd_print);

      # print STDERR "1059 \$print_line $print_line\n";
      ( my $max, my $datacenter_name, my $datastore_uuid ) = split( " $delimiter ", $print_line );
      $line2_act =~ s/xorux_lpar_max/$max/;

      my $lpar_space_show = $datastore_name;
      $lpar_space_show =~ s/&&1/\//g;

      #my $lpar_url = $lpar_space_show;
      my $query_lpar = $lpar_space_show;

      #if ( defined $rrd_file_all && $rrd_file_all ne "") left_curly
      if ( defined $datacenter_name && $datacenter_name ne "" ) {

        # my @pathx = split ("/",$rrd_file_all);
        # my $hmc_t = @pathx[@pathx - 2];
        # my $server_t = @pathx[@pathx - 3];
        # my $lpar_url = @pathx[@pathx - 1];
        # $lpar_url =~ s/\.rrs$//;
        # $lpar_url =~ s/\.rrt$//;
        #  $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=datastore&entitle=0&none=none\">$lpar_space_show</a>";
        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$datacenter_name&server=$alias_name&lpar=$datastore_name&item=datastore&entitle=0&none=none&d_platform=$params{d_platform}&datastore_uuid=$datastore_uuid\">$lpar_space_show</a>";
      }
      else {
        $line2_act =~ s/clickabletd/toleft/;    # Firmware , Available are not
      }
      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_datastore_name/$query_lpar/;
      $line2_act =~ s/xorux_alias_name/$alias_name/;
      $line2_act =~ s/xorux_lpar_color/$color/;

      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_memaggreg_day =~ s/COMMENT://;
      $line3_memaggreg_day =~ s/\\//g;
      push @table_out, $line3_memaggreg_day;
    }
    else {
      push @table_out, $line3_memaggreg;
    }

    #push  @table_out, $line3_memaggreg;
    # print STDERR "\@table_out @table_out\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /memaggreg/ || $item_ret =~ /wpar_mem/ || $item_ret =~ /wpar_cpu/ ) ) {    # also: memaggreg_threads, memaggreg_res, memaggreg_size
                                                                                                                      # prepare table for memaggreg
    my $is_max1   = "";
    my $is_max2   = "";
    my $is_type1  = "";
    my $is_type2  = "";
    my $allocated = 'Current allocated memory in GB&nbsp;&nbsp;';
    $allocated = 'Current granted memory in GB&nbsp;&nbsp;' if $vmware;
    $allocated = 'Current CPU load in cores&nbsp;&nbsp;'    if $item_ret =~ /wpar_cpu/;
    $allocated = 'Current used memory in GB&nbsp;&nbsp;'    if $item_ret =~ /wpar_mem/;

    if ( $item_ret =~ /wpar_/ ) {
      $is_max1 = "<th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>";
      $is_max2 = "<td>xorux_lpar_max</td>";
    }
    if ( $item_ret =~ /memaggreg_threads/ || $item_ret =~ /memaggreg_res/ ) {
      $allocated = 'Current number of threads&nbsp;&nbsp;&nbsp;' if $item_ret =~ /memaggreg_threads/;
      $is_max1   = "<th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>";
      $is_max2   = "<td>xorux_lpar_max</td>";
    }
    if ( $item_ret =~ /memaggreg_size/ ) {
      $is_max1  = "<th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>";
      $is_max2  = "<td>xorux_lpar_max</td>";
      $is_type1 = "<th class=\"sortable header\">type&nbsp;&nbsp;&nbsp;&nbsp;</th>";
      $is_type2 = "<td>xorux_lpar_type</td>";
    }

    my $line1_memaggreg = "<table class=\"tablesorter tablegend\" data-sortby='4 3'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$allocated</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  $is_max1
  $is_type1
      </tr>
    </thead>
    <tbody>";
    my $line2_memaggreg = "    <tr>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_lpar_avg</td>
  $is_max2
  $is_type2
      </tr>";

    my $line3_memaggreg = "  </tbody>  </table>";

    my $line3_memaggreg_day = " </tbody>
    <tfoot>
      <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
    </tfoot> </table>\n";

    push @table_out, $line1_memaggreg;

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_memaggreg;
      ( my $average, undef, my $lpar_space, my $color, my $rrd_file_all ) = split( " $delimiter ", $print_line );
      if ( !defined $color ) {
        $print_line = shift(@rrd_print);
        ( undef, $color, $rrd_file_all ) = split( " $delimiter ", $print_line );
      }

      if ( $item_ret =~ /memaggreg_threads/ || $item_ret =~ /memaggreg_res/ || $item_ret =~ /wpar_/ ) {
        $print_line = shift(@rrd_print);
        ( my $max ) = split( " $delimiter", $print_line );
        $line2_act =~ s/xorux_lpar_max/$max/;
      }
      if ( $item_ret =~ /memaggreg_size/ ) {
        $print_line = shift(@rrd_print);
        ( my $max ) = split( " $delimiter", $print_line );
        $line2_act =~ s/xorux_lpar_max/$max/;
        $print_line = shift(@rrd_print);
        ( my $type ) = split( " $delimiter", $print_line );
        my $type_txt = "*other";
        if ( $type !~ /NaNQ/ ) {
          $type_txt = "*FIXED" if $type == 0;    # see lpar2rrd-daemon.pl - AS400 section
          $type_txt = "*SAME"  if $type == 1;
          $type_txt = "*CALC"  if $type == 2;
        }
        else {
          $type_txt = "";
        }
        $line2_act =~ s/xorux_lpar_type/$type_txt/;
      }

      my $lpar_space_show = $lpar_space;
      $lpar_space_show =~ s/&&1/\//g;
      my $lpar_url   = $lpar_space_show;
      my $query_lpar = $lpar_space_show;
      if ( defined $rrd_file_all && $rrd_file_all ne "" ) {
        my @pathx    = split( "/", $rrd_file_all );
        my $hmc_t    = @pathx[ @pathx - 2 ];
        my $server_t = @pathx[ @pathx - 3 ];

        # $lpar_url =~ s/ /\+/g;
        # $lpar_url =~ s/([^A-Za-z0-9\+-_])/sprintf("%%%02X", ord($1))/seg; # PH: keep it is it is exactly!!!
        # $lpar_url =~ s/\#/%23/g;
        $lpar_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;
        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=lpar&entitle=0&none=none&d_platform=$params{d_platform}\">$lpar_space_show</a>";
      }
      else {
        $line2_act =~ s/clickabletd/toleft/;    # Firmware , Available are not
      }
      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_name/$query_lpar/;
      $line2_act =~ s/xorux_lpar_color/$color/;
      if ( $lpar_space =~ "Available memory" ) {
        $line2_act = "<tfoot>" . $line2_act . "</tfoot>";
      }
      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_memaggreg_day =~ s/COMMENT://;
      $line3_memaggreg_day =~ s/\\//g;
      push @table_out, $line3_memaggreg_day;
    }
    else {
      push @table_out, $line3_memaggreg;
    }

    #push  @table_out, $line3_memaggreg;
    # print STDERR "\@table_out @table_out\n";
    return $graphv_line;
  }

  if ( defined $item_ret && $item_ret =~ /pagingagg/ ) {

    # prepare table for paging aggregated
    my $line1_osmem_agg = "<table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
  <th class=\"sortable header toleft\">[MB/s]</th>
  <th>READ</th>
  <th class=\"sortable header\">AVG&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">MAX&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>WRITE</th>
  <th class=\"sortable header\">AVG&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">MAX&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line2_osmem_agg = "   <tr>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_lpar_color_read</td>
  <td>xorux_lpar_avg_read</td>
  <td>xorux_lpar_max_read</td>
  <td class=\"legsq\">xorux_lpar_color_write</td>
  <td>xorux_lpar_avg_write</td>
  <td>xorux_lpar_max_write</td>
      </tr>\n";
    my $line3_osmem_agg = " </tbody> </table>\n";

    push @table_out, $line1_osmem_agg;

    # print STDERR "pagingagg \@rrd_print @rrd_print\n";

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_osmem_agg;
      ( my $average_read, undef, my $lpar_space, my $color_read, my $rrd_file_all ) = split( " $delimiter ", $print_line );

      $print_line = shift(@rrd_print);
      ( my $max_read, undef ) = split( "$delimiter", $print_line );

      $print_line = shift(@rrd_print);
      ( my $average_write, my $color_write ) = split( "$delimiter", $print_line );

      $print_line = shift(@rrd_print);
      ( my $max_write, undef ) = split( "$delimiter", $print_line );

      my $lpar_space_show = $lpar_space;
      $lpar_space_show =~ s/&&1/\//g;
      my $lpar_url = $lpar_space_show;
      my @pathx    = split( "/", $rrd_file_all );
      my $hmc_t    = @pathx[ @pathx - 3 ];
      my $server_t = @pathx[ @pathx - 4 ];

      # $lpar_url =~ s/ /\+/g;
      # $lpar_url =~ s/([^A-Za-z0-9\+-_])/sprintf("%%%02X", ord($1))/seg; # PH: keep it is it is exactly!!!
      # $lpar_url =~ s/\#/%23/g;
      $lpar_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;

      my $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=lpar&entitle=0&none=none\">$lpar_space_show</a>";

      $line2_act =~ s/xorux_lpar_name/$query_lpar/;
      $line2_act =~ s/xorux_lpar_color_read/$color_read/;
      $line2_act =~ s/xorux_lpar_avg_read/$average_read/;
      $line2_act =~ s/xorux_lpar_max_read/$max_read/;
      $line2_act =~ s/xorux_lpar_color_write/$color_write/;
      $line2_act =~ s/xorux_lpar_avg_write/$average_write/;
      $line2_act =~ s/xorux_lpar_max_write/$max_write/;
      push @table_out, $line2_act;
    }
    push @table_out, $line3_osmem_agg;
    return $graphv_line;
  }

  if ( defined $item_ret && $item_ret =~ / lan/ || $item_ret =~ / san1/ || $item_ret =~ / san2 $/ || $item_ret =~ /sea/ || $item_ret =~ /san_resp/ || $item_ret =~ /faults/ || $item_ret =~ /pages/ || $item_ret =~ /data_as/ || $item_ret =~ /iops_as/ || $item_ret =~ /data_ifcb/ || $item_ret =~ /paket_ifcb/ || $item_ret =~ /packets_lan/ || $item_ret =~ /packets_sea/ || $item_ret =~ /vmw-iops/ || $item_ret =~ /ds-vmiops/ || $item_ret =~ /hitachi-lan-totals/ || $item_ret =~ /hitachi-san-totals/ || $item_ret =~ /power_san/ || $item_ret =~ /power_lan/ || $item_ret =~ /power_sas/ || $item_ret =~ /power_hea/ || $item_ret =~ /power_sri/ || $item_ret =~ /solaris_ldom_net/ || $item_ret =~ /solaris_ldom_san1/ || $item_ret =~ /solaris_ldom_san2/ || $item_ret =~ /solaris_ldom_san_resp/ || $item_ret =~ /solaris_ldom_pack/ || $item_ret =~ /san_no_ldom1/ || $item_ret =~ /solaris_ldom_vnet/ || $item_ret =~ /clustlan/ || $item_ret =~ /s2d_volume_agr_/ || $item_ret =~ /sarmon_san/ || $item_ret =~ /sarmon_iops/ || $item_ret =~ /sarmon_latency/ || $item_ret =~ /hdt_latency/ || $item_ret =~ /error/ ) {
    my $Int = "Int";
    $Int = "   "       if ( $item_ret =~ /data_as/ || $item_ret =~ /iops_as/ || $item_ret =~ /data_ifcb/ || $item_ret =~ /paket_ifcb/ );
    $Int = "Datastore" if $item_ret =~ /vmw-iops/;
    $Int = "VM "       if $item_ret =~ /ds-vmiops/;
    $Int = "server"    if $item_ret =~ /clustlan/;
    $Int = "Volume"    if $item_ret =~ /s2d_volume_agr_/;
    $Int = "Disk"      if $item_ret =~ /hdt_latency/;

    # prepare table for LAN SAN1 SAN2 SEA SAN_RESP FAULT(AS400) PAGES(AS400)

    my $line1_lan = "<p class='custom0'>[MB/sec]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int</th>
  <th>READ\</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>WRITE\</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_data = "<p class='custom0'>[MB/sec]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int</th>
        <th class=\"toleft\">Location\</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg</th>
        <th class=\"sortable header toleft\">Max</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg</th>
        <th class=\"sortable header toleft\">Max</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_hea_data = "<p class='custom0'>[MB/sec]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_hea_io = "<p class='custom0'>[Packets/sec]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_lan_io = "<p class='custom0'>[Packets/sec]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int</th>
        <th class=\"toleft\">Location\</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_san_io = "<p class='custom0'>[IOPS]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int</th>
        <th class=\"toleft\">Location\</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_sas_io = "<p class='custom0'>[IOPS]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int</th>
        <th class=\"toleft\">Location\</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_sri_io = "<p class='custom0'>[Packets/sec]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int (Lpar)</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_power_sri_data = "<p class='custom0'>[MB/s]</p>
    <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Int (Lpar)</th>
        <th>READ\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>WRITE\</th>
        <th class=\"sortable header toleft\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header toleft\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line1_san1 = "<p class='custom0'>[MB/sec]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
  <th class=\"sortable header toleft\">$Int</th>
  <th>READ</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>WRITE</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line1_san2 = "<p class='custom0'>[$iops]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
      <tr>
  <th class=\"sortable header toleft\">$Int</th>
  <th>READ</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>WRITE</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line1_san_resp = "<p class='custom0'>[ms]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
      <tr>
  <th class=\"sortable header toleft\">Int</th>
  <th>READ</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>WRITE</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line2_san_resp = "<p class='custom0'>[ms]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
      <tr>
  <th class=\"sortable header toleft\">Int</th>
  <th>READ/WRITE</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line_san_fcs_error = "<p class='custom0'></p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
      <tr>
  <th class=\"sortable header toleft\">Int</th>
  <th>ERROR</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line_san_fcs_error_aggr = "<p class='custom0'></p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
      <tr>
  <th class=\"sortable header toleft\">LPAR name</th>
  <th class=\"sortable header toleft\">FC</th>
  <th>ERROR</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line1_s2d_lat = "<p class='custom0'>[ms]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
  <th class=\"sortable header toleft\">$Int</th>
  <th>READ</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>WRITE</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line1_sea = "<p class='custom0'>[MB/sec]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
  <th class=\"sortable header toleft\">Phys (SEA)</th>
  <th>READ\</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>WRITE\</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";
    my $line1_faults = "
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">Name</th>
  <th>DB</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>non\/DB</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n";

    my $line2_lan = "   <tr>
  <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_lpar_color_read</td>
  <td>xorux_lpar_avg_read</td>
  <td>xorux_lpar_max_read&nbsp;&nbsp;&nbsp;&nbsp;</td>
  <td class=\"legsq\">xorux_lpar_color_write</td>
  <td>xorux_lpar_avg_write</td>
  <td>xorux_lpar_max_write</td>
      </tr>\n";

    my $line2_san_resp1 = "   <tr>
  <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_lpar_color_read</td>
  <td>xorux_lpar_avg_read</td>
  <td>xorux_lpar_max_read&nbsp;&nbsp;&nbsp;&nbsp;</td>
      </tr>\n";

    my $line2_san_fc_err = "   <tr>
  <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
  <td title=\"bubble_info\" class=\"toleft\">xorux_fcs_name</td>
  <td class=\"legsq\">xorux_lpar_color_read</td>
  <td>xorux_lpar_avg_read</td>
  <td>xorux_lpar_max_read&nbsp;&nbsp;&nbsp;&nbsp;</td>
      </tr>\n";

    my $line2_power_lan = "
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"toleft\">xorux_physical_location</td>
        <td class=\"legsq\">xorux_lpar_color_read</td>
        <td class=\"toleft\">xorux_lpar_avg_read</td>
        <td class=\"toleft\">xorux_lpar_max_read&nbsp;&nbsp;&nbsp;&nbsp;</td>
        <td class=\"legsq\">xorux_lpar_color_write</td>
        <td class=\"toleft\">xorux_lpar_avg_write</td>
        <td class=\"toleft\">xorux_lpar_max_write</td>
      </tr>\n";
    my $line2_power_sri = "
      <tr>
        <td class=\"toleft\">xorux_physical_location</td>
        <td class=\"legsq\">xorux_lpar_color_read</td>
        <td class=\"toleft\">xorux_lpar_avg_read</td>
        <td class=\"toleft\">xorux_lpar_max_read&nbsp;&nbsp;&nbsp;&nbsp;</td>
        <td class=\"legsq\">xorux_lpar_color_write</td>
        <td class=\"toleft\">xorux_lpar_avg_write</td>
        <td class=\"toleft\">xorux_lpar_max_write</td>
      </tr>\n";

    my $line2_power_hea = "
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_lpar_color_read</td>
        <td class=\"toleft\">xorux_lpar_avg_read</td>
        <td class=\"toleft\">xorux_lpar_max_read&nbsp;&nbsp;&nbsp;&nbsp;</td>
        <td class=\"legsq\">xorux_lpar_color_write</td>
        <td class=\"toleft\">xorux_lpar_avg_write</td>
        <td class=\"toleft\">xorux_lpar_max_write</td>
      </tr>\n";

    my $line3_lan = " </tbody> </table>\n";

    my $line3_lan_day = " </tbody>
    <tfoot><tr>
      <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
    </tr> </tfoot> </table>\n";

    #print STDERR "line2955 \$item_ret:$item_ret\n";
    if    ( $item_ret =~ /san_resp|error|lan/ )                                           { $item_ret =~ s/^\s+|\s+$//g; }
    if    ( $item_ret =~ /power_lan/ && $rest_api_type eq "data" )                        { push @table_out, $line1_power_data; }
    elsif ( $item_ret =~ /power_lan/ && $rest_api_type eq "packets" )                     { push @table_out, $line1_power_lan_io; }
    elsif ( $item_ret =~ /power_san/ && $rest_api_type eq "data" )                        { push @table_out, $line1_power_data; }
    elsif ( $item_ret =~ /power_san/ && $rest_api_type eq "packets" )                     { push @table_out, $line1_power_san_io; }
    elsif ( $item_ret =~ /power_hea/ && $rest_api_type eq "data" )                        { push @table_out, $line1_power_hea_data; }
    elsif ( $item_ret =~ /power_hea/ && $rest_api_type eq "packets" )                     { push @table_out, $line1_power_hea_io; }
    elsif ( $item_ret =~ /power_sas/ && $rest_api_type eq "data" )                        { push @table_out, $line1_power_data; }
    elsif ( $item_ret =~ /power_sas/ && $rest_api_type eq "packets" )                     { push @table_out, $line1_power_sas_io; }
    elsif ( $item_ret =~ /power_sri/ && $rest_api_type eq "data" )                        { push @table_out, $line1_power_sri_data; }
    elsif ( $item_ret =~ /power_sri/ && $rest_api_type eq "packets" )                     { push @table_out, $line1_power_sri_io; }
    elsif ( $item_ret =~ /^lan/ && $item_ret !~ /packets/ && $item_ret !~ /clustlan/ )    { push @table_out, $line1_lan; }
    elsif ( $item_ret =~ /clustlan/ )                                                     { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /solaris_ldom_net|solaris_ldom_vnet/ && $item_ret !~ /packets/ ) { push @table_out, $line1_lan; }
    elsif ( $item_ret =~ /hitachi-san-totals/ )                                           { push @table_out, $line1_lan; }
    elsif ( $item_ret =~ /sea/ && $item_ret !~ /packets/ )                                { push @table_out, $line1_sea; }
    elsif ( $item_ret =~ /san1/ )                                                         { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /san2 $/ )                                                       { push @table_out, $line1_san2; }
    elsif ( $item_ret =~ /solaris_ldom_san1/ )                                            { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /solaris_ldom_san2/ )                                            { push @table_out, $line1_san2; }
    elsif ( $item_ret =~ /san_no_ldom1/ )                                                 { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /san_no_ldom2/ )                                                 { push @table_out, $line1_san2; }
    elsif ( $item_ret =~ /^san_resp/ )                                                    { push @table_out, $line1_san_resp; }
    elsif ( $item_ret =~ /^solaris_ldom_san_resp/ )                                       { push @table_out, $line2_san_resp; }
    elsif ( $item_ret =~ /^error_san$/ )                                                  { push @table_out, $line_san_fcs_error; }
    elsif ( $item_ret =~ /^error_lan$/ )                                                  { push @table_out, $line_san_fcs_error; }
    elsif ( $item_ret =~ /^error_aggr$/ )                                                 { push @table_out, $line_san_fcs_error_aggr; }
    elsif ( $item_ret =~ /faults/ )                                                       { push @table_out, $line1_faults; }
    elsif ( $item_ret =~ /pages/ )                                                        { push @table_out, $line1_faults; }
    elsif ( $item_ret =~ /data_as/ )                                                      { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /iops_as/ )                                                      { push @table_out, $line1_san2; }
    elsif ( $item_ret =~ /data_ifcb/ )                                                    { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /vmw-iops/ )                                                     { push @table_out, $line1_san2; }
    elsif ( $item_ret =~ /ds-vmiops/ )                                                    { push @table_out, $line1_san2; }
    elsif ( $item_ret =~ /paket_ifcb/ || $item_ret =~ /packets_lan/ || $item_ret =~ /packets_sea/ || $item_ret =~ /solaris_ldom_pack/ ) {
      $line1_san1 =~ s/MB/Packets/;
      push @table_out, $line1_san1;
    }
    elsif ( $item_ret =~ /s2d_volume_agr_iops/ )    { push @table_out, $line1_san2; }
    elsif ( $item_ret =~ /s2d_volume_agr_data/ )    { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /s2d_volume_agr_latency/ ) { push @table_out, $line1_s2d_lat; }
    elsif ( $item_ret =~ /sarmon_san/ )             { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /sarmon_iops/ )            { push @table_out, $line1_san1; }
    elsif ( $item_ret =~ /sarmon_latency/ )         { push @table_out, $line1_san1; }

    #    elsif ( $item_ret =~ /hdt_latency/ )            { push @table_out, $line1_san_resp; }
    elsif ( $item_ret =~ /hdt_latency/ ) { push @table_out, $line1_s2d_lat; }

    #    print STDERR Dumper(@rrd_print) . "\n";
    my $sriov_aliases;
    if ( -f "$basedir/data/$server/$host/sriov_aliases.json" ) {
      $sriov_aliases = read_json("$basedir/data/$server/$host/sriov_aliases.json");
    }
    my @rrd_print1 = @rrd_print;
    if ( $item_ret =~ /^solaris_ldom_san_resp/ || $item_ret =~ /^error_san$/ || $item_ret =~ /^error_lan$/ ) {
      while ( my $print_line1 = shift(@rrd_print1) ) {
        my $line2_act = $line2_san_resp1;
        ( my $average_read, undef, my $lpar_space, my $color_read, my $rrd_file_all ) = split( " $delimiter ", $print_line1 );
        if ( $lpar_space =~ m/\.$/ ) {
          $lpar_space = substr( $lpar_space, 0, -1 );
        }
        $print_line1 = shift(@rrd_print1);
        ( my $max_read, my $bubble_info ) = split( "$delimiter", $print_line1 );
        my $lpar_space_show = $lpar_space;
        $lpar_space_show =~ s/&&1/\//g;
        $line2_act       =~ s/xorux_lpar_name/$lpar_space_show/;
        $line2_act       =~ s/xorux_lpar_color_read/$color_read/;
        $line2_act       =~ s/xorux_lpar_avg_read/$average_read/;
        $line2_act       =~ s/xorux_lpar_max_read/$max_read/;
        $line2_act       =~ s/bubble_info/$bubble_info/;
        push @table_out, $line2_act;
      }
    }
    if ( $item_ret =~ /^error_aggr$/ ) {
      while ( my $print_line1 = shift(@rrd_print1) ) {
        my $line2_act = $line2_san_fc_err;
        ( my $average_read, undef, my $lpar_space, my $fcs_name, my $color_read, my $rrd_file_all ) = split( " $delimiter ", $print_line1 );
        if ( $lpar_space =~ m/\.$/ ) {
          $lpar_space = substr( $lpar_space, 0, -1 );
        }
        $print_line1 = shift(@rrd_print1);
        ( my $max_read, my $bubble_info ) = split( "$delimiter", $print_line1 );
        my $lpar_space_show = $lpar_space;
        $lpar_space_show =~ s/^\s+|\s+$//g;
        $lpar_space_show =~ s/&&1/\//g;
        my $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$host&server=$server&lpar=$lpar_space_show&item=lpar&entitle=0&none=none\">$lpar_space</a>";
        $line2_act =~ s/xorux_lpar_name/$query_lpar/;
        $line2_act =~ s/xorux_fcs_name/$fcs_name/;
        $line2_act =~ s/xorux_lpar_color_read/$color_read/;
        $line2_act =~ s/xorux_lpar_avg_read/$average_read/;
        $line2_act =~ s/xorux_lpar_max_read/$max_read/;
        $line2_act =~ s/bubble_info/$bubble_info/;
        push @table_out, $line2_act;
      }
    }
    if ( $item_ret !~ /error/ && $item_ret !~ /solaris_ldom_san_resp/ ) {
      while ( my $print_line = shift(@rrd_print) ) {
        my $line2_act;
        $line2_act = $line2_lan;
        if ( $item_ret =~ /power_lan/ || $item_ret =~ /power_san/ || $item_ret =~ /power_sas/ ) {
          $line2_act = $line2_power_lan;
        }
        if ( $item_ret =~ /power_hea/ ) {
          $line2_act = $line2_power_hea;
        }
        if ( $item_ret =~ /power_sri/ ) {
          $line2_act = $line2_power_sri;
        }

        #print STDERR"$print_line\n!!!";
        my $average_read;
        my $physical_location;
        my $lpar_space;
        my $color_read;
        my $rrd_file_all;
        if ( $item_ret =~ /power_/ ) {
          ( $average_read, undef, $physical_location, $lpar_space, $color_read, $rrd_file_all ) = split( " $delimiter ", $print_line );
        }
        else {
          ( $average_read, undef, $lpar_space, $color_read, $rrd_file_all ) = split( " $delimiter ", $print_line );
        }
        if ( ( ( !defined $rrd_file_all ) or ( $rrd_file_all eq "" ) or ( $rrd_file_all eq " " ) ) && ( $item_ret !~ m/^ power/ && $item_ret !~ m/ faults / && $item_ret !~ m/ pages / ) ) {
          $rrd_file_all = shift(@rrd_print);
          ( undef, $rrd_file_all ) = split( "$delimiter", $rrd_file_all );
        }
        if ( $lpar_space =~ m/\.$/ ) {
          $lpar_space = substr( $lpar_space, 0, -1 );
        }
        if ( $item_ret =~ /power_sri/ ) {
          if ( defined $sriov_aliases->{$lpar_space} && $sriov_aliases->{$lpar_space} ne "" ) {
            $lpar_space = "$lpar_space ($sriov_aliases->{$lpar_space})";
          }
          else {
            $lpar_space = "$lpar_space";
          }
        }
        $print_line = shift(@rrd_print);
        ( my $max_read, my $bubble_info ) = split( "$delimiter", $print_line );
        $bubble_info = "" if $bubble_info eq " ";
        $bubble_info = "" if $item_ret =~ "hitachi";    # empty string -> lpar_name will be showed
                                                        # print STDERR "1168 \$bubble_info $bubble_info\n";

        $print_line = shift(@rrd_print);
        ( my $average_write, my $color_write ) = split( "$delimiter", $print_line );

        $print_line = shift(@rrd_print);
        ( my $max_write, my $vm_dbi_uuid ) = split( " $delimiter ", $print_line );

        my $lpar_space_show = $lpar_space;
        $lpar_space_show =~ s/&&1/\//g;
        if ( $item_ret =~ /power_/ ) {
          my $test;
          if ( $item_ret =~ /power_sri/ ) {
            ( $test, undef ) = split( " \\(", $lpar_space );
          }
          else {
            $test = $lpar_space;
          }
          $test     =~ s/-S[0-9]*$//g;
          $item_ret =~ s/^\s+|\s+$//g;
          my $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$host&server=$server&lpar=$test&item=$item_ret&entitle=0&none=none\">$lpar_space</a>";

          # lpar2rrd-cgi/detail.sh?host=vhmc &server=P02DR__9117-MMC-SN44K8102&lpar=44K8102-V1-C5-T1.ralm&item=power_lan&entitl
          if ( $item_ret !~ /power_sri/ ) {
            $line2_act =~ s/xorux_lpar_name/$query_lpar/;
          }
          else {
            $line2_act =~ s/xorux_physical_location/$query_lpar/;
          }
        }
        if ( $item_ret =~ /ds-vmiops/ ) {
          my $vcenter_host = get_vcenter_host($server);

          # print STDERR "2662 \$server $server \$lpar $lpar \$item $item \$vm_dbi_uuid $vm_dbi_uuid\n";
          my $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$vcenter_host&server=&lpar=$lpar_space&item=vmw-iops&entitle=0&none=none&d_platform=VMware&vm_dbi_uuid=$vm_dbi_uuid\">$lpar_space_show</a>";
          if ( $vm_dbi_uuid eq "does_not_exist" ) {    # is not clickable
            $query_lpar = "<a>$lpar_space_show</a>";
          }
          $line2_act =~ s/xorux_lpar_name/$query_lpar/;
        }
        else {
          $line2_act =~ s/xorux_lpar_name/$lpar_space_show/;
        }
        $line2_act =~ s/xorux_lpar_color_read/$color_read/;
        $line2_act =~ s/xorux_physical_location/$physical_location/;
        $line2_act =~ s/xorux_lpar_avg_read/$average_read/;
        $line2_act =~ s/xorux_lpar_max_read/$max_read/;
        $line2_act =~ s/xorux_lpar_color_write/$color_write/;
        $line2_act =~ s/xorux_lpar_avg_write/$average_write/;
        $line2_act =~ s/xorux_lpar_max_write/$max_write/;
        $line2_act =~ s/bubble_info/$bubble_info/;

        # print STDERR "1182 \$line2_act $line2_act \$bubble_info ,$bubble_info,\n";
        # do not print the legend SAN, SAN IOPS (san2) & SAN RESP if Fcs has all 4 numbers undefined
        # e.g. LPAR has been migrated to other HW without some Fcs
        if ( $item_ret =~ /san2 $|san1|san_resp/ ) {

          # print STDERR "2477 \$line2_act $line2_act \$bubble_info ,$bubble_info,\n";
          my $littlestring = "nan|NaN";
          my @matches      = $line2_act =~ /($littlestring)/g;
          my $count        = scalar @matches;
          next if $count eq "4";
        }
        push @table_out, $line2_act;
      }
    }
    if ( $updated =~ /Updated/ ) {
      $line3_lan_day =~ s/COMMENT://;
      $line3_lan_day =~ s/\\//g;
      push @table_out, $line3_lan_day;
    }
    else {
      push @table_out, $line3_lan;
    }

    # print STDERR "1024 @table_out\n";
    return $graphv_line;
  }

  # XenServer
  if ( defined $item_ret && ( $item_ret =~ /(xen-(.*)-aggr|custom-xenvm-(.*))/ ) ) {
    my @header;
    my $units;
    my $column_count = 7;
    my $link_type    = '';

    if ( $item_ret =~ /(vbd|lan)/ ) {
      $column_count = 8;
      if ( $item_ret =~ /xenvm/ ) {
        @header    = ( 'Pool', 'VM', 'READ', 'WRITE' );
        $link_type = 'vm';
      }
      else {    # xen-(lan|disk)
        if ( $item_ret =~ /lan/ ) {
          @header = ( 'Host', 'Int', 'READ', 'WRITE' );
        }
        else {    # xen-disk
          @header = ( 'Host', 'Storage', 'READ', 'WRITE' );
        }
      }
      if    ( $item_ret =~ /lan/ )     { $units = '[MB/sec]'; }
      elsif ( $item_ret =~ /latency/ ) { $units = '[millisec]'; }
      elsif ( $item_ret =~ /iops/ )    { $units = '[IOPS]'; }
      else                             { $units = '[MiB/sec]'; }
    }
    elsif ( $item_ret =~ /xen-host-(cpu-percent|cpu-cores|memory-used|memory-free)-aggr/ ) {
      $column_count = 4;
      @header       = ( 'Host', '', '', '' );
      $link_type    = 'host';

      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
      else                                 { $units = '[GiB]'; }
    }
    elsif ( $item_ret =~ /(xen-vm|xen-host-vm|custom-xenvm)-(cpu-percent|cpu-cores|memory-used|memory-free)/ ) {
      $column_count = 5;
      if ( $item_ret =~ /custom-xenvm/ ) {
        @header = ( 'Pool', 'VM', '', '' );
      }
      else {
        @header = ( 'Host', 'VM', '', '' );
      }
      $link_type = 'vm';

      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
      else                                 { $units = '[GiB]'; }
    }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
  <th>$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>$header[2]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END

    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th>$header[2]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>$header[3]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_7col = <<END;
      <tr>
  <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_row_8col = <<END;
      <tr>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }

      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      if ( $link_type ne '' ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = XenServerMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\" class=\"backlink\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }
      $table_row =~ s/xorux_val1_color/$val1_color/;
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }

      push @table_out, $table_row;
    }

    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # Nutanix
  if ( defined $item_ret && ( $item_ret =~ /(nutanix-(.*)-aggr|custom-nutanixvm-(.*))/ ) ) {
    my @header       = [];
    my $units        = '';
    my $column_count = 7;
    my $link_type    = '';

    if ( $item_ret =~ /(vbd|lan)/ ) {
      $column_count = 8;
      if ( $item_ret =~ /nutanixvm/ || $item_ret =~ /nutanix-vm/ ) {
        if ( $item_ret =~ /vbd-aggr/ ) {
          @header       = ( 'Cluster', 'VM', 'Total', '' );
          $column_count = 5;
        }
        else {
          @header = ( 'Cluster', 'VM', 'READ', 'WRITE' );
        }
        $link_type = 'vm';
      }
      elsif ( $item_ret =~ /sp-aggr/ ) {
        if ( $item_ret =~ /latency-sp-aggr/ ) {
          @header       = ( 'Cluster', 'Storage Pool', 'Total', '' );
          $column_count = 5;
        }
        else {
          @header = ( 'Cluster', 'Storage Pool', 'READ', 'WRITE' );
        }
        $link_type = 'sp';
      }
      elsif ( $item_ret =~ /vg-aggr/ ) {
        if ( $item_ret =~ /latency-vg-aggr/ ) {
          @header       = ( 'Cluster', 'Volume Group', 'Total', '' );
          $column_count = 5;
        }
        else {
          @header = ( 'Cluster', 'Volume Group', 'READ', 'WRITE' );
        }
        $link_type = 'vg';
      }
      elsif ( $item_ret =~ /vd-aggr/ ) {
        if ( $item_ret =~ /latency-vd-aggr/ ) {
          @header       = ( 'Cluster', 'Virtual Disk', 'Total', '' );
          $column_count = 5;
        }
        else {
          @header = ( 'Cluster', 'Virtual Disk', 'READ', 'WRITE' );
        }
        $link_type = 'vd';
      }
      elsif ( $item_ret =~ /sc-aggr/ ) {
        if ( $item_ret =~ /latency-sc-aggr/ ) {
          @header       = ( 'Cluster', 'Storage Container', 'Total', '' );
          $column_count = 5;
        }
        else {
          @header = ( 'Cluster', 'Storage Container', 'READ', 'WRITE' );
        }
        $link_type = 'sc';
      }
      elsif ( $item_ret =~ /sr-aggr/ ) {
        if ( $item_ret =~ /latency-sr-aggr/ ) {
          @header       = ( 'Host', 'Disk', 'Total', '' );
          $column_count = 5;
        }
        else {
          @header = ( 'Host', 'Disk', 'READ', 'WRITE' );
        }
        $link_type = 'sr';
      }
      elsif ( $item_ret =~ /vbd-latency-aggr/ ) {
        if ( $item_ret =~ /vbd-latency-aggr/ ) {
          @header       = ( 'Host', 'Storage', 'Total', '' );
          $column_count = 5;
        }
        else {
          @header = ( 'Host', 'Storage', 'READ', 'WRITE' );
        }
        $link_type = 'storage';
      }
      else {    # nutanix-(lan|disk)
        if ( $item_ret =~ /lan/ ) {
          @header = ( 'Host', 'Int', 'READ', 'WRITE' );
        }
        else {    # nutanix-disk
          @header    = ( 'Host', 'Disk', 'READ', 'WRITE' );
          $link_type = 'storage';
        }
      }
      if    ( $item_ret =~ /lan/ )     { $units = '[MB/sec]'; }
      elsif ( $item_ret =~ /latency/ ) { $units = '[millisec]'; }
      elsif ( $item_ret =~ /iops/ )    { $units = '[IOPS]'; }
      else                             { $units = '[MB/sec]'; }
    }
    elsif ( $item_ret =~ /nutanix-host-(cpu-percent|cpu-cores|memory-used|memory-free)-aggr/ ) {
      $column_count = 4;
      @header       = ( 'Host', '', '', '' );
      $link_type    = 'host';
      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
      else                                 { $units = '[GB]'; }
    }
    elsif ( $item_ret =~ /(nutanix-vm|nutanix-host-vm|custom-nutanixvm)-(cpu-percent|vbd-aggr|cpu-cores|memory-used|memory-free)/ ) {
      $column_count = 5;
      if ( $item_ret =~ /custom-nutanixvm/ ) {
        @header = ( 'Cluster', 'VM', '', '' );
      }
      else {
        @header = ( 'Host', 'VM', '', '' );
      }
      $link_type = 'vm';
      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
      else                                 { $units = '[GB]'; }
    }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END

    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END

    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' ) {
        $uuid =~ s/^\s+|\s+$//g;
        $uuid =~ s/\/sys//g;

        if ( $uuid =~ /disk/ ) {
          my @split = split( /\/disk-/, $uuid );
          $uuid = $split[1];
        }

        my $link_url = NutanixMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;
        $item      =~ s/custom-nutanixvm/nutanix-vm/g;
        $item      =~ s/memory-used/memory/g;
        $item      =~ s/memory-free/memory/g;

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=nutanix&server=$uuid&lpar=$uuid&item=$item&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }

      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }

      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # AWS
  if ( defined $item_ret && ( $item_ret =~ /(aws-(.*)-aggr|custom-aws-ec2-(.*))/ ) ) {
    my @header       = [];
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    @header = ( 'Region', 'EC2', 'READ', 'WRITE' );

    if ( $item_ret =~ /(data|net|(rds)-latency|lan|iops)/ ) {
      $column_count = 8;
      if ( $item_ret =~ /ec2/ ) {
        @header    = ( 'Region', 'EC2', 'READ', 'WRITE' );
        $link_type = 'ec2';
      }
      elsif ( $item_ret =~ /ebs/ ) {
        @header    = ( 'Region', 'EBS', 'READ', 'WRITE' );
        $link_type = 'ebs';
      }
      elsif ( $item_ret =~ /rds/ ) {
        @header    = ( 'Region', 'RDS', 'READ', 'WRITE' );
        $link_type = 'rds';
      }
      if    ( $item_ret =~ /net/ )  { $units = '[MB/sec]'; }
      elsif ( $item_ret =~ /iops/ ) { $units = '[IOPS]'; }
      else                          { $units = '[MB/sec]'; }
    }
    elsif ( $item_ret =~ /aws-(region|ec2)-(cpu-percent|cpu-cores|cores|cpu|memory-used|memory-free)-aggr/ ) {
      $column_count = 5;
      @header       = ( 'Region', 'EC2', '', '' );
      $link_type    = 'ec2';

      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
      else                                 { $units = '[GB]'; }
    }
    elsif ( $item_ret =~ /aws-region-(stopped|running)-aggr/ ) {
      $column_count = 4;
      @header       = ( 'Region', '', '' );

      #$link_type = 'ec2';
      $units = '[Count]';
    }
    elsif ( $item_ret =~ /(aws-ec2|custom-aws-ec2|aws-rds)-(cpu-percent|vbd-aggr|cpu-cores|memory-used|memory-free)/ ) {
      $column_count = 5;
      if ( $item_ret =~ /custom-aws-ec2/ ) {
        @header = ( 'Region', 'EC2', '', '' );
      }
      elsif ( $item_ret =~ /aws-rds/ ) {
        @header = ( 'Region', 'RDS', '', '' );
      }
      else {
        @header = ( 'Region', 'EC2', '', '' );
      }
      $link_type = 'ec2';
      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
    }
    elsif ( $item_ret =~ /(aws-rds)-(db-connection|mem-free|disk-free)/ ) {
      @header       = ( 'Region', 'RDS', '', '' );
      $column_count = 5;
      $link_type    = 'rds';
    }
    elsif ( $item_ret =~ /aws-api/ ) {
      @header       = ( 'Region', 'API', '', '' );
      $column_count = 5;
      $link_type    = 'api';
    }
    elsif ( $item_ret =~ /aws-lambda/ ) {
      @header       = ( 'Region', 'Lambda', '', '' );
      $column_count = 5;
      $link_type    = 'lambda';
    }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END

    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = AWSMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=aws&server=$uuid&lpar=$uuid&item=$item&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }

      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }

      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # GCloud
  if ( defined $item_ret && ( $item_ret =~ /(gcloud-(.*)-aggr|custom-gcloud-compute-(.*))/ ) ) {
    my @header       = [];
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    @header = ( 'Region', 'Compute Engine', 'READ', 'WRITE' );

    if ( $item_ret =~ /(data|net|lan|iops)/ ) {
      $column_count = 8;
      if ( $item_ret =~ /compute/ ) {
        @header    = ( 'Region', 'Compute Engine', 'READ', 'WRITE' );
        $link_type = 'compute';
      }
      if    ( $item_ret =~ /net|lan/ ) { $units = '[MB/sec]'; }
      elsif ( $item_ret =~ /iops/ )    { $units = '[IOPS]'; }
      else                             { $units = '[MB/sec]'; }
    }
    elsif ( $item_ret =~ /gcloud-compute-cpu-percent-aggr/ || $item_ret =~ /gcloud-compute-mem-(used|free)-aggr/ ) {
      $column_count = 5;
      @header       = ( 'Region', 'Compute Engine', '', '', '' );
      $link_type    = 'compute';

      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
      else                                 { $units = '[GiB]'; }
    }
    elsif ( $item_ret =~ /gcloud-compute-(running|stopped)-aggr/ ) {
      $column_count = 4;
      @header       = ( 'Region', '', '', '' );

      #$link_type = 'compute';
      $units = '[GiB]';
    }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = GCloudMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=gcloud&server=$uuid&lpar=$uuid&item=$item&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }

      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }

      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # Azure
  if ( defined $item_ret && ( $item_ret =~ /(azure-(.*)-aggr|custom-azure-vm-(.*))/ ) ) {
    my @header       = [];
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    @header = ( 'Location', 'Virtual Machine', 'READ', 'WRITE', '' );

    if ( $item_ret =~ /(data|net|lan|iops)/ ) {
      $column_count = 8;
      if ( $item_ret =~ /vm/ ) {
        if ( $item_ret =~ /resource/ ) {
          @header = ( 'Resource Group', 'Virtual Machine', 'READ', 'WRITE', '' );
        }
        else {
          @header = ( 'Location', 'Virtual Machine', 'READ', 'WRITE', '' );
        }
        $link_type = 'vm';
      }
      if    ( $item_ret =~ /net|lan/ ) { $units = '[MB/sec]'; }
      elsif ( $item_ret =~ /iops/ )    { $units = '[IOPS]'; }
      else                             { $units = '[MB/sec]'; }
    }
    elsif ( $item_ret =~ /(vm-cpu-percent-aggr|vm-mem-free-aggr|vm-mem-used-aggr)/ ) {
      $column_count = 5;
      if ( $item_ret =~ /resource/ ) {
        @header = ( 'Resource Group', 'Virtual Machine', '', '', '' );
      }
      else {
        @header = ( 'Location', 'Virtual Machine', '', '', '' );
      }
      $link_type = 'vm';

      if    ( $item_ret =~ /cpu-cores/ )   { $units = '[cores]'; }
      elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
      else                                 { $units = '[GB]'; }
    }
    elsif ( $item_ret =~ /azure-region-(stopped|running)-aggr/ ) {
      $column_count = 4;
      @header       = ( 'Location', '', '', '', '' );

      #$link_type = 'region';
      $units = '[Count]';
    }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
                <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = AzureMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        $item =~ s/-resource//;
        $item =~ s/-location//;
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=azure&server=$uuid&lpar=$uuid&item=$item&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }

      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # Kubernetes
  if ( defined $item_ret && ( $item_ret =~ /(kubernetes-(.*)-aggr)/ ) ) {
    my @header       = [];
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    @header = ( 'Cluster', 'Node', 'READ', 'WRITE', '' );

    if ( $item_ret =~ /(cpu|memory|pods)/ ) {
      $column_count = 5;
      if ( $item_ret =~ /node/ ) {
        @header    = ( 'Cluster', 'Node', '', '', '' );
        $link_type = 'node';
      }
      elsif ( $item_ret =~ /pod-container/ ) {
        @header    = ( 'Pod', 'Container', '', '', '' );
        $link_type = 'container';
      }
      elsif ( $item_ret =~ /container/ ) {
        @header    = ( 'Cluster', 'Container', '', '', '' );
        $link_type = 'container';
      }
      elsif ( $item_ret =~ /pod/ ) {
        @header    = ( 'Cluster', 'Pod', '', '', '' );
        $link_type = 'pod';
      }
      elsif ( $item_ret =~ /pods/ ) {
        @header    = ( 'Cluster', 'Node', '', '', '' );
        $link_type = 'node';
      }
      elsif ( $item_ret =~ /namespace/ ) {
        @header    = ( 'Cluster', 'Namespace', '', '', '' );
        $link_type = 'namespace';
      }
    }
    elsif ( $item_ret =~ /(data|iops|latency|container-net|net)/ ) {
      $column_count = 8;
      if ( $item_ret =~ /node/ ) {
        @header    = ( 'Cluster', 'Node', 'READ', 'WRITE', '' );
        $link_type = 'node';
      }
      elsif ( $item_ret =~ /container/ ) {
        @header    = ( 'Pod', 'Container', 'READ', 'WRITE', '' );
        $link_type = 'container';
      }
      elsif ( $item_ret =~ /container-net/ ) {
        @header = ( 'Pod', 'Container', 'READ', 'WRITE', '' );
      }
      elsif ( $item_ret =~ /network/ ) {
        @header    = ( 'Cluster', 'Pod', 'READ', 'WRITE', '' );
        $link_type = 'pod';
      }
      elsif ( $item_ret =~ /net/ ) {
        @header = ( 'Pod', 'Interface', 'READ', 'WRITE', '' );
      }
    }

    if    ( $item_ret =~ /memory/ )      { $units = '[GB]'; }
    elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
    elsif ( $item_ret =~ /cpu/ )         { $units = '[CPU]'; }
    elsif ( $item_ret =~ /pods/ )        { $units = '[Count]'; }
    elsif ( $item_ret =~ /iops/ )        { $units = '[IOPS]'; }
    elsif ( $item_ret =~ /latency/ )     { $units = '[ms]'; }
    elsif ( $item_ret =~ /data/ )        { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /net/ )         { $units = '[MB/sec]'; }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
                <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END
    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' && defined $uuid ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = KubernetesMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        my $item_to_url = "$item";
        if ( $item_to_url =~ m/pod-container/ ) {
          $item_to_url =~ s/pod-container/container/ig;
        }
        if ( $item_to_url =~ m/pod-network/ ) {
          $item_to_url =~ s/pod-network/pod-net-aggr/ig;
        }
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=kubernetes&server=$uuid&lpar=$uuid&item=$item_to_url&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # Openshift
  if ( defined $item_ret && ( $item_ret =~ /(openshift-(.*)-aggr)/ ) ) {
    my @header       = [];
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    @header = ( 'Cluster', 'Node', 'READ', 'WRITE', '' );

    if ( $item_ret =~ /project/ ) {
      $column_count = 5;
      if ( $item_ret =~ /pod/ && $item_ret !~ /container/ ) {
        if ( $item_ret =~ /(data|iops|latency|container-net|net)/ ) {
          @header = ( 'Project', 'Pod', 'READ', 'WRITE', '' );
        }
        else {
          @header = ( 'Project', 'Pod', '', '', '' );
        }
        $link_type = 'pod';
      }
      elsif ( $item_ret =~ /container/ ) {
        if ( $item_ret =~ /(data|iops|latency|container-net|net)/ ) {
          @header = ( 'Project', 'Container', 'READ', 'WRITE', '' );
        }
        else {
          @header = ( 'Project', 'Container', '', '', '' );
        }
        $link_type = 'container';
      }
    }
    elsif ( $item_ret =~ /(cpu|memory|pods)/ ) {
      $column_count = 5;
      if ( $item_ret =~ /node/ ) {
        @header    = ( 'Cluster', 'Node', '', '', '' );
        $link_type = 'node';
      }
      elsif ( $item_ret =~ /pod-container/ ) {
        @header    = ( 'Pod', 'Container', '', '', '' );
        $link_type = 'container';
      }
      elsif ( $item_ret =~ /container/ ) {
        @header    = ( 'Cluster', 'Container', '', '', '' );
        $link_type = 'container';
      }
      elsif ( $item_ret =~ /pod/ ) {
        @header    = ( 'Cluster', 'Pod', '', '', '' );
        $link_type = 'pod';
      }
      elsif ( $item_ret =~ /pods/ ) {
        @header    = ( 'Cluster', 'Node', '', '', '' );
        $link_type = 'node';
      }
      elsif ( $item_ret =~ /namespace/ ) {
        @header    = ( 'Cluster', 'Namespace', '', '', '' );
        $link_type = 'namespace';
      }
    }
    elsif ( $item_ret =~ /(data|iops|latency|container-net|net)/ ) {
      $column_count = 8;
      if ( $item_ret =~ /node/ ) {
        @header    = ( 'Cluster', 'Node', 'READ', 'WRITE', '' );
        $link_type = 'node';
      }
      elsif ( $item_ret =~ /container/ ) {
        @header    = ( 'Pod', 'Container', 'READ', 'WRITE', '' );
        $link_type = 'container';
      }
      elsif ( $item_ret =~ /container-net/ ) {
        @header = ( 'Pod', 'Container', 'READ', 'WRITE', '' );
      }
      elsif ( $item_ret =~ /network/ ) {
        @header = ( 'Cluster', 'Pod', 'READ', 'WRITE', '' );
      }
      elsif ( $item_ret =~ /net/ ) {
        @header = ( 'Pod', 'Interface', 'READ', 'WRITE', '' );
      }
    }
    if    ( $item_ret =~ /memory/ )      { $units = '[GB]'; }
    elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
    elsif ( $item_ret =~ /cpu/ )         { $units = '[CPU]'; }
    elsif ( $item_ret =~ /pods/ )        { $units = '[Count]'; }
    elsif ( $item_ret =~ /iops/ )        { $units = '[IOPS]'; }
    elsif ( $item_ret =~ /latency/ )     { $units = '[ms]'; }
    elsif ( $item_ret =~ /data/ )        { $units = '[MiB/sec]'; }
    elsif ( $item_ret =~ /net/ )         { $units = '[MiB/sec]'; }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
                <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END
    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' && defined $uuid ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = OpenshiftMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        my $item_to_url = "$item";
        if ( $item_to_url =~ m/project-pod-container/ ) {
          $item_to_url =~ s/project-pod-container/container/ig;
        }
        elsif ( $item_to_url =~ m/project-pod/ ) {
          $item_to_url =~ s/project-pod/pod/ig;
        }
        elsif ( $item_to_url =~ m/pod-container/ ) {
          $item_to_url =~ s/pod-container/container/ig;
        }

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=openshift&server=$uuid&lpar=$uuid&item=$item_to_url&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # Cloudstack
  if ( defined $item_ret && ( $item_ret =~ /(cloudstack-(.*)-aggr)/ ) ) {
    my @header       = ( 'Cloud', 'Host', 'READ', 'WRITE', '' );
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    if ( $item_ret =~ /host/ ) {
      if ( $item_ret =~ /net/ ) {
        @header       = ( 'Cloud', 'Host', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cloud', 'Host', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'host';
    }
    elsif ( $item_ret =~ /instance/ ) {
      if ( $item_ret =~ /(iops|data|net)/ ) {
        @header       = ( 'Cloud', 'Instance', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cloud', 'Instance', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'instance';
    }
    elsif ( $item_ret =~ /volume/ ) {
      if ( $item_ret =~ /(iops|data)/ ) {
        @header       = ( 'Cloud', 'Volume', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cloud', 'Volume', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'volume';
    }
    elsif ( $item_ret =~ /primaryStorage/ ) {
      @header       = ( 'Cloud', 'Primary Storage', '', '', '' );
      $column_count = 5;
      $link_type    = 'primaryStorage';
    }

    if    ( $item_ret =~ /memory/ )    { $units = '[GB]'; }
    elsif ( $item_ret =~ /cpu-cores/ ) { $units = '[cores]'; }
    elsif ( $item_ret =~ /cpu/ )       { $units = '[GHz]'; }
    elsif ( $item_ret =~ /iops/ )      { $units = '[IOPS]'; }
    elsif ( $item_ret =~ /latency/ )   { $units = '[ms]'; }
    elsif ( $item_ret =~ /data/ )      { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /net/ )       { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /size/ )      { $units = '[GiB]'; }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
                <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END
    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
    ##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' && defined $uuid ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = CloudstackMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        my $item_to_url = "$item";

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=cloudstack&server=$uuid&lpar=$uuid&item=$item_to_url&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # Proxmox
  if ( defined $item_ret && ( $item_ret =~ /(proxmox-(.*)-aggr|custom-proxmoxvm-(.*))/ ) ) {
    my @header       = ( 'Cluster', 'Node', 'READ', 'WRITE', '' );
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    if ( $item_ret =~ /node/ ) {
      if ( $item_ret =~ /net/ ) {
        @header       = ( 'Cluster', 'Node', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cluster', 'Node', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'node';
    }
    elsif ( $item_ret =~ /node-vm/ ) {
      if ( $item_ret =~ /(iops|data|net)/ ) {
        @header       = ( 'Node', 'VM', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Node', 'VM', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'vm';
    }
    elsif ( $item_ret =~ /vm/ ) {
      if ( $item_ret =~ /(iops|data|net)/ ) {
        @header       = ( 'Cluster', 'VM', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cluster', 'VM', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'vm';
    }
    elsif ( $item_ret =~ /lxc/ ) {
      if ( $item_ret =~ /(iops|data|net)/ ) {
        @header       = ( 'Cluster', 'LXC', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cluster', 'LXC', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'lxc';
    }
    elsif ( $item_ret =~ /volume/ ) {
      if ( $item_ret =~ /(iops|data)/ ) {
        @header       = ( 'Cluster', 'Volume', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cluster', 'Volume', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'vm';
    }
    elsif ( $item_ret =~ /storage/ ) {
      @header       = ( 'Cluster', 'Storage', '', '', '' );
      $column_count = 5;
      $link_type    = 'storage';
    }

    if    ( $item_ret =~ /memory/ )      { $units = '[GB]'; }
    elsif ( $item_ret =~ /cpu-percent/ ) { $units = '[%]'; }
    elsif ( $item_ret =~ /cpu/ )         { $units = '[cores]'; }
    elsif ( $item_ret =~ /io/ )          { $units = '[%]'; }
    elsif ( $item_ret =~ /latency/ )     { $units = '[ms]'; }
    elsif ( $item_ret =~ /data/ )        { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /net/ )         { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /size/ )        { $units = '[GiB]'; }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
                <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END
    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
    ##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' && defined $uuid ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = ProxmoxMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        my $item_to_url = "$item";

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=Proxmox&server=$uuid&lpar=$uuid&item=$item_to_url&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # Docker
  if ( defined $item_ret && ( $item_ret =~ /(docker-(.*)-aggr)/ ) ) {
    my @header       = ( 'Container', 'READ', 'WRITE', '' );
    my $units        = '';
    my $column_count = 7;
    my $link_type    = '';

    if ( $item_ret =~ /total-container/ ) {
      if ( $item_ret =~ /cpu/ || $item_ret =~ /memory/ || $item_ret =~ /size/ ) {
        @header       = ( 'Host', 'Container', '', '', '' );
        $column_count = 5;
      }
      else {
        @header       = ( 'Host', 'Container', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      $link_type = 'container';
    }
    elsif ( $item_ret =~ /container/ ) {
      if ( $item_ret =~ /cpu/ || $item_ret =~ /memory/ || $item_ret =~ /size/ ) {
        @header       = ( 'Container', '', '', '' );
        $column_count = 4;
      }
      else {
        @header       = ( 'Container', 'READ', 'WRITE', '' );
        $column_count = 7;
      }
      $link_type = 'container';
    }
    elsif ( $item_ret =~ /volume/ ) {
      @header       = ( 'Volume', '', '', '' );
      $column_count = 4;
      $link_type    = 'volume';
    }

    if    ( $item_ret =~ /memory/ ) { $units = '[GB]'; }
    elsif ( $item_ret =~ /cpu/ )    { $units = '[cores]'; }
    elsif ( $item_ret =~ /io/ )     { $units = '[IOPS]'; }
    elsif ( $item_ret =~ /data/ )   { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /net/ )    { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /size/ )   { $units = '[GiB]'; }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
                <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END
    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' && defined $uuid ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = DockerMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        my $item_to_url = "$item";
        $item_to_url =~ s/total-//;

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=Docker&server=$uuid&lpar=$uuid&item=$item_to_url&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # FusionCompute
  if ( defined $item_ret && ( $item_ret =~ /(fusioncompute-(.*)-aggr|custom-fusioncomputevm-(.*))/ ) ) {
    my @header       = ( 'Cluster', 'Host', 'READ', 'WRITE', '' );
    my $units        = '';
    my $column_count = 8;
    my $link_type    = '';

    if ( $item_ret =~ /host-vm/ ) {
      if ( $item_ret =~ /(iops|data|net|ios|req)/ ) {
        @header       = ( 'Host', 'VM', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Host', 'VM', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'vm';
    }
    elsif ( $item_ret =~ /host/ || $item_ret =~ /cluster/ ) {
      if ( $item_ret =~ /net|ios|iops|data|req|packet/ ) {
        @header       = ( 'Cluster', 'Host', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cluster', 'Host', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'host';
    }
    elsif ( $item_ret =~ /vm/ ) {
      if ( $item_ret =~ /(iops|data|net|ios|req|ticks|sectors|packet)/ ) {
        @header       = ( 'Cluster', 'VM', 'READ', 'WRITE', '' );
        $column_count = 8;
      }
      else {
        @header       = ( 'Cluster', 'VM', '', '', '' );
        $column_count = 5;
      }
      $link_type = 'vm';
    }
    elsif ( $item_ret =~ /datastore/ ) {
      @header       = ( 'Site', 'Datastore', '', '', '' );
      $column_count = 5;
      $link_type    = 'datastore';
    }
    if    ( $item_ret =~ /memory-percent/ || $item_ret =~ /mem-percent/ )     { $units = '[%]'; }
    elsif ( $item_ret =~ /cpu-percent/ )                                      { $units = '[%]'; }
    elsif ( $item_ret =~ /disk-usage/ || $item_ret =~ /net-usage/ )           { $units = '[%]'; }
    elsif ( $item_ret =~ /iops/ || $item_ret =~ /ios/ || $item_ret =~ /req/ ) { $units = '[IOPS]'; }
    elsif ( $item_ret =~ /latency/ || $item_ret =~ /ticks/ )                  { $units = '[ms]'; }
    elsif ( $item_ret =~ /datastore/ )                                        { $units = '[GB]'; }
    elsif ( $item_ret =~ /data/ || $item_ret =~ /sectors/ )                   { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /net/ )                                              { $units = '[MB/sec]'; }
    elsif ( $item_ret =~ /packet/ )                                           { $units = '[number]'; }

    # the rest of this block is literally the same as in the oVirt branch, except the 8col table and different ad-hoc hypertext

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
        <th>&nbsp;</th>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th>$header[1]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
END
    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
        <th class=\"sortable header toleft\">$header[1]</th>
        <th>$header[2]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th>$header[3]</th>
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
        <td class=\"legsq\">xorux_val1_color</td>
        <td class=\"clickabletd\">xorux_server_name</td>
        <td class=\"clickabletd\">xorux_lpar_name</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max</td>
      </tr>
END
    my $table_row_7col = <<END;
      <tr>
        <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
        <td class=\"clickabletd\">xorux_server_name</td>
                <td class=\"clickabletd\">xorux_lpar_name</td>
        <td class=\"legsq\">xorux_val1_color</td>
        <td>xorux_val1_avg</td>
        <td>xorux_val1_max&nbsp;</td>
        <td class=\"legsq\">xorux_val2_color</td>
        <td>xorux_val2_avg</td>
        <td>xorux_val2_max</td>
        </tr>\n
END
    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END
    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
    ##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid ) = split( "$delimiter", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      # note: parse the $item to get "item" in data-url for detail-graph preview; this will replace "xorux_val1_color"

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      my $data_url;
      if ( $link_type ne '' && defined $uuid ) {
        $uuid =~ s/^\s+|\s+$//g;
        my $link_url = FusionComputeMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        my $item_to_url = "$item";
        $item_to_url =~ s/custom-fusioncomputevm/fusioncompute-vm/;
        $item_to_url =~ s/datastore-used/datastore-capacity/;
        $item_to_url =~ s/datastore-free/datastore-capacity/;
        $item_to_url =~ s/mem-used/mem/;
        $item_to_url =~ s/mem-free/mem/;
        if ( $item_to_url =~ m/host-vm/ ) {
          $item_to_url =~ s/host-vm/vm/;
        }

        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=FusionCompute&server=$uuid&lpar=$uuid&item=$item_to_url&time=$time&type_sam=$time&detail=1&entitle=0&none=none\"";
        $data_url =~ s/-aggr//;
      }
      else {
        $table_row =~ s/xorux_lpar_name/$name_space_show/;
      }

      if ( defined $data_url ) {
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      else {
        $table_row =~ s/xorux_val1_color/$val1_color/;
      }
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 5 ) {
        $table_row =~ s/xorux_server_name/$cluster/;
      }
      elsif ( $column_count == 7 || $column_count == 8 ) {
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        if ( $column_count == 8 ) {
          $table_row =~ s/xorux_server_name/$cluster/;
        }
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      push @table_out, $table_row;
    }
    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  # oVirt
  if ( defined $item_ret && ( $item_ret =~ /ovirt_.*_aggr_|custom_ovirt_vm_.*/ ) ) {
    my @header;
    my $units;
    my $column_count = 7;
    my $link_type;

    #custom-ovirtvm-cpu-percent
    if ( $item_ret =~ /(domain|domains_total|vm)_aggr_data/ ) {
      $link_type = 'disk';
      @header    = ( $1 eq 'domains_total' ? 'Storage domain & Disk' : 'Disk', 'READ', 'WRITE' );
      $units     = '[MB/sec]';
    }
    elsif ( $item_ret =~ /(domain|domains_total|vm)_aggr_latency/ ) {
      $link_type = 'disk';
      @header    = ( $1 eq 'domains_total' ? 'Storage domain & Disk' : 'Disk', 'READ', 'WRITE' );
      $units     = '[millisec]';
    }
    elsif ( $item_ret =~ /(domain|domains_total|vm)_aggr_iops/ ) {
      $link_type = 'disk';
      @header    = ( $1 eq 'domains_total' ? 'Storage domain & Disk' : 'Disk', 'READ', 'WRITE' );
      $units     = '[IOPS]';
    }
    elsif ( $item_ret =~ /(host_nic|vm)_aggr_net/ ) {
      $link_type = $1;
      @header    = ( 'Int', 'READ', 'WRITE' );
      $units     = '[MB/sec]';
    }
    elsif ( $item_ret =~ /(host|cluster)_aggr_(vm|host)_(cpu_core|cpu_percent|mem_used_percent|mem_used|mem_free)/ ) {
      $column_count = 4;
      $link_type    = $2;
      @header       = ( ( $2 eq 'vm' ? uc $2 : ucfirst $2 ), '', '' );

      if    ( $3 eq 'cpu_core' )                                { $units = '[cores]'; }
      elsif ( $3 eq 'cpu_percent' || $3 eq 'mem_used_percent' ) { $units = '[%]'; }
      else                                                      { $units = '[GB]'; }
    }
    elsif ( $item_ret =~ /custom_ovirt_vm_(cpu_core|cpu_percent|mem_used|mem_free)/ ) {
      $column_count = 5;
      @header       = ( 'Cluster', 'VM', '' );

      if    ( $1 eq 'cpu_cores' )   { $units = '[cores]'; }
      elsif ( $1 eq 'cpu_percent' ) { $units = '[%]'; }
      else                          { $units = '[GB]'; }
    }

    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
  <th>$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>$header[2]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_7col = <<END;
      <tr>
  <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid, my $uuid_owner ) = split( " $delimiter ", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";
      $item =~ s/^custom_|cluster_aggr_|host_aggr_|_used(_percent)?$|_free$//g;

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      #      $table_row =~ s/xorux_lpar_name/$name_space_show/;
      #      $table_row =~ s/xorux_val1_color/$val1_color/ unless $column_count == 5;
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 4 ) {
        my $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=ovirt&server=nope&lpar=$uuid&item=$item&time=$time&type_sam=$time&detail=1\"";
        my $link_url = OVirtMenu::get_url( { type => ${link_type}, ${link_type} => $uuid } );
        my $link     = "<a href=\"${link_url}\">$name_space_show</a>";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      elsif ( $column_count == 5 ) {
        my $data_url       = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=ovirt&server=nope&lpar=$uuid&item=$item&time=$time&type_sam=$time&detail=1\"";
        my $link_url       = OVirtMenu::get_url( { type => 'vm', id => $uuid } );
        my $link           = "<a href=\"${link_url}\" class=\"backlink\">$name_space_show</a>";
        my $link_owner_url = OVirtMenu::get_url( { type => 'cluster_aggr', id => $uuid_owner } );
        my $link_owner     = "<a href=\"${link_owner_url}\" class=\"backlink\">$cluster</a>";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/xorux_server_name/$link_owner/;
      }
      elsif ( $column_count == 7 ) {
        if ( $link_type eq 'host_nic' ) {
          my $link_url = OVirtMenu::get_url( { type => 'host_nic', id => $uuid } );
          my $link     = "<a href=\"${link_url}\" class=\"backlink\">$name_space_show</a>";

          $table_row =~ s/xorux_lpar_name/$link/;
        }
        elsif ( $link_type eq 'disk' ) {
          my $data_item = 'ovirt_disk_' . ( split '_', $item )[-1];
          my $data_url  = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=ovirt&server=nope&lpar=$uuid&item=$data_item&time=$time&type_sam=$time&detail=1\"";
          my $link_url  = OVirtMenu::get_url( { type => 'disk', id => $uuid } );
          my $link      = "<a href=\"${link_url}\" class=\"backlink\">$name_space_show</a>";

          $table_row =~ s/xorux_lpar_name/$link/;
          $table_row =~ s/>xorux_val1_color/$data_url>xorux_val1_color/;
          $table_row =~ s/>xorux_val2_color/$data_url>xorux_val2_color/;
        }
        else {
          $table_row =~ s/xorux_lpar_name/$name_space_show/;
        }

        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        $table_row =~ s/xorux_val1_color/$val1_color/;
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }

      push @table_out, $table_row;
    }

    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /oracledb/ ) ) {    #_Wait_class_Main|oracledb_Services

    my @header;
    my $units;
    my $column_count = 4;
    my $link_type;
    my $page   = OracleDBDataWrapper::basename( $item, '__' );
    my $legend = OracleDBDataWrapper::graph_legend($page);
    if ( $item_ret =~ /Wait_class_Main/ ) {
      $column_count = 5;
      $link_type    = $lpar;
      @header       = ( 'Instance', 'Wait class', 'WRITE' );
      $units        = '';
    }
    elsif ( $item_ret =~ /Services/ ) {
      $units        = '[ms]';
      $column_count = 5;
      $link_type    = 'Services';
      @header       = ( 'Instance', 'Service', 'WRITE' );
      $units        = '[DB Blocks]';
    }
    elsif ( $item_ret =~ /oracledb_Disk_latency/ ) {
      $column_count = 5;
      $link_type    = $lpar;
      @header       = ( 'Instance', 'Value type', 'WRITE' );
      $units        = '[ms per wait]';
    }
    elsif ( $item_ret =~ /oracledb_viewthree|oracledb_aggr_Session/ ) {
      $column_count = 5;
      $link_type    = "Session info";
      @header       = ( 'Instance', 'Value type', 'WRITE' );
      $units        = '';
    }
    elsif ( $item_ret =~ /oracledb_view|oracledb_Cache/ ) {
      $column_count = 5;
      $link_type    = $lpar;
      @header       = ( 'Instance', 'Value type', 'WRITE' );
      $units        = '[ms per wait]';
    }
    elsif ( $item_ret =~ m/oracledb_aggr_SQL_query_user_info|oracledb_aggr_SQL_query_cursors_info/ ) {
      $column_count = 5;
      $link_type    = $lpar;
      @header       = ( 'Instance', 'Value type', 'WRITE' );
      $units        = '';
    }
    elsif ( $item_ret =~ m/CPU_Usage_Per_Sec_Total/
      or $item =~ m/DB_Block_Changes_Per_Sec_Total/
      or $item =~ m/Logical_Reads_Per_Sec_Total/
      or $item =~ m/Host_CPU_Utilization_Total/
      or $item =~ m/used_Total/
      or $item =~ m/free_Total/
      or $item =~ m/logcap_Total/ )
    {
      $column_count = 5;
      $link_type    = $lpar;
      @header       = ( 'Instance', 'Host name', 'Value type', 'WRITE' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }
    elsif ( $item =~ m/host_metrics/ ) {
      $column_count = 5;
      $link_type    = $lpar;
      @header       = ( 'Host name', 'DB/Instance', 'Value type', 'WRITE' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }
    elsif ( $item =~ m/hosts_Total/ ) {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Host name', 'DB/Instance' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }
    elsif ( $item =~ m/configuration_DBTotal/ ) {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Host name', 'DB/Instance' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }
    else {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Instance', 'Value type', 'WRITE' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }

    #elevator
    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_8col = <<END;
      <tr>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    #elevator

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }

##    push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    #   print STDERR $item_ret;
    #   print STDERR "  @rrd_print\n";

    while ( my $print_line = shift(@rrd_print) ) {

      #print STDERR "$print_line\n\n";
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }

      ( my $val1_avg, my $item,        my $name_space, my $val1_color, my $rrd_name )   = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster,    my $uuid,       my $uuid_owner ) = split( " $delimiter ", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      #      warn "PRINT LINE$print_line";
      #      warn "RRD PRINT @rrd_print";

      #$item =~ s/^custom_|cluster_aggr_|host_aggr_|_used(_percent)?$|_free$//g;
      #print STDERR "\n             $val1_avg, $item, $name_space, $val1_color         \n";
      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      #      $table_row =~ s/xorux_lpar_name/$name_space_show/;
      #      $table_row =~ s/xorux_val1_color/$val1_color/ unless $column_count == 5;
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 4 ) {
        my $data_url = "";
        if ( $item =~ m/aggr_SQL_query/ ) {
          my $item_strip = $item;
          $item_strip =~ s/oracledb_Wait_class_Main//g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=not_needed&server=$server&lpar=$lpar&item=oracledb_colorclick$item_strip" . "___$rrd_name$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        elsif ( $item =~ /oracledb_hosts_Total/ ) {
          my $item_strip = $item;
          $item_strip =~ s/$lpar/singlehost/g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=hostname&lpar=singlehost&item=$item_strip$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        else {
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";

        }
        my @sp          = split( /,/, $name_space_show );
        my $link        = "";
        my $clean_linkT = $link_type;
        $clean_linkT =~ s/oracledb_//g;
        $clean_linkT =~ s/aggr_//g;
        if ( $sp[2] ) {
          my $url = "";
          $link = "<a href=\"$url\" class=\"backlink\">$sp[0]-$sp[1]</a>";
        }
        else {
          my $instance = OracleDBDataWrapper::instancename_to_ip( $sp[0], $server );
          my $odb_id   = OracleDBDataWrapper::get_uuid( $server, $instance->{type}, $instance->{ip} );
          my $url      = OracleDBMenu::get_url( { type => "$clean_linkT", id => "$odb_id" } );
          $link = "<a href=\"$url\" class=\"backlink\">$sp[0]</a>";
        }

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;

      }
      elsif ( $column_count == 5 ) {
        my $data_url = "";
        if ( $item =~ m/Services/ ) {
          my $item_strip = $item;
          my $foo_color  = $val1_color;
          $foo_color  =~ s/#/_a_/g;
          $item_strip =~ s/oracledb_Services//g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=not_needed&server=$server&lpar=$lpar&item=oracledb_colorclick$item_strip" . "___$uuid$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        elsif ( $lpar =~ m/view/ or $lpar =~ m/Cache/ or $lpar =~ m/Disk_latency/ or $lpar =~ m/aggr_Session_info/ ) {

          #item_strip =~ s/oracledb_Services//g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=oracledb_$lpar" . "__$rrd_name$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        elsif ( $item =~ m/Wait_class_Main/ ) {
          my $item_strip = $item;
          $item_strip =~ s/oracledb_Wait_class_Main//g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=not_needed&server=$server&lpar=$lpar&item=oracledb_colorclick$item_strip" . "___$uuid$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        elsif ( $item =~ m/aggr_SQL_query/ ) {
          my $item_strip = $item;
          $item_strip =~ s/oracledb//g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=oracledb_$lpar" . "___$rrd_name$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        elsif ( $item =~ m/CPU_Usage_Per_Sec_Total/
          or $item =~ m/DB_Block_Changes_Per_Sec_Total/
          or $item =~ m/Logical_Reads_Per_Sec_Total/
          or $item =~ m/Host_CPU_Utilization_Total/
          or $item =~ m/used_Total/
          or $item =~ m/free_Total/
          or $item =~ m/logcap_Total/ )
        {
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          my @sp = split( /,/, $name_space_show );
          $item =~ s/_Total//g;

          #if ($sp[2]){
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$sp[2]&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";

          #}else{
          #  $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$sp[1]&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";
          #}
        }
        elsif ( $item =~ /oracledb_host_metrics/ ) {
          my $item_strip = $item;
          $item_strip =~ s/$lpar/configuration/g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          my @sp_host = split( /,/, $uuid );
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$sp_host[0]&server=$sp_host[1]&lpar=singlehost&item=$item_strip$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        elsif ( $item =~ /oracledb_DBTotal/ ) {
          my $item_strip = $item;
          $item_strip =~ s/$lpar/configuration/g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          my @sp_host = split( /,/, $uuid );
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$sp_host[0]&server=$sp_host[1]&lpar=singlehost&item=$item_strip$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        else {
          #item_strip =~ s/oracledb_Services//g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        $name_space_show =~ s/3-way/3 way/g;
        $name_space_show =~ s/2-way/2 way/g;
        my @sp         = split( /,/, $name_space_show );
        my $link       = "";
        my $link_owner = "";

        #if ($sp[2]){
        #  if ($sp[2] and $sp[2] =~ /^gc |^GC /){
        #    $sp[2] =~ s/gc //g;
        #    $sp[2] =~ s/GC //g;
        #  }
        #  $link = "<a href=\"/lpar2rrd-cgi/detail.sh?platform=OracleDB&type=$link_type\&$link_type=$uuid\">$sp[2]</a>";
        #  $link_owner = "<a href=\"/lpar2rrd-cgi/detail.sh?platform=OracleDB&type=$link_type\&$link_type=$uuid\">$sp[0]-$sp[1]</a>";
        #}else{
        if ( $sp[1] and $sp[1] =~ /^gc |^GC / ) {
          $sp[1] =~ s/gc //g;
          $sp[1] =~ s/GC //g;
        }
        if ( $link_type eq "configuration_Total" ) {
          my $alias  = OracleDBDataWrapper::get_alias( $uuid, $sp[0] );
          my $odb_id = OracleDBDataWrapper::get_uuid( "hostname", "Items", $sp[1] );
          my $url    = OracleDBMenu::get_url( { type => "host_metrics", id => "$odb_id" } );
          $link = "<a href=\"$url\" class=\"backlink\">$sp[1]</a>";

          my $l_type;
          if ( index( $item, "CPU_Usage_Per_Sec" ) != -1 ) {
            $l_type = "CPU_info";
          }
          elsif ( index( $item, "DB_Block_Changes" ) != -1 or index( $item, "Logical_Reads_Pe" ) != -1 ) {
            $l_type = "Data_rate_r";
          }
          elsif ( $item =~ /_free/ or $item =~ /_used/ or $item =~ /_logcap/ ) {
            $l_type = "configuration";
          }
          my $instance = OracleDBDataWrapper::instancename_to_ip( $sp[0], $alias );
          $odb_id     = OracleDBDataWrapper::get_uuid( $alias, $instance->{type}, $instance->{ip} );
          $url        = OracleDBMenu::get_url( { type => "$l_type", id => "$odb_id" } );
          $link_owner = "<a href=\"$url\" class=\"backlink\">$sp[0]</a>";
        }
        else {
          my $instance    = OracleDBDataWrapper::instancename_to_ip( $sp[0], $server );
          my $odb_id      = OracleDBDataWrapper::get_uuid( $server, $instance->{type}, $instance->{ip} );
          my $clean_linkT = $link_type;
          $clean_linkT =~ s/oracledb_//g;
          $clean_linkT =~ s/aggr_//g;
          $clean_linkT =~ s/ /_/g;
          my $url = "";
          if ( $clean_linkT eq "hosts_Total" ) {
            $clean_linkT = "hosts_metrics";
            $url         = OracleDBMenu::get_url( { type => "$clean_linkT", id => "$odb_id" } );
          }
          else {
            $url = OracleDBMenu::get_url( { type => "$link_type", id => "$odb_id" } );
          }

          $link       = "<a href=\"$url\" class=\"backlink\">$sp[1]</a>";
          $url        = OracleDBMenu::get_url( { type => "$clean_linkT", id => "$odb_id" } );
          $link_owner = "<a href=\"$url\" class=\"backlink\">$sp[0]</a>";
        }

        #}
        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/xorux_server_name/$link_owner/;
      }

      push @table_out, $table_row;

      #}
    }

    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    #print STDERR "GNLINE $graphv_line\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /powercmc/ ) ) {
    # TODO: clickable legend

    # COPY OF oracledb
    my @header;
    my $units;
    my $column_count = 4;
    my $link_type;
    my $page   = PowercmcDataWrapper::basename( $item, '__' );
    my $legend = PowercmcDataWrapper::graph_legend($page);
 
    #warn " $item"; 
    #warn " $page";  
    
    my %page_header = (
      "cmc_system" => 'Servers',
      "credit" => 'Credit consumer',
      "metered_core_minutes" => 'OS',
      "metered_memory_minutes" => 'Metric',
      "cmc_total" => 'Servers',
      "cmc_system_memory" => 'Memory',
      "total_cpu" => 'Console:Pool',
      "total_credit" => 'Console:Pool',
    ); 
    
    # !!! Make change in links/legend...
    if ($page eq "cmc_system" && $item =~ 'pep2_system'){
      $page_header{$page} = "CPU";
    } 
 
    if ( defined $page_header{$page} ) {
      my $table_header_name = $page_header{$page};      

      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( "$table_header_name", 'Value type', 'WRITE' );
      $units        = '';
    }
    else {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Metric', 'Value type', 'WRITE' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }

    #elevator
    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_8col = <<END;
      <tr>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";

    #elevator

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }

    while ( my $print_line = shift(@rrd_print) ) {

      my $table_row;

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }

      ( my $val1_avg, my $item,        my $name_space, my $val1_color, my $rrd_name )   = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster,    my $uuid,       my $uuid_owner ) = split( " $delimiter ", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      $name_space =~ s/\s+$//g;
      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 4 ) {
        my $data_url = "";
        
        my $foo_color = $val1_color;
        $foo_color =~ s/#/_a_/g;
        $uuid      =~ s/ //g;
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$name_space&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";

        my @sp          = split( /,/, $name_space_show );
        my $link        = "";
        my $clean_linkT = $link_type;
        $clean_linkT =~ s/db2_//g;
        $clean_linkT =~ s/aggr_//g;
        if ( $sp[2] ) {
          my $url = "";
          $link = "$sp[0]-$sp[1]";
        }
        else {
          my $instance = "";
          my $odb_id   = "";
          my $url      = "";
          $link = "$sp[0]";
        }

        $table_row =~ s/xorux_lpar_name/$link/;
        #$table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/>xorux_val1_color/>$val1_color/;

      }
      elsif ( $column_count == 5 ) {
        my $data_url  = "";
        my $foo_color = $val1_color;
        $foo_color =~ s/#/_a_/g;
        $uuid      =~ s/ //g;
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";
        my @sp          = split( /,/, $name_space_show );
        my $link        = "";
        my $link_owner  = "";
        my $instance    = "";
        my $odb_id      = "";
        my $clean_linkT = $link_type;
        my $url         = "";
        $link       = "$sp[1]";
        $url        = "";
        $link_owner = "$sp[0]";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/xorux_server_name/$link_owner/;
      }

      push @table_out, $table_row;

    }

    my @table_save;
    my @table_foot = ();
    
    #warn $lpar;
 
    for my $table_row (@table_out){
      if ( $lpar eq 'pep2_pool' && $table_row =~ />Base</){
        push (@table_foot, $table_row);
      }
      elsif ( $lpar eq 'pep2_pool' && $table_row =~ />Installed</){
        push (@table_foot, $table_row);
      }
      else{
        push (@table_save, $table_row);
      }
    }
 
    @table_out = @table_save;
 
    my $table_end_day = "</tbody><tfoot><tr> <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td></tr></tfoot></table>\n";
    my $special_table_end_day = "<tr> <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td></tr>\n";
    
    my $tfoot = '';

    my $time_in_print = 0;

    if (scalar(@table_foot)){
      $tfoot .= "<tfoot>";
      for my $table_row (@table_foot){
        $tfoot .= $table_row;
      }
      
      if ( $updated =~ /Updated/ ) {
        $special_table_end_day =~ s/(COMMENT:|\\)//g;
        push @table_out, $special_table_end_day;
        $time_in_print = 1;
      }
      
      $tfoot .= "</tfoot>";
     
      $table_end = $tfoot." ".$table_end;
      
    }
    
    if ( $updated =~ /Updated/ && ! $time_in_print ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /db2/ ) ) {    #_Wait_class_Main|oracledb_Services

    my @header;
    my $units;
    my $column_count = 4;
    my $link_type;
    my $page   = Db2DataWrapper::basename( $item, '__' );
    my $legend = Db2DataWrapper::graph_legend($page);
    if ( $item_ret =~ /Locks/ ) {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Lock type', 'Value type', 'WRITE' );
      $units        = '';
    }
    else {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Metric', 'Value type', 'WRITE' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }

    #elevator
    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_8col = <<END;
      <tr>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    #elevator

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }

    while ( my $print_line = shift(@rrd_print) ) {

      my $table_row;

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }

      ( my $val1_avg, my $item,        my $name_space, my $val1_color, my $rrd_name )   = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster,    my $uuid,       my $uuid_owner ) = split( " $delimiter ", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      $name_space =~ s/\s+$//g;
      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 4 ) {
        my $data_url = "";
        if ( $item =~ m/aggr_SQL_query/ ) {
          my $item_strip = $item;
          $item_strip =~ s/oracledb_Wait_class_Main//g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=not_needed&server=$server&lpar=$lpar&item=oracledb_colorclick$item_strip" . "___$rrd_name$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        else {
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$name_space&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";

        }
        my @sp          = split( /,/, $name_space_show );
        my $link        = "";
        my $clean_linkT = $link_type;
        $clean_linkT =~ s/db2_//g;
        $clean_linkT =~ s/aggr_//g;
        if ( $sp[2] ) {
          my $url = "";
          $link = "$sp[0]-$sp[1]";
        }
        else {
          my $instance = "";
          my $odb_id   = "";
          my $url      = "";
          $link = "$sp[0]";
        }

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;

      }
      elsif ( $column_count == 5 ) {
        my $data_url  = "";
        my $foo_color = $val1_color;
        $foo_color =~ s/#/_a_/g;
        $uuid      =~ s/ //g;
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";
        my @sp          = split( /,/, $name_space_show );
        my $link        = "";
        my $link_owner  = "";
        my $instance    = "";
        my $odb_id      = "";
        my $clean_linkT = $link_type;
        my $url         = "";
        $link       = "$sp[1]";
        $url        = "";
        $link_owner = "$sp[0]";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/xorux_server_name/$link_owner/;
      }

      push @table_out, $table_row;

    }

    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    #print STDERR "GNLINE $graphv_line\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /postgres/ ) ) {    #_Wait_class_Main|oracledb_Services

    my @header;
    my $units;
    my $column_count = 4;
    my $link_type;
    my $page   = PostgresDataWrapper::basename( $item, '__' );
    my $legend = PostgresDataWrapper::graph_legend($page);
    if ( $item_ret =~ /Locks/ ) {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Lock type', 'Value type', 'WRITE' );
      $units        = '';
    }
    else {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Metric', 'Value type', 'WRITE' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }

    #elevator
    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_8col = <<END;
      <tr>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    #elevator

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }

    while ( my $print_line = shift(@rrd_print) ) {

      my $table_row;

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }

      ( my $val1_avg, my $item,        my $name_space, my $val1_color, my $rrd_name )   = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster,    my $uuid,       my $uuid_owner ) = split( " $delimiter ", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      $name_space =~ s/\s+$//g;
      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 4 ) {
        my $data_url = "";
        if ( $item =~ m/aggr_SQL_query/ ) {
          my $item_strip = $item;
          $item_strip =~ s/oracledb_Wait_class_Main//g;
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=not_needed&server=$server&lpar=$lpar&item=oracledb_colorclick$item_strip" . "___$rrd_name$foo_color&time=$time&type_sam=$time&detail=1\"";
        }
        else {
          my $foo_color = $val1_color;
          $foo_color =~ s/#/_a_/g;
          $uuid      =~ s/ //g;
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$name_space&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";

        }
        my @sp          = split( /,/, $name_space_show );
        my $link        = "";
        my $clean_linkT = $link_type;
        $clean_linkT =~ s/postgres_//g;
        $clean_linkT =~ s/aggr_//g;
        if ( $sp[2] ) {
          my $url = "";
          $link = "$sp[0]-$sp[1]";
        }
        else {
          my $instance = "";
          my $odb_id   = "";
          my $url      = "";
          $link = "$sp[0]";
        }

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;

      }
      elsif ( $column_count == 5 ) {
        my $data_url = "";

        #item_strip =~ s/oracledb_Services//g;
        my $foo_color = $val1_color;
        $foo_color =~ s/#/_a_/g;
        $uuid      =~ s/ //g;
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";
        my @sp         = split( /,/, $name_space_show );
        my $link       = "";
        my $link_owner = "";

        my $instance    = "";
        my $odb_id      = "";
        my $clean_linkT = $link_type;
        $clean_linkT =~ s/oracledb_//g;
        $clean_linkT =~ s/aggr_//g;
        $clean_linkT =~ s/ /_/g;
        my $url = "";
        $link       = "$sp[1]";
        $link_owner = "$sp[0]";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/xorux_server_name/$link_owner/;
      }

      push @table_out, $table_row;

    }

    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    #print STDERR "GNLINE $graphv_line\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /sqlserver/ ) ) {    #_Wait_class_Main|oracledb_Services

    my @header;
    my $units;
    my $column_count = 4;
    my $link_type;
    my $page   = SQLServerDataWrapper::basename( $item, '__' );
    my $legend = SQLServerDataWrapper::graph_legend($page);
    if ( $item_ret =~ /Locks/ ) {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Lock type', 'Value type', 'WRITE' );
      $units        = '';
    }
    else {
      $column_count = 4;
      $link_type    = $lpar;
      @header       = ( 'Metric', 'Value type', 'WRITE' );
      $units        = exists $legend->{brackets} ? $legend->{brackets} : "";
    }

    #elevator
    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_8col = <<END;
      <tr>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    #elevator

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }

    while ( my $print_line = shift(@rrd_print) ) {

      my $table_row;

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }

      ( my $val1_avg, my $item,        my $name_space, my $val1_color, my $rrd_name )   = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster,    my $uuid,       my $uuid_owner ) = split( " $delimiter ", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";

      $name_space =~ s/\s+$//g;
      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;

      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      if ( $column_count == 4 ) {
        my $data_url = "";

        my $foo_color = $val1_color;
        $foo_color =~ s/#/_a_/g;
        $uuid      =~ s/ //g;
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$name_space&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";

        my @sp          = split( /,/, $name_space_show );
        my $link        = "";
        my $clean_linkT = $link_type;
        $clean_linkT =~ s/aggr_//g;
        if ( $sp[2] ) {
          my $url = "";
          $link = "$sp[0]-$sp[1]";
        }
        else {
          my $instance = "";
          my $odb_id   = "";
          my $url      = "";
          $link = "$sp[0]";
        }

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;

      }
      elsif ( $column_count == 5 ) {
        my $data_url = "";

        my $foo_color = $val1_color;
        $foo_color =~ s/#/_a_/g;
        $uuid      =~ s/ //g;
        $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$uuid&server=$server&lpar=$lpar&item=$item$foo_color&time=$time&type_sam=$time&detail=1\"";

        my @sp         = split( /,/, $name_space_show );
        my $link       = "";
        my $link_owner = "";

        my $instance    = "";
        my $odb_id      = "";
        my $clean_linkT = $link_type;
        $clean_linkT =~ s/ /_/g;
        my $url = "";
        $link       = "$sp[1]";
        $link_owner = "$sp[0]";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/xorux_server_name/$link_owner/;
      }

      push @table_out, $table_row;

    }

    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }

    #print STDERR "GNLINE $graphv_line\n";
    return $graphv_line;
  }

  # OracleVM disk and net
  if ( defined $item_ret && ( $item_ret =~ /ovm_.*_aggr|ovm_.*_total|custom_orvm*/ ) ) {
    my @header;
    my $units;
    my $column_count = 7;
    my $link_type;
    my $item_click;

    #print STDERR "2856 \$item $item \$html_heading $html_heading \$test_item $test_item \@rrd_print @rrd_print\n";
    if ( $item_ret =~ /ovm_net_aggr/ ) {
      $link_type = $item;
      @header    = ( 'Int', 'READ', 'WRITE' );
      $units     = '[MB/sec]';
    }
    elsif ( $item_ret =~ /ovm_server_total_cpu|ovm_server_total_mem|ovm_serverpools_total_cpu|ovm_serverpools_total_mem|ovm_vm_aggr_cpu_serverpool|ovm_vm_aggr_cpu_server/ ) {

      #print STDERR "28i63 \$item $item \$html_heading $html_heading \$test_item $test_item \@rrd_print @rrd_print\n";
      $column_count = 4;
      if ( $item_ret =~ /ovm_server_total_cpu|ovm_serverpools_total_cpu/ ) {
        $item_click = "ovm_server_cpu_core";
      }
      elsif ( $item_ret =~ /ovm_server_total_mem|ovm_serverpools_total_mem/ ) {
        $item_click = "ovm_server_mem_server";
      }
      else {
        $item_click = "ovm_vm_cpu_core";
      }

      if ( $item_ret =~ /ovm_vm/ ) {
        $link_type = "vm";
        @header    = ( 'VM', '', '', '' );
      }
      else {
        @header    = ( 'Server', '', '', '' );
        $link_type = "server";
      }
      if ( $item_ret =~ /cpu/ ) {
        $units = '[cores]';
      }
      elsif ( $item_ret =~ /mem/ ) {
        $units = '[GB]';
      }
    }
    elsif ( $item_ret =~ /ovm_server_total_net|ovm_serverpools_total_net/ ) {
      $column_count = 8;
      $link_type    = $item;
      @header       = ( 'Net name', 'Server', 'READ', 'WRITE', '' );
      $units        = '[MB/sec]';
    }
    elsif ( $item_ret =~ /ovm_server_total_disk|ovm_serverpools_total_disk|ovm_server_aggr_disk_used/ ) {
      $column_count = 8;
      $link_type    = $item;
      @header       = ( 'Disk id', 'Server', 'READ', 'WRITE', '' );
      $units        = '[MB/sec]';
    }
    elsif ( $item_ret =~ /ovm_server_aggr_net|ovm_vm_aggr_net/ ) {
      $link_type = $item;
      @header    = ( 'Net name', 'READ', 'WRITE', '' );
      $units     = '[MB/sec]';
    }
    elsif ( $item_ret =~ /ovm_vm_aggr_disk/ ) {
      $link_type = $item;
      @header    = ( 'Disk id', 'READ', 'WRITE', '' );
      $units     = '[MB/sec]';
    }
    elsif ( $item_ret =~ /custom_orvm/ ) {
      $column_count = 5;

      #  $link_type    = $item;
      @header = ( 'ServerPool', 'VM', '', '', '' );

      #  $units        = '[cores]';
    }

    #print STDERR "2856 \$item $item \$test_item $test_item \@rrd_print @rrd_print $column_count\n";
    my $table_header_4col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_5col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='5'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_header_7col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 7'>
    <thead>
      <tr>
        <th class=\"sortable header toleft\">$header[0]</th>
  <th>$header[1]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>$header[2]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>\n
END

    my $table_header_8col = <<END;
  <p class='custom0'>$units</p>
  <table class=\"tablesorter tablegend\" data-sortby='4 8'>
    <thead>
      <tr>
  <th class=\"sortable header toleft\">$header[0]</th>
  <th class=\"sortable header toleft\">$header[1]</th>
  <th>$header[2]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th>$header[3]</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>
END

    my $table_row_4col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_5col = <<END;
      <tr>
  <td class=\"legsq\">xorux_val1_color</td>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max</td>
      </tr>
END

    my $table_row_7col = <<END;
      <tr>
  <td title=\"bubble_info\" class=\"toleft\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END
    my $table_row_8col = <<END;
      <tr>
  <td class=\"clickabletd\">xorux_server_name</td>
  <td class=\"clickabletd\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_val1_color</td>
  <td>xorux_val1_avg</td>
  <td>xorux_val1_max&nbsp;</td>
  <td class=\"legsq\">xorux_val2_color</td>
  <td>xorux_val2_avg</td>
  <td>xorux_val2_max</td>
      </tr>\n
END

    my $table_end     = " </tbody> </table>\n";
    my $table_end_day = <<END;
    </tbody>
    <tfoot>
      <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>
    </tfoot>
  </table>\n
END

    if ( $column_count == 4 ) {
      push @table_out, $table_header_4col;
    }
    elsif ( $column_count == 5 ) {
      push @table_out, $table_header_5col;
    }
    elsif ( $column_count == 7 ) {
      push @table_out, $table_header_7col;
    }
    elsif ( $column_count == 8 ) {
      push @table_out, $table_header_8col;
    }
##  push @table_out, ( $column_count == 4 ? $table_header_4col : $table_header_7col );

    my $oraclevm_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
    my $oraclevm_metadata = OracleVmDataWrapperOOP->new( { acl_check => $oraclevm_acl } );

    while ( my $print_line = shift(@rrd_print) ) {
      my $table_row;    # = ( $column_count == 4 ? $table_row_4col : $table_row_7col );

      if ( $column_count == 4 ) {
        $table_row = $table_row_4col;
      }
      elsif ( $column_count == 5 ) {
        $table_row = $table_row_5col;
      }
      elsif ( $column_count == 7 ) {
        $table_row = $table_row_7col;
      }
      elsif ( $column_count == 8 ) {
        $table_row = $table_row_8col;
      }

      #print STDERR"line5345-print_line-$print_line\n";
      #print STDERR"line5346-rrd_print-@rrd_print\n";
      ( my $val1_avg, my $item, my $name_space, my $val1_color, undef ) = split( " $delimiter ", $print_line );
      ( my $val1_max, my $bubble_info, my $cluster, my $uuid, my $uuid_owner ) = split( " $delimiter ", shift(@rrd_print) );
      $bubble_info = "" if $bubble_info eq " ";
      $item =~ s/^custom_|cluster_aggr_|host_aggr_|_used(_percent)?$|_free$//g;

      my $name_space_show = $name_space;
      $name_space_show =~ s/&&1/\//g;
      $name_space_show =~ s/lan-//g;
      $name_space_show =~ s/\.rrd//g;

      #     $table_row =~ s/xorux_lpar_name/$name_space_show/;
      #     $table_row =~ s/xorux_val1_color/$val1_color/ unless $column_count == 5;
      $table_row =~ s/xorux_val1_avg/$val1_avg/;
      $table_row =~ s/xorux_val1_max/$val1_max/;

      #print STDERR"my $val1_max, my $bubble_info, my $cluster, my $uuid, my $uuid_owner\n";
      if ( $column_count == 4 ) {

        # vzor - /lpar2rrd-cgi/detail-graph.sh?host=OracleVM&server=nope&lpar=9303b6f8fcfe438a8ab398cfff840ff3&item=ovm_server_cpu_core&time=d&type_sam=&detail=9&entitle=0&none=-1587389689&d_platform=not defined
        my $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=OracleVM&server=nope&lpar=$uuid&item=$item_click&time=d&type_sam=&detail=1\"";
        my $link     = "<a href=\"/lpar2rrd-cgi/detail.sh?platform=OracleVM&type=$link_type\&id=$uuid\">$name_space_show</a>";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
      }
      elsif ( $column_count == 5 ) {
        my $data_url   = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=OracleVM&server=nope&lpar=$uuid&item=$item&time=$time&type_sam=$time&detail=1\"";
        my $link       = "<a href=\"/lpar2rrd-cgi/detail.sh?platform=OracleVM&type=$link_type\&id=$uuid\">$name_space_show</a>";
        my $link_owner = "<a href=\"/lpar2rrd-cgi/detail.sh?platform=OracleVM&type=server&id=$uuid_owner\">$cluster</a>";

        $table_row =~ s/xorux_lpar_name/$link/;
        $table_row =~ s/>xorux_val1_color/$data_url>$val1_color/;
        $table_row =~ s/xorux_server_name/$link_owner/;
      }
      elsif ( $column_count == 7 ) {
        my $link = "<a href=\"/lpar2rrd-cgi/detail.sh?platform=OracleVM&type=server&id=$uuid_owner\">$name_space_show</a>";
        $table_row =~ s/xorux_lpar_name/$link/;

        ( my $val2_avg, my $val2_color, my $a, my $b, my $c, my $d ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        $table_row =~ s/xorux_val1_color/$val1_color/;
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      elsif ( $column_count == 8 ) {
        my $link = "<a href=\"/lpar2rrd-cgi/detail.sh?platform=OracleVM&type=server&id=$uuid_owner\">$name_space_show</a>";
        if ( $item_ret =~ /ovm_server_total_net|ovm_serverpools_total_net/ ) {
          $table_row =~ s/xorux_lpar_name/$link/;
          my $net_name = $uuid;
          $net_name  =~ s/^lan-//g;
          $net_name  =~ s/\.rrd$//g;
          $table_row =~ s/xorux_server_name/$net_name/;
        }
        elsif ( $item_ret =~ /ovm_server_total_disk|ovm_serverpools_total_disk/ ) {
          $table_row =~ s/xorux_lpar_name/$link/;
          my $net_name = $uuid;
          $net_name =~ s/^disk-//g;
          $net_name =~ s/\.rrd$//g;
          my $server_disk = $oraclevm_metadata->get_label( 'server', $uuid_owner );
          $table_row =~ s/xorux_server_name/$net_name/;
        }
        elsif ( $item_ret =~ /ovm_server_aggr_disk_used/ ) {
          my $disk_name = $uuid;
          $disk_name =~ s/^disk-//g;
          $disk_name =~ s/\.rrd$//g;
          my $server_disk = $oraclevm_metadata->get_label( 'server', $uuid_owner );
          $table_row =~ s/xorux_server_name/$disk_name/;
          $table_row =~ s/xorux_lpar_name/$server_disk/;
        }
        ( my $val2_avg, my $val2_color ) = split( "$delimiter", shift(@rrd_print) );
        ( my $val2_max, undef ) = split( "$delimiter", shift(@rrd_print) );

        #print STDERR "$table_row,$link,$uuid\n";
        $table_row =~ s/xorux_val1_color/$val1_color/;
        $table_row =~ s/xorux_val2_color/$val2_color/;
        $table_row =~ s/xorux_val2_avg/$val2_avg/;
        $table_row =~ s/xorux_val2_max/$val2_max/;
        $table_row =~ s/bubble_info/$bubble_info/;
      }
      push @table_out, $table_row;
    }

    if ( $updated =~ /Updated/ ) {
      $table_end_day =~ s/(COMMENT:|\\)//g;
      push @table_out, $table_end_day;
    }
    else {
      push @table_out, $table_end;
    }
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /wlm-cpu/ || $item_ret =~ /wlm-mem/ || $item_ret =~ /wlm-dkio/ ) ) {
    my $line1_wlm = "<table class=\"tablesorter tablegend\" data-sortby=\"4\">
    <thead>
      <tr>

  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">Class&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2_wlm = "<tr>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td class=\"toleft\">Class</td>
        <td>xorux_lpar_avg</td>
        <td>xorux_lpar_max</td>
      </tr>";

    my $line3_wlm = "  </tbody>  </table>";

    my $line3_wlm_day = " </tbody>
      <tfoot>
      <td colspan=\"4\" class=\"tdupdated toleft\">$updated</td>
      </tfoot> </table>\n";

    push @table_out, $line1_wlm;

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_wlm;
      ( my $average, undef, my $lpar_space, my $color ) = split( " $delimiter ", $print_line );

      # ($lpar_space, my $user) = split(" ",$lpar_space);
      $print_line = shift(@rrd_print);

      # ( my $max, my $color, my $user, my $function, my $filename ) = split( " $delimiter ", $print_line );
      ( my $max, my $filename ) = split( " $delimiter ", $print_line );

      # $lpar_space =~ s/wlm-//g;
      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      $line2_act =~ s/Class/$lpar_space/;
      $filename  =~ s/\.mmm$//;
      $line2_act =~ s/xorux_lpar_color/$color/;

      #$line2_act =~ s/Type/$subtype/;
      # print STDERR "1138 \$filename $filename\n";
      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_wlm_day =~ s/COMMENT://;
      $line3_wlm_day =~ s/\\//g;
      push @table_out, $line3_wlm_day;
    }
    else {
      push @table_out, $line3_wlm;
    }

    # push  @table_out, $line3_wlm;
    #print STDERR "\@table_out @table_out\n";
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /memams-day/ || $item_ret =~ /cap_used-day/ || $item_ret =~ /cap_free-day/ || $item_ret =~ /cap_proc-day/ || $item_ret =~ /dsk_svc_as-day/ || $item_ret =~ /dsk_wait_as-day/ || $item_ret =~ /dsk_latency-day/ ) ) {

    # prepare table for memams day

    my $unit = "GB";
    $unit = "percent" if $item_ret =~ /cap_proc-day/;
    my $alloc_free = "Current allocated in $unit";
    $alloc_free = "Current free in $unit"     if $item_ret =~ /cap_free-day/;
    $alloc_free = "Disk service time in [ms]" if $item_ret =~ /dsk_svc_as-day/;
    $alloc_free = "Disk wait time in [ms]"    if $item_ret =~ /dsk_wait_as-day/;
    $alloc_free = "Disk latency time in [ms]" if $item_ret =~ /dsk_latency-day/;

    my $line1_memams_day = "<table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$alloc_free:</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Last&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2_memams_day = "    <tr>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td title=\"bubble_info\" class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_lpar_avg</td>
  <td>xorux_lpar_max</td>
  <td>xorux_lpar_last</td>
      </tr>";
    my $line3_memams = "  </tbody> </table>";

    my $line3_memams_day = " </tbody>
    <tfoot>
      <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
    </tfoot> </table>\n";

    push @table_out, $line1_memams_day;

    my $bubble_info = "";

    while ( my $print_line = shift(@rrd_print) ) {
      my $data_url  = "";
      my $line2_act = $line2_memams_day;
      ( my $average, undef, my $lpar_space, my $color, my $rrd_file_all ) = split( " $delimiter ", $print_line );

      $print_line = shift(@rrd_print);
      my $max             = "";
      my $lpar_space_orig = "";
      if ( defined $print_line ) {
        ( $max, $bubble_info, $lpar_space_orig ) = split( " $delimiter ", $print_line );
      }
      $print_line = shift(@rrd_print);
      my $last = "";
      if ( defined $print_line ) {
        ( $last, undef ) = split( "$delimiter", $print_line );
      }
      my $lpar_space_show = $lpar_space;
      $lpar_space_show =~ s/&&1/\//g;
      my $lpar_url   = $lpar_space_show;
      my $query_lpar = $lpar_space_show;
      if ( defined $rrd_file_all && $rrd_file_all ne "" ) {
        my @pathx    = split( "/", $rrd_file_all );
        my $hmc_t    = @pathx[ @pathx - 2 ];
        my $server_t = @pathx[ @pathx - 3 ];
        if ( $item_ret =~ /cap_/ ) {
          $hmc_t    = @pathx[ @pathx - 4 ];
          $server_t = @pathx[ @pathx - 5 ];
        }

        # $lpar_url =~ s/ /\+/g;
        # $lpar_url =~ s/([^A-Za-z0-9\+-_])/sprintf("%%%02X", ord($1))/seg; # PH: keep it is it is exactly!!!
        # $lpar_url =~ s/\#/%23/g;
        $lpar_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;

        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=lpar&entitle=0&none=none\">$lpar_space_show</a>";

        if ( $item_ret =~ /cap_/ ) {

          #          my $as_lpar = @pathx[@pathx - 3]."/ASP/".$lpar_url;
          my $as_lpar = @pathx[ @pathx - 3 ] . "/ASP/" . $lpar_space_orig;

          # print STDERR "1333 detail-graph-cgi.pl \$rrd_file_all $rrd_file_all \$hmc_t $hmc_t \$server_t $server_t \$lpar_url $lpar_url \$as_lpar $as_lpar\n";
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$hmc_t&server=$server_t&lpar=$as_lpar&item=asp_cap&time=$time&type_sam=$time&detail=1\"";
        }
      }
      else {
        $line2_act =~ s/clickabletd/toleft/;    # Configured max not
      }

      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      $line2_act =~ s/xorux_lpar_last/$last/;
      if ( $item_ret =~ /cap_/ ) {
        $query_lpar = $lpar_url;
      }
      $line2_act =~ s/xorux_lpar_name/$query_lpar/;
      $line2_act =~ s/>xorux_lpar_color/$data_url>$color/;
      $bubble_info = "" if !defined $bubble_info;
      $line2_act =~ s/bubble_info/$bubble_info/;
      if ( $lpar_space =~ "Configured max" ) {
        $line2_act = "<tfoot>" . $line2_act . "</tfoot>";
      }

      # print STDERR "1345 detail-graph-cgi.pl \$line2_act $line2_act \$bubble_info $bubble_info\n";
      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_memams_day =~ s/COMMENT://;
      $line3_memams_day =~ s/\\//g;
      push @table_out, $line3_memams_day;
    }
    else {
      push @table_out, $line3_memams;
    }
    return $graphv_line;
  }

  if ( defined $item_ret && ( $item_ret =~ /memams-other/ || $item_ret =~ /cap_used-other/ || $item_ret =~ /cap_free-other/ || $item_ret =~ /cap_proc-other/ || $item_ret =~ /dsk_svc_as-other/ || $item_ret =~ /dsk_wait_as-other/ || $item_ret =~ /dsk_latency-other/ ) ) {

    # prepare table for amsaggreg others

    my $unit = "GB";
    $unit = "percent" if $item_ret =~ /cap_proc-other/;

    my $alloc_free = "Current allocated in $unit";
    $alloc_free = "Current free in $unit"     if $item_ret =~ /cap_free-other/;
    $alloc_free = "Disk service time in [ms]" if $item_ret =~ /dsk_svc_as-other/;
    $alloc_free = "Disk wait time in [ms]"    if $item_ret =~ /dsk_wait_as-other/;
    $alloc_free = "Disk latency time in [ms]" if $item_ret =~ /dsk_latency-other/;

    my $line1_memams_other = "<table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th>&nbsp;</th>
  <th class=\"sortable header toleft\">$alloc_free:</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2_memams_other = "    <tr>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td title=\"bubble_info\" class=\"clickabletd\">xorux_lpar_name</td>
  <td>xorux_lpar_avg</td>
  <td>xorux_lpar_max</td>
      </tr>";
    my $line3_memams_other = "  </tbody> </table>";

    push @table_out, $line1_memams_other;
    my $bubble_info = "";

    while ( my $print_line = shift(@rrd_print) ) {
      my $data_url        = "";
      my $lpar_space_orig = "";
      my $line2_act       = $line2_memams_other;
      ( my $average, undef, my $lpar_space, my $color, my $rrd_file_all ) = split( " $delimiter ", $print_line );

      $print_line = shift(@rrd_print);
      my $max = "";
      if ( defined $print_line ) {
        ( $max, $bubble_info, $lpar_space_orig ) = split( " $delimiter ", $print_line );
      }
      my $lpar_space_show = $lpar_space;
      $lpar_space_show =~ s/&&1/\//g;
      my $lpar_url   = $lpar_space_show;
      my $query_lpar = $lpar_space_show;
      if ( defined $rrd_file_all && $rrd_file_all ne "" ) {
        my @pathx    = split( "/", $rrd_file_all );
        my $hmc_t    = @pathx[ @pathx - 2 ];
        my $server_t = @pathx[ @pathx - 3 ];
        if ( $item_ret =~ /cap_/ ) {
          $hmc_t    = @pathx[ @pathx - 4 ];
          $server_t = @pathx[ @pathx - 5 ];
        }

        # $lpar_url =~ s/ /\+/g;
        # $lpar_url =~ s/([^A-Za-z0-9\+-_])/sprintf("%%%02X", ord($1))/seg; # PH: keep it is it is exactly!!!
        # $lpar_url =~ s/\#/%23/g;
        $lpar_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;

        $query_lpar = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url&item=lpar&entitle=0&none=none\">$lpar_space_show</a>";

        if ( $item_ret =~ /cap_/ ) {

          #my $as_lpar = @pathx[@pathx - 3]."/ASP/".$lpar_url;
          my $as_lpar = @pathx[ @pathx - 3 ] . "/ASP/" . $lpar_space_orig;

          # print STDERR "1333 detail-graph-cgi.pl \$rrd_file_all $rrd_file_all \$hmc_t $hmc_t \$server_t $server_t \$lpar_url $lpar_url \$as_lpar $as_lpar\n";
          $data_url = " data-url=\"/lpar2rrd-cgi/detail-graph.sh?host=$hmc_t&server=$server_t&lpar=$as_lpar&item=asp_cap&time=$time&type_sam=$time&detail=1\"";
        }
      }
      else {
        $line2_act =~ s/clickabletd/toleft/;    # Configured max not
      }

      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      if ( $item_ret =~ /cap_/ ) {
        $query_lpar = $lpar_url;
      }
      $line2_act =~ s/xorux_lpar_name/$query_lpar/;
      $line2_act =~ s/>xorux_lpar_color/$data_url>$color/;
      $bubble_info = "" if !defined $bubble_info;
      $line2_act =~ s/bubble_info/$bubble_info/;
      if ( $lpar_space =~ "Configured max" ) {
        $line2_act = "<tfoot>" . $line2_act . "</tfoot>";
      }
      push @table_out, $line2_act;
    }
    push @table_out, $line3_memams_other;
    return $graphv_line;
  }

  if ( defined $item_ret && $item_ret =~ /san2-nmon/ ) {

    # prepare table for SAN2NMON

    my $line1_san2nmon = "<p class='custom0'>[$iops]</p>
  <table class=\"tablesorter tablegend\" data-sortby='4'>
    <thead>
      <tr>
  <th class=\"sortable header toleft\">Int</th>
  <th>TOTAL</th>
  <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
  <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2_san2nmon = "    <tr>
  <td class=\"toleft\">xorux_lpar_name</td>
  <td class=\"legsq\">xorux_lpar_color</td>
  <td>xorux_lpar_avg</td>
  <td>xorux_lpar_max</td>
      </tr>";

    my $line3_san2nmon_day = "  </tbody>
     <tfoot> <tr>
  <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr></tfoot>  </table>";
    my $line3_san2nmon = "  </tbody></table>";

    push @table_out, $line1_san2nmon;

    while ( my $print_line = shift(@rrd_print) ) {
      my $line2_act = $line2_san2nmon;
      ( my $average, undef, my $lpar_space, my $color ) = split( "$delimiter", $print_line );

      $print_line = shift(@rrd_print);
      ( my $max, undef ) = split( "$delimiter", $print_line );
      $line2_act =~ s/xorux_lpar_avg/$average/;
      $line2_act =~ s/xorux_lpar_max/$max/;
      $line2_act =~ s/xorux_lpar_name/$lpar_space/;
      $line2_act =~ s/xorux_lpar_color/$color/;
      push @table_out, $line2_act;
    }
    if ( $updated =~ /Updated/ ) {
      $line3_san2nmon_day =~ s/COMMENT://;
      $line3_san2nmon_day =~ s/\\//g;
      push @table_out, $line3_san2nmon_day;
    }
    else {
      push @table_out, $line3_san2nmon;
    }
    return $graphv_line;
  }

########        custom groups ######   &   hmc totals lpar

  if (
    defined $item_ret
    && ( $item_ret =~ /multiview-lpar/
      || $item_ret =~ /multiview-shpool/
      || $item_ret =~ /multiview-mem/
      || $item_ret =~ /multiview-osmem/
      || $item_ret =~ /multiview-ent/
      || $item_ret =~ /multiview-disk/
      || $item_ret =~ /multiview-net/
      || $item_ret =~ /multihmclpar/
      || $item_ret =~ /hyp_clustservms/
      || $item_ret =~ /custom_hyperv_cpu/ )
    )
  {
    # prepare HTML table for custom group
    my $lpar_pool = "Lpar";
    $lpar_pool = "VM" if ( $item_ret =~ /multiview-disk/ || $item_ret =~ /multihmclpar_vm/ || $item_ret =~ /multihmclpardy/ || $item_ret =~ /multiview-net/ || $item_ret =~ /multihmclpar_mem/ || $item_ret =~ /hyp_clustservms/ || $item_ret =~ /custom_hyperv_cpu/ );
    my $max_pool       = "";
    my $max_pool_value = "";
    my $hmc_rank       = 2;        # for lpar, shpool, mem
    my $server_rank    = 3;        # for lpar, shpool, mem
    my $item_leg       = "lpar";

    my $line0 = "<p class='custom0'>Utilization in CPU cores</p>";
    ($vmware) && ( $line0 = "<p class='custom0'>Utilization in CPU GHz  </p>" );
    ( $item_ret =~ /multiview-disk/ )        && ( $line0 = "<p class='custom0'>Disk MB/sec  </p>" );
    ( $item_ret =~ /multiview-net/ )         && ( $line0 = "<p class='custom0'>Network MB/sec  </p>" );
    ( $item_ret =~ /multihmclpar_vm/ )       && ( $line0 = "<p class='custom0'>Utilization in CPU GHz  </p>" );
    ( $item_ret =~ /multihmclpar_mem/ )      && ( $line0 = "<p class='custom0'>Active Memory in GB  </p>" );
    ( $item_ret =~ /multihmclpar_memgrant/ ) && ( $line0 = "<p class='custom0'>Granted Memory in GB  </p>" );
    ( $item_ret =~ /multiview-mem/ )         && ( $line0 = "<p class='custom0'>Allocation in GB</p>" );
    ( $item_ret =~ /multihmclpardy/ ) && do {
      $line0    = "<p class='custom0'>CPU-ready-%/vCPU</p>";
      $item_leg = "vmw-ready";
    };
    ( $item_ret =~ /multiview-osmem/ ) && do {
      $line0       = "<p class='custom0'>Used memory in GBytes</p>";
      $hmc_rank    = 3;
      $server_rank = 4;
    };
    ( $item_ret =~ /multiview-ent-[lan|san]/ ) && do {
      $line0          = "<p class='custom0'>[MB/sec]</p>";
      $max_pool       = "<th class=\"sortable header toleft\">int&nbsp;&nbsp;&nbsp;&nbsp;</th>";
      $max_pool_value = "<td class=\"toleft\">xorux_int_adapter</td>";
      $hmc_rank       = 3;
      $server_rank    = 4;
    };
    ( $item_ret =~ /multiview-ent-san2/ ) && do {
      $line0       = "<p class='custom0'>[$iops]</p>";
      $hmc_rank    = 3;
      $server_rank = 4;
    };
    ( $item_ret =~ /multiview-shpool/ ) && do {
      $lpar_pool      = "Pool";
      $max_pool       = "<th class=\"sortable header\">Max pool&nbsp;&nbsp;&nbsp;&nbsp;</th>";
      $max_pool_value = "<td>xorux_max_pool</td>";
    };
    ( $item_ret =~ /multiview-lpar/ ) && do {
      $max_pool       = "<th class=\"sortable header\">Entitled&nbsp;&nbsp;&nbsp;&nbsp;</th>";
      $max_pool_value = "<td>xorux_lpar_entitled</td>";
    };

    # my $first_col_line1 = "<th>&nbsp;</th> <th class=\"sortable header toleft\">Server</th>";
    my $first_col_line1 = "<th class=\"sortable header toleft\">Server</th>";

    # my $first_col_line2 = "<td class=\"legsq\">xorux_lpar_color</td> <td class=\"clickabletd\">xorux_server_name</td>";
    my $first_col_line2 = "<td class=\"clickabletd\">xorux_server_name</td>";
    ( $item_ret =~ /multihmclpar_linux_cpu/ ) && do {
      $line0           = "<p class='custom0'>Utilization in CPU %  </p>";
      $first_col_line1 = "";
      $first_col_line2 = "";
      $lpar_pool       = "Linux";
    };
    ( $item_ret =~ /multihmclpar_linux_mem/ ) && do {
      $line0           = "<p class='custom0'>Memory in GB  </p>";
      $first_col_line1 = "";
      $first_col_line2 = "";
      $lpar_pool       = "Linux";
    };
    my $line1 = "<table class=\"tablesorter tablegend\" data-sortby='6 5'>
    <thead>
      <tr>
      <th>&nbsp;</th>
        $first_col_line1
        <th class=\"sortable header toleft\">$lpar_pool</th>
        $max_pool
        <th class=\"sortable header\">Avrg&nbsp;&nbsp;&nbsp;&nbsp;</th>
        <th class=\"sortable header\">Max&nbsp;&nbsp;&nbsp;&nbsp;</th>
      </tr>
    </thead>
    <tbody>";
    my $line2 = "    <tr>
    <td class=\"legsq\">xorux_lpar_color</td>
  $first_col_line2
        <td class=\"clickabletd\">xorux_lpar_name</td>
        $max_pool_value
  <td>xorux_lpar_avg</td>
  <td>xorux_lpar_max</td>
      </tr>";
    my $line4_updated = "";
    if ( $updated =~ "Updated" ) {
      $line4_updated = " <tr>
        <td colspan=\"7\" class=\"tdupdated toleft\">$updated</td>
      </tr>";
    }
    my $line4_note = "</tbody> <tr> <td colspan=\"7\">(Note that for CPU dedicated LPARs is always shown their whole entitlement)</td></tr></table>\n";

    push @table_out, $line0;
    push @table_out, $line1;

    my $total_lines          = "";
    my $total_lines_to_print = "";
    my ( $average, $server_space, $lpar_space, $int, $color, $rrd_file_all, $hyp_cluster );

    # print STDERR "3156 \@rrd_print",join("\n",@rrd_print),"\n";

    my @menu;
    if ( $item_ret =~ /custom_hyperv_cpu/ ) {    # you need menu, some VMs can be in cluster
      read_menu( \@menu );

      # print STDERR "2788 menu.txt @menu\n";
    }

    #my @matches = grep { /^L/ && /$lpar/ } @menu;
    # print STDERR "2790 @matches\n";
    #( undef, $host ) = split( "host=", $matches[0] );
    #( $host, undef ) = split( "&", $host );

    while ( my $print_line = shift(@rrd_print) ) {
      if ( $print_line !~ "$delimiter Total" ) {
        my $line2_act = $line2;
        if ( $item_ret !~ /multiview-ent/ ) {
          ( $average, undef, $server_space, $lpar_space, undef, $hyp_cluster ) = split( " $delimiter ", $print_line );

          # 0.00 XORUX custom_hyperv_cpu XORUX HVNODE02                   XORUX hvlinux03 XORUX #0000FF XORUX /home/lpar2rrd/lpar2rrd/data/windows/domain_ad.xorux.com/hyperv_VMs/8127B1FB-FFD6-4A9F-82BC-36CF9F18
          #
          if ( !defined $lpar_space ) {
            $lpar_space = "lpar_space";
            error( "no lpar_space value for item : $item_ret in \$print_line $print_line " . __FILE__ . ":" . __LINE__ );
          }
        }
        else {    # also multiview-ent[-lan|-san|-san2]
          ( $average, undef, $server_space, $lpar_space, $int ) = split( " $delimiter ", $print_line );
          if ( !defined $lpar_space ) {
            $lpar_space = "lpar_space";
            error( "no lpar_space value for item : $item_ret in \$print_line $print_line " . __FILE__ . ":" . __LINE__ );
          }
          $line2_act =~ s/xorux_int_adapter/$int/ if defined $int;
        }
        if ( $item_ret =~ /multiview-shpool/ ) {
          $print_line = shift(@rrd_print);
          ( my $mx_pool, undef ) = split( "$delimiter", $print_line );
          $line2_act =~ s/xorux_max_pool/$mx_pool/;
        }
        $print_line = shift(@rrd_print);
        ( my $average, $color, $rrd_file_all ) = split( "$delimiter", $print_line );
        $print_line = shift(@rrd_print);
        ( my $max, undef ) = split( "$delimiter", $print_line );
        my $entitled = "";
        if ( $item_ret =~ /multiview-lpar/ ) {
          $print_line = shift(@rrd_print);
          if ( defined $print_line && $print_line ne "" ) {
            ( $entitled, undef ) = split( "$delimiter", $print_line );

            # print STDERR "3181 \$entitled ,$entitled,\n";
          }
        }
        my $lpar_space_show   = $lpar_space;
        my $server_space_show = $server_space;
        if ( !defined $lpar_space_show ) {
          error( "no lpar value for item : $item_ret " . __FILE__ . ":" . __LINE__ );
          next;
        }
        $lpar_space_show   =~ s/&&1/\//g;
        $server_space_show =~ s/&&1/\//g;
        my $lpar_url     = $lpar_space_show;
        my $query_lpar   = $lpar_space_show;
        my $server_url   = $server_space_show;
        my $query_server = $server_space_show;
        if ( defined $rrd_file_all ) {

          # print STDERR "3264 clickable \$rrd_file_all $rrd_file_all \$lpar_space_show ,$lpar_space_show,\n";
          my @pathx     = split( "/", $rrd_file_all );
          my $hmc_t     = @pathx[ @pathx - $hmc_rank ];
          my $server_t  = @pathx[ @pathx - $server_rank ];
          my $file_name = @pathx[ @pathx - 1 ];
          if ( $item_ret =~ /multihmclpardy/ ) {    # for VM prepare UUID
                                                    # $lpar_url = $file_name;
            $lpar_url = $lpar_space;

            # $lpar_url =~ s/\.rrm$//;
          }

          # print STDERR "2351 \$hmc_t $hmc_t \$server_t $server_t \$file_name $file_name\n";
          if ( $item_ret =~ /hyp_clustservms/ ) {
            $server_t = "windows/$server_t";
            $lpar_url = $file_name;
            $lpar_url =~ s/\.rrm$//;
          }

          # $lpar_url =~ s/ /\+/g;
          # $lpar_url =~ s/([^A-Za-z0-9\+-_])/sprintf("%%%02X", ord($1))/seg; # PH: keep it is it is exactly!!!
          # $lpar_url =~ s/\#/%23/g;
          $lpar_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;

          # $server_url =~ s/ /\+/g;
          # $server_url =~ s/([^A-Za-z0-9\+-_])/sprintf("%%%02X", ord($1))/seg; # PH: keep it is it is exactly!!!
          # $server_url =~ s/\#/%23/g;
          $server_url =~ s/([^a-zA-Z0-9_.!:~*()'\''-])/sprintf("%%%02X", ord($1))/ge;

          if ( $file_name =~ /SharedPool/ ) {
            $file_name =~ s/\.rr.$//;
            $lpar_url = $file_name;
          }    # &none=none&square_item=$item_leg
               # remove lpar alias   aix1 [ala/ix1]
          my $lpar_url_without_alias = $lpar_url;
          $lpar_url_without_alias =~ s/%5B.*%5D//;

          if ( $item_ret =~ /hyp_clustservms/ || $item_ret =~ /custom_hyperv_cpu/ ) {

            # new wave solution
            # HOST/Totals
            # platform=hyperv&item=host&domain=ad.int.xorux.com&name=HYPERV
            #
            # HOST/VM
            # platform=hyperv&item=vm&domain=ad.int.xorux.com&host=HYPERV&name=XoruX-master
            # or it can be in cluster

            # print STDERR "3248 $item_ret \$server_t $server_t \$lpar_url_without_alias $lpar_url_without_alias \$lpar_space_show $lpar_space_show \$server_space_show $server_space_show\n";
            my $domain = $server_t;
            my $x_lpar = $lpar_space_show;
            $x_lpar =~ s/^\s+|\s+$//g;
            my $x_server = $server_space_show;
            $x_server    =~ s/^\s+|\s+$//g;
            $domain      =~ s/windows\/domain_//;
            $hyp_cluster =~ s/cluster_//;

            $query_lpar   = "<a href=\"?platform=hyperv&item=vm&cluster=$hyp_cluster&host=$x_server&name=$x_lpar&id=$lpar_url_without_alias\">$lpar_space_show</a>";
            $query_server = "<a href=\"?platform=hyperv&item=host&domain=$domain&name=$x_server&host=host\">$server_space_show</a>";
            if ( $item_ret =~ /custom_hyperv_cpu/ ) {

              # find out if VM is in cluster
              my @matches = grep { /^L/ && /$lpar_url_without_alias/ } @menu;

              # print STDERR "3322 @matches\n";
              # L:ad.xorux.com:HVNODE01:61538264-853B-43A0-99F5-DCFE083864C0:hvlinux02:/lpar2rrd-cgi/detail.sh?host=HVNODE01&server=windows/domain_ad.xorux.com&lpar=61538264-853B-43A0-99F5-DCFE083864C0&item=lpar&entitle=0&gui=1&none=none:MSNET-HVCL::H
              my $hyp_cluster = "";
              if ( defined $matches[0] ) {
                ( undef, undef, undef, undef, undef, undef, $hyp_cluster, undef ) = split( ":", $matches[0] );
              }
              if ( $hyp_cluster ne "" ) {
                $query_lpar = "<a href=\"?platform=hyperv&item=vm&cluster=$hyp_cluster&host=$x_server&name=$x_lpar&id=$lpar_url_without_alias\">$lpar_space_show</a>";
              }
              else {
                $query_lpar = "<a href=\"?platform=hyperv&item=vm&host=$x_server&name=$x_lpar&id=$lpar_url_without_alias\">$lpar_space_show</a>";
              }
            }
          }
          else {
            my $platform = "";
            if ($xormon) {

              #$platform = "&platform=VMware";
            }

            $server_t     = "" if !defined $server_t;
            $query_lpar   = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=$lpar_url_without_alias&item=lpar&entitle=0&none=none&d_platform=$params{d_platform}$platform\">$lpar_space_show</a>";
            $query_server = "<a href=\"/lpar2rrd-cgi/detail.sh?host=$hmc_t&server=$server_t&lpar=pool&item=pool&entitle=0&none=none&d_platform=$params{d_platform}$platform\">$server_space_show</a>";
          }

          ( $lpar_space_show =~ /^CPU pool$/ ) && ( $query_lpar =~ s/lpar=CPU%20pool\&item=lpar/lpar=pool&item=pool/ );    # replace CPU pool by "pool"
          ( $lpar_url        =~ /SharedPool/ ) && ( $query_lpar =~ s/item=lpar/item=pool/ );

        }
        $line2_act =~ s/xorux_lpar_avg/$average/;
        $line2_act =~ s/xorux_lpar_max/$max/;
        $line2_act =~ s/xorux_lpar_entitled/$entitled/;
        $line2_act =~ s/xorux_server_name/$query_server/;
        $line2_act =~ s/xorux_lpar_name/$query_lpar/;
        $line2_act =~ s/xorux_lpar_color/$color/;

        #        ( $item_ret =~ /multiview-mem/)   && ( $line2_act =~ s/legsq//);

        push @table_out, $line2_act;
      }
      else {
        my $total_text = "Total";
        ( my $average, undef ) = split( "$delimiter", $print_line );
        my $line2_act = $line2;
        $line2_act =~ s/clickabletd/toleft/g;    # Total not

        ( $print_line =~ /Total max/ ) && do {
          $line2_act =~ s/xorux_lpar_avg//;
          $line2_act =~ s/xorux_lpar_max//;
          $line2_act =~ s/xorux_lpar_name//;
          $line2_act =~ s/xorux_max_pool/$average/;
          $line2_act =~ s/xorux_server_name/Total max pool units/;
          $line2_act =~ s/xorux_lpar_color/#000000/;                 #$color
          $total_lines .= $line2_act;
          $line2_act = "";
        };
        ( $print_line =~ /Total entitled processor cores/ ) && do {
          $line2_act =~ s/xorux_lpar_avg//;
          $line2_act =~ s/xorux_lpar_max//;
          $line2_act =~ s/xorux_lpar_name//;
          $line2_act =~ s/xorux_lpar_entitled/$average/;
          $line2_act =~ s/xorux_max_pool//;
          $line2_act =~ s/xorux_server_name/Total entitled processor cores/;
          $line2_act =~ s/xorux_lpar_color/#000000/;                           #$color
          $total_lines .= $line2_act;
          $line2_act = "";
        };
        ( $print_line =~ /Total ava/ ) && do {
          $line2_act =~ s/xorux_lpar_avg/$average/;
          $line2_act =~ s/xorux_lpar_max//;
          $line2_act =~ s/xorux_lpar_name//;
          $line2_act =~ s/xorux_max_pool//;
          $line2_act =~ s/xorux_server_name/Total available/;
          $line2_act =~ s/xorux_lpar_color/#000000/;                           #$color
          $total_lines .= $line2_act;
          $line2_act = "";
        };
        ( $print_line =~ /Total ave/ ) && do {
          $line2_act =~ s/xorux_lpar_avg/$average/;
          $line2_act =~ s/xorux_lpar_max//;
          $line2_act =~ s/xorux_lpar_name//;
          $line2_act =~ s/xorux_lpar_entitled//;
          $line2_act =~ s/xorux_max_pool//;
          $line2_act =~ s/xorux_server_name/Total average/;
          $line2_act =~ s/xorux_lpar_color//;                                  #$color is no color
          $total_lines .= $line2_act;
          $line2_act = "";
        };
        $total_lines_to_print .= $total_lines;
        $total_lines = "";
        push @table_out, $line2_act if ( $line2_act ne "" );
      }
    }
    my $tbody_end = "</tbody>";
    push @table_out, $tbody_end;

    $total_lines_to_print = "<tfoot>" . $total_lines_to_print . $line4_updated . "</tfoot></table>";
    push @table_out, $total_lines_to_print;

    # print STDERR "1951 \@table_out @table_out\n";
    return $graphv_line;
  }
  if ( $item_ret =~ m/power_.an/ ) {
    return;
  }
  error( "sub ret_graph_param - not recognised item : $item_ret " . __FILE__ . ":" . __LINE__ );

  #print STDERR "1700 detail-graph-cgi.pl ??? \@table_out @table_out\n";
}

sub get_vcenter_host {
  my $vcenter_uuid = shift;
  if ( $vcenter_uuid !~ /^vmware_/ ) {
    return $vcenter_uuid;
  }

  # from vmware_eb6102a7-1fa0-4376-acbb-f67e34a2212c_28 returns vmware host '10.22.11.10'
  # which is in servers.txt in 2nd part of each line 10.22.11.14XORUX10.22.11.10

  my $hosts_in_cluster = "$wrkdir/$vcenter_uuid/servers.txt";
  if ( open( my $FF, "<$hosts_in_cluster" ) ) {
    my @hosts = (<$FF>);
    close($FF);
    ( undef, my $vcenter_host ) = split "XORUX", $hosts[0];
    chomp $vcenter_host;
    return $vcenter_host;
  }
  else {
    error( "can't open $hosts_in_cluster: $! :" . __FILE__ . ":" . __LINE__ );
    return $vcenter_uuid;
  }
}

sub graph_lpar {
  my $host         = shift;
  my $server       = shift;
  my $lpar         = shift;
  my $type         = shift;
  my $name_out     = shift;
  my $type_sam     = shift;
  my $upper        = shift;
  my $detail       = shift;
  my $graph_hours  = shift;
  my $entitle      = shift;             # 1 do not show entitle area
  my $start_unix   = shift;
  my $end_unix     = shift;
  my $super_detail = shift;
  my $t            = "COMMENT:\" \"";
  my $t2           = "COMMENT:\\n";
  my $step_new     = $step;
  my $last         = "COMMENT:\" \"";
  my $rigid        = "\n --rigid";

  my $file_pth_vcpu = "$wrkdir/$server/*/$lpar";
  my $no_name       = "";
  my @files_test    = <$file_pth_vcpu.rvm>;
  my $vcpu_found    = scalar(@files_test);

  # print STDERR "2475 detail-graph-cgi.pl sub graph_lpar ,$host,$server,$lpar,$type,$item,$type_sam,$detail,$graph_hours \$hyperv $hyperv \$vmware $vmware\n";

  my $type_orig = $type;

  # print STDERR "2189 \$detail $detail \$type $type\n";

  #  my $in_cores = 1; # graph for vmware is in cores
  my $in_cores     = 0;    # graph for vmware is in MHz
                           #my $in_cores = 2;  # graph for vmware has right axis
  my $one_core_hz  = 1;
  my $one_core_mhz = 1;
  my $one_core_ghz = 1;

  # if (time % 2 == 0) {$in_cores = 1};  # just for fun

  #  my $vmware = 0;  # is global variable

  my $keep_virtual = 0;
  if ( $ENV{KEEP_VIRTUAL} ) {
    $keep_virtual = $ENV{KEEP_VIRTUAL};    # keep number of virt processors in RRD --> etc/.magic
  }
  else {
    $keep_virtual = 0;
  }

  #print "001 $host:$server:$lpar:$name_out:$type_sam\n";
  # print STDERR "v graph_lpar\$upper $upper\n";

  if ( !defined $upper || $upper eq '' || $upper =~ "entitle" || $upper =~ m/none/ || $upper == 0 ) {    # entitle  badly sent param
    $upper = 0.1;
  }

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $units_exponent = "--units-exponent=1.00";
  $units_exponent = "" if $vmware;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lpar: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $super_detail == 3 ) {

        # GFR request
        $xgrid = " --x-grid=MINUTE:60:HOUR:1:HOUR:2:0:%H ";
      }
      elsif ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  my $header_prefix = "LPAR:";
  my $rrd           = "$wrkdir/$server/$host/$lpar.rr$type_sam";

  if ($vmware) {
    if ( $detail == 1 ) {
      $lpar = human_vmware_name( $lpar, "neg" );
    }
    $rrd           = "$wrkdir/$all_vmware_VMs/$lpar.rrm";
    $header_prefix = "VM:";
  }
  if ($hyperv) {
    if ( $detail == 1 ) {
      $lpar = human_vmware_name( $lpar, "neg", $server );
    }
    $rrd           = "$wrkdir/$server/$all_hyperv_VMs/$lpar.rrm";
    $header_prefix = "VM:";
  }
  if ($hitachi) {
    $rrd = "$wrkdir/$server/$host/$lpar.hlm";
  }

  # print STDERR"%%$host!!\n";
  if ( $host =~ /Solaris/ ) {
    $rrd = "$wrkdir/$host/$server/ZONE/$lpar.mmm";

    #print STDERR"=== $rrd ===\n";
  }
  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $lpar_slash = human_vmware_name( $lpar, "", $server );
  if ($vmware) {
    $lpar_slash =~ s/\(.*\)//;
  }

  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt      = " ";
    $header_prefix = "";
  }

  my $header      = "$header_prefix $lpar_slash_nmon :$last_txt$text";
  my $header_only = $header;

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  my $vcpu = 0;

  if ( ( $type =~ "d" && $graph_hours == 0 ) || $vmware ) {    # || $hyperv ) {
    my $rrd_last = rrd_file_actual("$rrd");
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    if ( $type =~ "d" ) {
      $l =~ s/:/\\:/g;
      $t = "COMMENT:Updated\\:\" $l \"";
    }

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );

    # print STDERR "\@row_arr @row_arr\n";
    my $m = "";
    my $i = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );
        if ($vmware) {

          # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
          if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ ) {

            #print "m : $m\n" if $DEBUG ;
            #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
            my $utiltot_mhz = 1;
            my $utiltot_ghz = 1;
            $utiltot_mhz = sprintf( "%e", $m_arr[2] );
            $utiltot_ghz = $utiltot_mhz / 1000;
            $one_core_hz = sprintf( "%e", $m_arr[3] );
            if ($in_cores) {
              my $util = sprintf( "%5.2f", $utiltot_mhz / $one_core_hz * 1000000 );
              if ( $type !~ "d" ) {next}
              $last = "COMMENT:\"Last CPU usage in cores      $util\"";
              if ( $in_cores == 2 ) {
                my $utlt_mhz = sprintf( "%5.0f", $utiltot_mhz );
                my $utlt_ghz = sprintf( "%5.2f", $utiltot_ghz );
                $last = "COMMENT:\"Last CPU usage                $util    $utlt_ghz\"";
              }
            }
            else {
              $utiltot_mhz = $utiltot_mhz / 1000;
              my $util = sprintf( "%5.2f", $utiltot_mhz );
              $last = "COMMENT:\"Last utilization            $util\"";
            }

            # get vCPU
            # print STDERR "\$m_arr[18] $m_arr[18]\n";
            $vcpu = $m_arr[18];
            $vcpu = sprintf( "%e", $vcpu );
            $vcpu = $vcpu * 1;
            if ( !defined $vcpu ) {
              $vcpu = 'not defined';
            }
          }
        }
        elsif ($hitachi) {
          if ( $m_arr[1] =~ /\d/ ) {
            my $util = sprintf( "%5.2f", sprintf( "%e", $m_arr[1] ) );
            $last = "COMMENT:\"Last utilization in CPU cores  $util\"";
          }
        }
        else {
          # go further ony if it is a digit (avoid it when NaNQ (== no data) is there)
          if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ && $m_arr[4] =~ /\d/ ) {

            #print "m : $m\n" if $DEBUG ;
            #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
            my $entitled_cycles = 1;
            my $capped_cycles   = 1;
            my $uncapped_cycles = 1;
            my $curr_proc       = 1;

            if ( $keep_virtual == 1 ) {

              # when KEEP_VIRTUAL then virtual_procs is the second field
              $entitled_cycles = sprintf( "%e", $m_arr[3] );
              $capped_cycles   = sprintf( "%e", $m_arr[4] );
              $uncapped_cycles = sprintf( "%e", $m_arr[5] );
              $curr_proc       = sprintf( "%e", $m_arr[1] );
            }
            else {
              $entitled_cycles = sprintf( "%e", $m_arr[2] );
              $capped_cycles   = sprintf( "%e", $m_arr[3] );
              $uncapped_cycles = sprintf( "%e", $m_arr[4] );
              $curr_proc       = sprintf( "%e", $m_arr[1] );
            }
            if ( $entitled_cycles != 0 ) {
              my $util = sprintf( "%5.2f", ( $capped_cycles + $uncapped_cycles ) / $entitled_cycles ) * $curr_proc;

              #print ("\n $util $curr_proc $entitled_cycles $capped_cycles $uncapped_cycles\n");

              $last = "COMMENT:\"Last utilization in CPU cores  $util\"";
            }
          }
        }
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  #  my $start_time = "now-1$type";
  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=\"CPU cores\"";
  $vertical_label = "--vertical-label=\"CPU usage in Hz\"" if $vmware && !$in_cores;
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # print STDERR "creating graph : $host:$server:$lpar_slash:$type_sam:$type:$name_out:$rrd:$entitle:$item \$header $header\n" if $DEBUG ;

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $cmd = "";

  $cmd .= "$graph_cmd \"$name_out\"";
  if ( $in_cores == 2 && $vmware ) {

    #  $cmd .= " --right-axis-label \"CPU usage in MHz\"";
    $one_core_mhz = int( $one_core_hz / 1000000 );
    $one_core_ghz = $one_core_mhz / 1000;
    if ($yes_right_axis) {
      $cmd .= " --right-axis $one_core_ghz:0";
      $cmd .= " --right-axis-format %1.2lf";
    }
  }

  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";

  # $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=$upper";
  $cmd .= " $vertical_label";
  $cmd .= " $units_exponent";           #--units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  #  for LPM
  my @rrd_files;
  my @rrd_files_rvm;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first

  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "", \@rrd_files, $cgi );

  # print STDERR "2505 lpm_find_files is returning @rrd_files\n";

  my $i = -1;              # iterators for LPM cycle
  my $j;

  my $cores_mhz = "cores";    # for vmware graph legend
  if ( $in_cores == 2 ) {
    $cores_mhz = "     ";
  }
  my $gprint_form = "8.2lf";
  my $rrv_present;
  if ($vmware) {

    foreach $rrd (@rrd_files) {    # LPM cycle
      chomp($rrd);
      $i++;
      $j = $i - 1;
      $rrd =~ s/:/\\:/g;

      $cmd .= " DEF:ent${i}=\"$rrd\":CPU_Alloc:AVERAGE";
      $cmd .= " DEF:utl${i}=\"$rrd\":CPU_usage:AVERAGE";
      $cmd .= " DEF:hz${i}=\"$rrd\":host_hz:AVERAGE";
      $cmd .= " DEF:vcpu${i}=\"$rrd\":vCPU:AVERAGE";
      if ( $i == 0 ) {
        $cmd .= " CDEF:entr${i}=ent${i}";
        $cmd .= " CDEF:utlr${i}=utl${i}";
        $cmd .= " CDEF:hzr${i}=hz${i}";
        $cmd .= " CDEF:vcpur${i}=vcpu${i}";
        next;
      }
      $cmd .= " CDEF:entr${i}=entr${j},UN,ent${i},entr${j},IF";
      $cmd .= " CDEF:utlr${i}=utlr${j},UN,utl${i},utlr${j},IF";
      $cmd .= " CDEF:hzr${i}=hzr${j},UN,hz${i},hzr${j},IF";
      $cmd .= " CDEF:hzr${i}=vcpur${j},UN,vcpu${i},vcpur${j},IF";
    }
    $cmd .= " CDEF:cpu_entitl_mhz=entr${i}";
    $cmd .= " CDEF:utiltot_mhz=utlr${i}";
    $cmd .= " CDEF:one_core_hz=hzr${i}";
    $cmd .= " CDEF:vcpu_num=vcpur${i}";

    if ($in_cores) {
      $cmd .= " CDEF:utiltot=utiltot_mhz,one_core_hz,/,1000000,*";
      $cmd .= " CDEF:cpu_entitl=cpu_entitl_mhz,one_core_hz,/,1000000,*";
    }
    else {    # in GHz
      $cmd .= " CDEF:utiltotgp=utiltot_mhz,1000,/";
      $cmd .= " CDEF:cpu_entitlgp=cpu_entitl_mhz,1000,/";
      $cmd .= " CDEF:utiltot=utiltot_mhz,1000,*,1000,*";
      $cmd .= " CDEF:cpu_entitl=cpu_entitl_mhz,1000,*,1000,*";
      $cores_mhz   = "     ";
      $gprint_form = "5.1lf";
    }
  }
  elsif ($hitachi) {
    $cmd .= " DEF:cores=\"$rrd\":cores:AVERAGE";
  }
  else {

    my $file_pth_vcpu = "$wrkdir/$server/*/$lpar.rvm";
    my ( $result_vcpu_cmd, $vcpu ) = LPM_easy( "AVERAGE", $file_pth_vcpu, "0", "0", "allocated_cores" );
    $cmd .= $result_vcpu_cmd        if ($vcpu_found);
    $cmd .= " CDEF:allocated=$vcpu" if ($vcpu_found);

    my $last_updated_rvm = "";
    foreach my $rrd_tot (@rrd_files) {    # LPM cycle
      chomp($rrd_tot);

      # LPM identifies all servers, however not all HMC under servers
      # Add here data from all HMcs
      my $lpar_name  = basename($rrd_tot);
      my $server_dir = dirname($rrd_tot) . "/..";
      my $file_pth   = "$server_dir/*/$lpar_name";

      $file_pth =~ s/ /\\ /g;
      my $no_name = "";
      my @files   = (<$file_pth$no_name>);    # unsorted, workaround for space in names
      foreach $rrd (@files) {                 # LPM alias cycle
        chomp($rrd);
        $i++;
        $j = $i - 1;
        $rrd =~ s/:/\\:/g;

        my $rrv = $rrd;
        $rrv =~ s/rrm/rvm/g;
        $last_updated_rvm = $rrv if ( $last_updated_rvm eq "" );

        #my $rrv_act = rrd_file_actual ($rrv, 1);
        #$rrv_act =~ s/:/\\:/g;
        if ( -e $rrv && !defined $rrv_present->{$lpar} ) {    # if there is .rvm file with vCPU, not in all LPMed servers. If there is the .rvm file, add it to the graphs
                                                              #$rrv_present->{$lpar} = 1;
                                                              #$cmd .= " DEF:allocated=\"$rrv\":allocated_cores:AVERAGE";
        }
        $last_updated_rvm = $rrv if ( -e $rrv && ( Xorux_lib::file_time_diff($rrv) <= Xorux_lib::file_time_diff($last_updated_rvm) ) );
        $cmd .= " DEF:cur${i}=\"$rrd\":curr_proc_units:AVERAGE";
        $cmd .= " DEF:ent${i}=\"$rrd\":entitled_cycles:AVERAGE";
        $cmd .= " DEF:cap${i}=\"$rrd\":capped_cycles:AVERAGE";
        $cmd .= " DEF:uncap${i}=\"$rrd\":uncapped_cycles:AVERAGE";
        if ( $i == 0 ) {

          #$cmd .= " CDEF:allocatedr${i}=allocated${i}" if ( defined $rrv_present->{$lpar} && $rrv_present->{$lpar} ); # add vCPU to lpar graph
          $cmd .= " CDEF:curr${i}=cur${i}";
          $cmd .= " CDEF:entr${i}=ent${i}";
          $cmd .= " CDEF:capr${i}=cap${i}";
          $cmd .= " CDEF:uncapr${i}=uncap${i}";
          next;
        }

        #$cmd .= " CDEF:allocatedr${i}=allocatedr${j},UN,allocated${i},allocatedr${j},IF" if ( defined $rrv_present->{$lpar} && $rrv_present->{$lpar} ); # add vCPU to lpar graph
        $cmd .= " CDEF:curr${i}=curr${j},UN,cur${i},curr${j},IF";
        $cmd .= " CDEF:entr${i}=entr${j},UN,ent${i},entr${j},IF";
        $cmd .= " CDEF:capr${i}=capr${j},UN,cap${i},capr${j},IF";
        $cmd .= " CDEF:uncapr${i}=uncapr${j},UN,uncap${i},uncapr${j},IF";
      }
    }

    #$cmd .= " CDEF:allocated=allocatedr${i}" if ( defined $rrv_present->{$lpar} && $rrv_present->{$lpar} ); # add vCPU to lpar graph
    $cmd .= " CDEF:cur=curr${i}";
    $cmd .= " CDEF:ent=entr${i}";
    $cmd .= " CDEF:cap_peak=capr${i}";
    $cmd .= " CDEF:uncap=uncapr${i}";

    # filtering peaks caused by LPM or changing entitled, if cap CPU util is > entitled --> UNKN
    # usualy cap counter is affected only
    # sometimes might happen that even in normal load capped util is little higher than entitled! Therefore using 1.2
    $cmd .= " CDEF:cap=cap_peak,ent,/,1.2,GT,UNKN,cap_peak,IF";

    $cmd .= " CDEF:tot=cap,uncap,+";
    $cmd .= " CDEF:util=tot,ent,/,$cpu_max_filter,GT,UNKN,tot,ent,/,IF";
    $cmd .= " CDEF:utilperct=util,100,*";

    #do not use this filter, change results in filtering utilization cpu in graphs for dedicated lpars #HD, 27.4.2022
    $cmd .= " CDEF:utiltot=util,cur,*";

    #utilization divided by vcpu, utilization in percent<
    #$cmd .= " CDEF:utiltot2=utiltot,allocated,/";

    $cmd .= " CDEF:utiltot2=allocated,UN,utiltot,cur,/,utiltot,allocated,/,IF";
    $cmd .= " CDEF:utiltot2perc=utiltot2,100,*";

    #$cmd .= " CDEF:utiltot=util,cur,*,allocated,GT,UNKN,util,cur,*,IF";

    #testing
    #$cmd .= " DEF:allocated=\"$last_updated_rvm\":allocated_cores:AVERAGE";

  }

  #  if ($in_cores == 2 && $vmware) {
  #     $cmd .= " COMMENT:\"   Average                    cores    GHz (right axis)\\n\"";
  #  }
  if ($vmware) {
    $cmd .= " COMMENT:\"    GHz                     Avrg     Max\\n\"";
  }
  else {
    $cmd .= " COMMENT:\"Average [CPU cores]   \\n\"";
  }

=begin
  if ($vmware) {
    $cmd .= " LINE1:utiltot#FF0000:\" CPU usage    $cores_mhz   \"";
    $cmd .= " GPRINT:utiltotgp:AVERAGE:\" %$gprint_form\"";
    $cmd .= " GPRINT:utiltotgp:MAX:\" %$gprint_form\"";
    if ( $in_cores == 2 ) {
      $cmd .= " CDEF:utiltot_ghz=utiltot_mhz,1000,/";
      $cmd .= " GPRINT:utiltot_ghz:AVERAGE:\" %5.2lf\"";
    }
  }
  elsif ($hitachi) {
    $cmd .= " LINE1:cores#FF0000:\" Utilization\"";
    $cmd .= " GPRINT:cores:AVERAGE:\" %5.2lf\"";
  }
  else {
    $cmd .= " LINE1:utiltot#FF0000:\" Utilization             \"";
    $cmd .= " GPRINT:utiltot:AVERAGE:\" %5.2lf\"";
    $cmd .= " COMMENT:\"(\"";
    $cmd .= " GPRINT:utiltot2perc:AVERAGE:\" %3.1lf %%\"";
    $cmd .= " COMMENT:\")\"";
  }
  $cmd .= " $t2";
=cut

  if ( $entitle != 1 && !$hitachi ) {

    # default one, show entitlement area
    # else do not show entitled area --> customers request

    if ( !$vmware ) {
      $cmd .= " AREA:cur$pastel_green:\" Entitled                \"";
      $cmd .= " GPRINT:cur:AVERAGE:\" %5.2lf\"";
      $cmd .= " $t2";
      if ($vcpu_found) {    # add vCPU to lpar graph
        $cmd .= " LINE1:allocated#000000:\" Virtual                 \"";
        $cmd .= " GPRINT:allocated:AVERAGE:\" %5.2lf\"";
        $cmd .= " $t2";
      }
    }
    else {
      $cmd .= " AREA:cpu_entitl$pastel_green:\" Reserved CPU $cores_mhz   \"";
      $cmd .= " GPRINT:cpu_entitlgp:AVERAGE:\" %$gprint_form\"";
      $cmd .= " GPRINT:cpu_entitlgp:MAX:\" %$gprint_form\"";
      if ( $in_cores == 2 ) {
        $cmd .= " CDEF:cpu_entitl_ghz=cpu_entitl_mhz,1000,/";
        $cmd .= " GPRINT:cpu_entitl_ghz:AVERAGE:\" %5.2lf\"";
      }
      $cmd .= " $t2";
    }
  }
  if ($vmware) {
    $cmd .= " LINE1:utiltot#FF0000:\" CPU usage    $cores_mhz   \"";
    $cmd .= " GPRINT:utiltotgp:AVERAGE:\" %$gprint_form\"";
    $cmd .= " GPRINT:utiltotgp:MAX:\" %$gprint_form\"";
    if ( $in_cores == 2 ) {
      $cmd .= " CDEF:utiltot_ghz=utiltot_mhz,1000,/";
      $cmd .= " GPRINT:utiltot_ghz:AVERAGE:\" %5.2lf\"";
    }
  }
  elsif ($hitachi) {
    $cmd .= " LINE1:cores#FF0000:\" Utilization\"";
    $cmd .= " GPRINT:cores:AVERAGE:\" %5.2lf\"";
  }
  else {
    $cmd .= " LINE1:utiltot#FF0000:\" Utilization             \"";
    $cmd .= " GPRINT:utiltot:AVERAGE:\" %5.2lf\"";
    $cmd .= " COMMENT:\"(\"";
    $cmd .= " GPRINT:utiltot2perc:AVERAGE:\" %3.1lf %%\"";
    $cmd .= " COMMENT:\")\"";
  }
  $cmd .= " $t2";

  if ( $entitle != 1 && !$hitachi ) {

    # default one, show entitlement area
    # else do not show entitled area --> customers request

    if ( !$vmware ) {
    }
    else {
      #      $cmd .= " COMMENT:\"   CPU usage of Reserved   \"";
      #      $cmd .= " CDEF:cpu_entitl_proc=utiltot,cpu_entitl,/,100,*";
      $cmd .= " COMMENT:\"    vCPU in units      \"";
      $cmd .= " GPRINT:vcpu_num:AVERAGE:\" %4.0lf\"";
      $cmd .= " GPRINT:vcpu_num:MAX:\" %5.0lf\"";
      $cmd .= " $t2";
    }

  }

  #$cmd .= " $last";
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  #  "VRULE:0#000000"

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_lpar : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_vm_vmotion {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $upper       = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;             # 1 do not show entitle area
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT:\" \"";
  my $tl;                              # for clickable legend
  my $t2         = "COMMENT:\\n";
  my $step_new   = $step;
  my $last       = "COMMENT:\" \"";
  my $rigid      = "\n --rigid";
  my $act_time_u = time();
  my $req_time   = 0;

  # print STDERR "2610 sub graph_lpar_vm ,$host,$server,$lpar,$type,$item,$type_sam,$graph_hours,$vmware,$hyperv\n";

  #  my $in_cores = 1; # graph for vmware is in cores
  my $in_cores     = 0;    # graph for vmware is in MHz
                           #my $in_cores = 2;  # graph for vmware has right axis
  my $one_core_hz  = 1;
  my $one_core_mhz = 1;
  my $one_core_ghz = 1;

  if ( $upper eq '' || $upper =~ /entitle/ || $upper == 0 ) {
    $upper = 0.1;
  }
  $upper = 100 if $vmware;    # for usage in %

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lpar: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  my $all_vms = $all_vmware_VMs;
  $all_vms = $all_hyperv_VMs if $hyperv;

  my $rrd = "";
  $rrd = "$wrkdir/$all_vms/$lpar.rrm";
  $rrd = "$wrkdir/$server/$all_vms/$lpar.rrm" if $hyperv;

  # print STDERR "3047  detail-graph-cgi.pl \$host $host \$server $server \$lpar $lpar\n";

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  if ( $detail == 1 ) {
    $lpar = human_vmware_name( $lpar, "neg", $server );
  }

  my $lpar_slash = human_vmware_name( $lpar, "", $server );

  # if want to remove ( ... )
  $lpar_slash =~ s/\(.*\)//;

  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  my $lpar_slash_nmon_25 = $lpar_slash_nmon;

  # max 25 chars
  $lpar_slash_nmon_25 = substr( $lpar_slash_nmon_25, 0, 24 );
  #
  my $last_txt = "$lpar_slash_nmon:last ";
  my $head     = "VM";
  my $header   = "$head:Motion:$last_txt$text";

  #  my $last_txt = " last ";
  my $header_prefix = "VM:";
  if ( $detail == 2 ) {
    $last_txt      = "";
    $header_prefix = "Motion";
    $header        = "$header_prefix:$lpar_slash_nmon:$last_txt$text";
  }
  if ( !-d "$wrkdir/$server/$host" ) {

    # find host (= vcenter_name) cus $host contains cluster name from DSHB
    my @ppath = `ls $wrkdir/$server`;
    $host = "";
    foreach my $item (@ppath) {
      chomp $item;

      # print STDERR "2836 \$item ,$item, $wrkdir/$item\n";
      next if $item eq "";
      if ( -d "$wrkdir/$server/$item" ) {
        $host = $item;
        last;
      }
    }
    if ( $host eq "" ) {
      error( "no host: Graph vmotion error server $server hosts:@ppath: " . __FILE__ . ":" . __LINE__ );
      return;
    }

    # print STDERR "2848 \$host,$host,\$server,$server,\$lpar,$lpar,\n";
  }

  #  my $header = "$header_prefix $lpar_slash_nmon :$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      $xgrid      = "";             # just a trick

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
    }
  }

  # if (($type =~ "d" && $graph_hours == 0 ) || $vmware) { # always for vmware
  my $rrd_last = rrd_file_actual("$rrd");
  RRDp::cmd qq(last "$rrd_last");
  my $last_tt = RRDp::read;
  my $l       = localtime( time_from_last_tt($last_tt) );

  # following must be for RRD 1.2+
  if ( $type =~ "d" ) {
    $tl = "Updated:  $l";
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";
  }

  # get LAST value from RRD
  my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
  RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
  my $row = RRDp::read;
  chomp($$row);
  my @row_arr = split( /\n/, $$row );
  my $m       = "";
  my $i       = 0;

  foreach $m (@row_arr) {
    chomp($m);
    $i++;
    if ( $i == 3 ) {
      my @m_arr = split( / /, $m );

      #        if ($vmware) {
      # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
      if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ ) {

        #print "m : $m\n" if $DEBUG ;
        #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
        my $utiltot_mhz = 1;
        my $utiltot_ghz = 1;
        $utiltot_mhz = sprintf( "%e", $m_arr[2] );
        $utiltot_ghz = $utiltot_mhz / 1000;
        $one_core_hz = sprintf( "%e", $m_arr[3] );
        if ($in_cores) {
          my $util = sprintf( "%5.2f", $utiltot_mhz / $one_core_hz * 1000000 );
          if ( $type !~ "d" ) {next}
          $last = "COMMENT:\"Last CPU usage in cores      $util\"";
          if ( $in_cores == 2 ) {
            my $utlt_mhz = sprintf( "%5.0f", $utiltot_mhz );
            my $utlt_ghz = sprintf( "%5.2f", $utiltot_ghz );
            $last = "COMMENT:\"Last CPU usage                $util    $utlt_ghz\"";
          }
        }
        else {
          my $util = sprintf( "%5.0f", $utiltot_mhz );
          $last = "COMMENT:\"Last utilization in CPU MHz $util\"";
        }
      }

      #        }
    }
  }

  #   }
  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=\"CPU cores\"";

  # $vertical_label="--vertical-label=\"CPU usage in Hz\"" if $vmware && !$in_cores;
  $vertical_label = "--vertical-label=\"CPU usage in %\"" if $vmware && !$in_cores;
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # print STDERR "3204 creating graph : $host:$server:$lpar_slash:$lpar:$type_sam:$type:$name_out:$rrd:$entitle:$item\n" ;

  if ( $host eq "nope" ) {               # from historical report, just for now, you must think again situation in hist reports !
    my @menu;
    read_menu( \@menu );

    # print STDERR "2788 menu.txt @menu\n";
    my @matches = grep { /^L/ && /$lpar/ } @menu;

    # print STDERR "2790 @matches\n";
    ( undef, $host ) = split( "host=", $matches[0] );
    ( $host, undef ) = split( "&", $host );

    # print STDERR "2793 detail-graph-cgi.pl \$host $host\n";
  }
  $host =~ s/&/\\&/g;    # otherwise "grep" complaints
  my @path_lines = ();
  if ($vmware) {
    @path_lines = `grep -H "$lpar" "$wrkdir"/*/$host/VM_hosting.vmh`;    # attention: $host is vcenter
  }    # print STDERR "2796 detail-graph-cgi.pl \@path_lines @path_lines\n";
  elsif ($hyperv) {
    @path_lines = `grep -H "$lpar" "$wrkdir/$server"/*/VM_hosting.vmh`;
  }
  else {
    error( "$server $host $lpar : Graph error : vmotion but neither vmware not hyperv : exiting" . __FILE__ . ":" . __LINE__ );
    exit;
  }

  # print STDERR "3229 detail-graph-cgi.pl \@path_lines @path_lines\n";
  my %lines = ();    # keeping info: {server_name}[$inx]='start=1234567890:end=1234567890'
                     # typical data - always dual lines because esxi name | uuid, and possible end .. start .. end ..
                     # /home/lpar2rrd/dev/data/10.100.1.24/10.100.1.30/VM_hosting.vmh:502ab669-4c97-778a-7f5f-d9552e6733f3:start=1441406400
                     # /home/lpar2rrd/dev/data/0aef332e-09cf-11e3-8a09-5cf3fcdd4404/10.100.1.30/VM_hosting.vmh:502ab669-4c97-778a-7f5f-d9552e6733f3:start=1441406400
                     # /home/lpar2rrd/dev/data/0aef332e-09cf-11e3-8a09-5cf3fcdd4404/10.100.1.30:2430/VM_hosting.vmh:502ab669-4c97-778a-7f5f-d9552e6733f3:start=1441406400 # could be port
                     # in case hyperv
                     #                 /home/lpar2rrd/lpar2rrd/data/windows/domain_ad.xorux.com/HVNODE02/VM_hosting.vmh:8127B1FB-FFD6-4A9F-82BC-36CF9F18F03D:start=1532072416

  foreach my $line (@path_lines) {
    chomp($line);

    # print STDERR "3244, $line\n";
    ( my $server_path, my $time_part ) = split( "hosting.vmh:", $line );
    ( undef, $time_part ) = split( ":", $time_part, 2 );

    my $server_tmp = dirname($server_path);
    $server_tmp = dirname($server_tmp) if not $hyperv;
    my $server = basename($server_tmp);
    next if $server =~ m{.{8}-.{4}-.{4}-.{4}-.{12}};    # skip link uuid server line

    # print STDERR "3253, $line\n";
    if ( index( $time_part, "start=" ) == -1 ) {
      next;                                             #some tresh
    }
    my @st_end = split( "start=", $time_part );

    # print STDERR "2711 \@st_end @st_end\n";
    my $inx = 0;
    foreach my $st_line (@st_end) {

      # print STDERR "3220 \$st_line $st_line\n";
      $st_line =~ s/:$//;
      if ( $st_line eq "" ) {
        next;    # here the 1st atom (empty)
      }

      if ( index( $st_line, "end=" ) == -1 ) {    # only one start without end
                                                  # there can be more lines only with start eg. some non-standard operation with ESXi when manually transferred to other cluster or vCenter
                                                  # in any case: 'end' can not be newer than ESXi pool
        my $clean_server_path = $server_path;
        $clean_server_path =~ s/VM_//;
        my $last_mod_server_pool_time = ( stat("$clean_server_path/pool.rrm") )[9];

        # print STDERR "3275 $clean_server_path/pool.rrm\n";
        my $diff_end_time = 0;
        $diff_end_time = $last_mod_server_pool_time if ( $last_mod_server_pool_time < $end_time && $last_mod_server_pool_time > $st_line );
        if ( $diff_end_time > 0 ) {
          $lines{$server}[$inx] = "start=$st_line:end=$diff_end_time";
        }
        else {
          $lines{$server}[$inx] = "start=$st_line:end=$end_time";
        }
        $inx++;
        next;
      }
      $lines{$server}[$inx] = "start=$st_line";
      $inx++;
    }
  }

  # print STDERR Dumper(\%lines);

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $cmd = "";

  $cmd .= "$graph_cmd \"$name_out\"";
  if ( $in_cores == 2 && $vmware ) {

    #  $cmd .= " --right-axis-label \"CPU usage in MHz\"";
    $one_core_mhz = int( $one_core_hz / 1000000 );
    $one_core_ghz = $one_core_mhz / 1000;
    if ($yes_right_axis) {
      $cmd .= " --right-axis $one_core_ghz:0";
      $cmd .= " --right-axis-format %1.2lf";
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=$upper";
  $cmd .= " $vertical_label";

  #  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  my $color_index = -1;
  my $s           = 101;    #in case too many v-motions
  if ($vmware) {

    #    $cmd .= " DEF:utiltot_mhz=\"$wrkdir/$all_vms/$lpar.rrm\":CPU_usage:AVERAGE"; # only once

    #  @ds    = ("CPU_usage_Proc","vCPU","host_hz","CPU_usage")   if $item eq "vmw-proc";
    my $kbmb = 100;

    $cmd .= " DEF:ids0=\"$wrkdir/$all_vms/$lpar.rrm\":CPU_usage_Proc:AVERAGE";
    $cmd .= " DEF:ids1=\"$wrkdir/$all_vms/$lpar.rrm\":vCPU:AVERAGE";
    $cmd .= " DEF:ids2=\"$wrkdir/$all_vms/$lpar.rrm\":host_hz:AVERAGE";
    $cmd .= " DEF:ids3=\"$wrkdir/$all_vms/$lpar.rrm\":CPU_usage:AVERAGE";

    $cmd .= " CDEF:CPU_usage_Proc=ids0,$kbmb,/";    # orig
    $cmd .= " CDEF:pageout_b_nf=ids1,$kbmb,/";

    $cmd .= " CDEF:vCPU=ids1,1,/";                                                               # number
    $cmd .= " CDEF:host_MHz=ids2,1000,/,1000,/";                                                 # to be in MHz
    $cmd .= " CDEF:CPU_usage=ids3,1,/";                                                          # MHz
    $cmd .= " CDEF:CPU_usage_res=CPU_usage,host_MHz,/,vCPU,/,100,*";                             # usage proc counted
                                                                                                 #    $cmd .= " CDEF:pagein_b=CPU_usage_res,1,/"; # counted
                                                                                                 #    $cmd .= " CDEF:pagein_b=CPU_usage_Proc,1,/"; # orig from counter metric
    $cmd .= " CDEF:pagein_b_raw=CPU_usage_Proc,UN,CPU_usage_res,CPU_usage_Proc,IF";
    $cmd .= " CDEF:pagein_b=pagein_b_raw,UN,UNKN,pagein_b_raw,100,GT,100,pagein_b_raw,IF,IF";    # cut more than 100%, VMware does the same
    $cmd .= " CDEF:utiltot_mhz=pagein_b,1,*";
  }
  if ($hyperv) {
    $cmd .= " DEF:utiltot_perc=\"$wrkdir/$server/$all_vms/$lpar.rrm\":PercentTotalRunTime:AVERAGE";
    $cmd .= " DEF:utiltot_time=\"$wrkdir/$server/$all_vms/$lpar.rrm\":Timestamp_PerfTime:AVERAGE";
    $cmd .= " CDEF:utiltot_mhz=utiltot_perc,utiltot_time,/,1,/";
  }

  #  $cmd .= " COMMENT:\\\"  VM                        Server            Util[GHz] AVG      MAX \\l\\\"" if $detail == 1;
  $cmd .= " COMMENT:\\\"  VM                        Server            Util[%]   AVG      MAX \\l\\\"" if ( $detail == 1 || $detail == 7 ) && $vmware;
  $cmd .= " COMMENT:\\\"  VM                        Server                      AVG      MAX \\l\\\"" if $detail == 1                     && !$vmware;
  while ( my ( $key, $value ) = each %lines ) {    # for every server
                                                   # print STDERR "2805 detail-graph-cgi.pl key: $key, value: $lines{$key}[0]\n"; # $lines{$key}[1]\n";

    $color_index++;
    my $cmd_tmp = "";
    my ( $t_start, $t_end );
    my $inx = 0;
    my $i   = 1;
    my $k   = 0;

    while ( defined $lines{$key}[$inx] ) {         # for all times
      ( undef, $t_start, $t_end ) = split( "=", $lines{$key}[$inx] );
      $inx++;
      $t_end   = substr( $t_end,   0, 10 );
      $t_start = substr( $t_start, 0, 10 );
      $t_start = $t_start * 1;
      $t_end   = $t_end * 1;

      # print STDERR "\$start_time $start_time \$t_start $t_start \$end_time $end_time \$t_end $t_end\n";
      if ( $t_start < $start_time ) { $t_start = $start_time }
      if ( $t_end > $end_time )     { $t_end = $end_time }
      if ( $t_start >= $t_end )     {next}

      # print STDERR "graphing $t_start $t_end\n";
      $cmd_tmp .= " CDEF:utiltot_mhzt${i}${s}=TIME,$t_start,GE,TIME,$t_end,LE,+,2,EQ,utiltot_mhz,UNKN,IF";    #temp
      if ( $i == 1 ) {
        $cmd_tmp .= " CDEF:utiltot_mh${i}${s}=utiltot_mhzt${i}${s},1,*";
      }
      else {
        $cmd_tmp .= " CDEF:utiltot_mh${i}${s}=utiltot_mh${k}${s},UN,utiltot_mhzt${i}${s},utiltot_mh${k}${s},IF";
      }
      $i++;
      $k++;
    }
    if ( $t_end <= $start_time ) {    # out of start time of picture
      next;
    }
    if ( $cmd_tmp eq "" ) {           # nothing to graph
      next;
    }
    $cmd .= "$cmd_tmp";
    $i--;

    #    $cmd .= " CDEF:utiltot_ghz${i}${s}=utiltot_mh${i}${s},1000,/"; # GHz
    #    $cmd .= " CDEF:utiltot_hz${i}${s}=utiltot_mh${i}${s},1000000,*"; # Hz

    $cmd .= " CDEF:utiltot_ghz${i}${s}=utiltot_mh${i}${s},1,*";    # GHz
    $cmd .= " CDEF:utiltot_hz${i}${s}=utiltot_mh${i}${s},1,*";     # Hz

    my $lpar_space = $lpar_slash_nmon;

    # to keep same count of characters
    $lpar_space =~ s/\\:/:/g;
    $lpar_space = sprintf( "%-25s", $lpar_space );

    # max 25 chars
    $lpar_space = substr( $lpar_space, 0, 24 );
    my $lpar_space_colon = $lpar_space;
    $lpar_space_colon =~ s/:/\\:/g;
    #
    my $server_space = $key;

    # to keep same count of characters
    $server_space =~ s/\\:/:/g;
    $server_space = sprintf( "%-25s", $server_space );
    $server_space = substr( $server_space, 0, 24 );
    my $server_space_colon = $server_space;
    $server_space_colon =~ s/:/\\:/g;
    my $lpar_server_legend = "$lpar_space  $server_space";
    $lpar_server_legend =~ s/:/\\:/g;
    $lpar_server_legend =~ s/%/%%/g;    # anti '%']
    my $host_colon = $host;
    $host_colon =~ s/:/\\:/g;

    if ( $detail == 1 || $detail == 7 ) {
      $cmd .= " LINE2:utiltot_hz${i}${s}$color[$color_index]:\"$lpar_server_legend\"";
    }
    else {
      $cmd .= " LINE2:utiltot_hz${i}${s}$color[$color_index]:";
    }
    if ($vmware) {
      $cmd .= " GPRINT:utiltot_ghz${i}${s}:AVERAGE:\"%5.2lf \"" if $detail == 1 || $detail == 7;
      $cmd .= " GPRINT:utiltot_ghz${i}${s}:MAX:\" %5.2lf \""    if $detail == 1 || $detail == 7;

      $cmd .= " PRINT:utiltot_ghz${i}${s}:AVERAGE:\"%3.2lf $delimiter $item $delimiter $server_space_colon $delimiter $lpar_space_colon\"";
      $cmd .= " PRINT:utiltot_ghz${i}${s}:MAX:\\\"%3.2lf $delimiter $color[$color_index] $delimiter $host_colon $delimiter $key\\\"";
    }
    if ($hyperv) {
      $cmd .= " GPRINT:utiltot_hz${i}${s}:AVERAGE:\"%5.2lf \"" if $detail == 1 || $detail == 7;
      $cmd .= " GPRINT:utiltot_hz${i}${s}:MAX:\" %5.2lf \""    if $detail == 1 || $detail == 7;

      $cmd .= " PRINT:utiltot_hz${i}${s}:AVERAGE:\"%3.2lf $delimiter $item $delimiter $server_space_colon $delimiter $lpar_space_colon\"";
      $cmd .= " PRINT:utiltot_hz${i}${s}:MAX:\\\"%3.2lf $delimiter $color[$color_index] $delimiter $host_colon $delimiter $key\\\"";
    }

    $cmd .= " $t2";
    $s++;
  }

  # $cmd .= " $last";
  $cmd .= " $t2";
  $cmd .= " $t" if $detail == 1 || $detail == 7;
  $cmd .= " HRULE:0#000000";

  #  "VRULE:0#000000"

  $cmd =~ s/\\"/"/g;

  # print STDERR "2766 detail-graph-cgi.pl \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_lpar : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $tl );
  return 0;
}

sub graph_trend {
  my $host     = shift;
  my $server   = shift;
  my $lpar     = shift;
  my $type     = shift;
  my $name_out = shift;
  my $type_sam = shift;
  my $upper    = shift;
  my $detail   = shift;
  my $t        = "COMMENT: ";
  my $t2       = "COMMENT:\\n";
  my $step_new = $step;
  my $xgrid    = "--x-grid=MONTH:1:MONTH:1:MONTH:1:0:%b";

  if ( $upper eq '' || $upper == 0 ) {
    $upper = 0.1;
  }

  if ( -f "$wrkdir/$server/$host/vmware.txt" ) {return}

  #ACL Check
  if ( $xormon && $power ) {
    my $lpar_uid = PowerDataWrapper::get_item_uid( { type => "VM", label => $lpar } );
    my $aclitem  = { hw_type => 'POWER', item_id => $lpar_uid, match => 'granted' };
    if ( !$acl->isGranted($aclitem) ) {
      $aclitem->{label} = $host;
      my $str = join( ", ", map {"$_=>$aclitem->{$_}"} keys %{$aclitem} );
      error( "ACL: object not allowed for user " . ACL::getUser() . ": $str " . __FILE__ . ":" . __LINE__ );
      return 1;
    }
  }

  my $rrd     = "$wrkdir/$server/$host/$lpar.rr$type_sam";
  my $rrd_lpm = "$wrkdir/$server/*/$lpar.rr$type_sam";

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacemnt for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "LPAR: $lpar_slash_nmon :$last_txt year";

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my $vertical_label = "--vertical-label=\"CPU cores\"";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  # Trend for yearly chart 1y back  + 1y forward
  #print "creating graph : $host:$server:$lpar:$type_sam:$type:trend\n" if $DEBUG ;
  #error ( "creating graph : $host:$server:$lpar:$type_sam:$type:trend");

  $rrd     =~ s/:/\\:/g;
  $rrd_lpm =~ s/:/\\:/g;
  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  if ( $detail == 10 ) {
    $header = "$server : LPAR: $lpar_slash_nmon :$last_txt year";
  }

  my $cmd .= "$graph_cmd \"$name_out\"";
  $cmd    .= " --title \"$header - trend\"";
  $cmd    .= " --start now-1$type";
  $cmd    .= " --end now+1$type";
  $cmd    .= " --imgformat PNG";
  $cmd    .= " --slope-mode";
  $cmd    .= " $no_minor";
  $cmd    .= " --width=$width_trend";
  $cmd    .= " --height=$height";
  $cmd    .= " --step=$step";
  $cmd    .= " --lower-limit=0.00";
  $cmd    .= " --color=BACK#$pic_col";
  $cmd    .= " --color=SHADEA#$pic_col";
  $cmd    .= " --color=SHADEB#$pic_col";
  $cmd    .= " --color=CANVAS#$pic_col";
  $cmd    .= " --alt-autoscale-max";
  $cmd    .= " --upper-limit=0.1";
  $cmd    .= " $vertical_label";
  $cmd    .= " --units-exponent=1.00";
  $cmd    .= " --alt-y-grid";
  $cmd    .= " $no_legend";
  $cmd    .= " $disable_rrdtool_tag";
  $cmd    .= " $font_def";
  $cmd    .= " $font_tit";
  $cmd    .= " $xgrid";

  # -PH
  # there is no real LPM support like for OS agent data, I have tried that but it is quite complicated as LPM_easy_trend() must be use as well
  # OS agnet data do not need to use LPM_easy_trend()
  # I have implemented return of all files in lpm_find_files(), must be used "lpar.rrm", but it does not cover LPM_easy_trend() (data from different HMCs)
  # print STDERR "001 $wrkdir, $server, $host, $lpar, $lpar_slash, $lpm_suff, $type_sam, $type, $lpar.rr$type_sam, $cgi \n";
  # lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "lpar.rrm", \@rrd_files, $cgi );

  # to use data from all HMCs (not real LPM, LPM is between servers what this does not do
  my ( $result_cmd, $CPU_cur_d, $CPU_ent_d, $CPU_cap_d, $CPU_uncap_d, $CPU_cur_m, $CPU_ent_m, $CPU_cap_m, $CPU_uncap_m, $CPU_cur_y, $CPU_ent_y, $CPU_cap_y, $CPU_uncap_y, $CPU_cur, $CPU_ent, $CPU_cap, $CPU_uncap ) = LPM_easy_trend( "$rrd_lpm", "curr_proc_units", "entitled_cycles", "capped_cycles", "uncapped_cycles" );

  $cmd .= $result_cmd;
  $cmd .= " CDEF:curd=$CPU_cur_d";
  $cmd .= " CDEF:curm=$CPU_cur_m";
  $cmd .= " CDEF:cury=$CPU_cur_y";
  $cmd .= " CDEF:cur=$CPU_cur";

  $cmd .= " CDEF:entd=$CPU_ent_d";
  $cmd .= " CDEF:entm=$CPU_ent_m";
  $cmd .= " CDEF:enty=$CPU_ent_y";
  $cmd .= " CDEF:ent=$CPU_ent";

  $cmd .= " CDEF:capd_peak=$CPU_cap_d";
  $cmd .= " CDEF:capm_peak=$CPU_cap_m";
  $cmd .= " CDEF:capy_peak=$CPU_cap_y";
  $cmd .= " CDEF:cap_peak=$CPU_cap";

  # filtering peaks caused by LPM or changing entitled, if cap CPU util is > entitled --> UNKN
  # usualy cap counter is affected only
  # sometimes might happen that even in normal load capped util is little higher than entitled! Therefore using 1.2
  $cmd .= " CDEF:capd=capd_peak,ent,/,1.2,GT,UNKN,capd_peak,IF";
  $cmd .= " CDEF:capm=capm_peak,ent,/,1.2,GT,UNKN,capm_peak,IF";
  $cmd .= " CDEF:capy=capy_peak,ent,/,1.2,GT,UNKN,capy_peak,IF";
  $cmd .= " CDEF:cap=cap_peak,ent,/,1.2,GT,UNKN,cap_peak,IF";

  $cmd .= " CDEF:uncapd=$CPU_uncap_d";
  $cmd .= " CDEF:uncapm=$CPU_uncap_m";
  $cmd .= " CDEF:uncapy=$CPU_uncap_y";
  $cmd .= " CDEF:uncap=$CPU_uncap";

  $cmd .= " CDEF:totd=capd,uncapd,+";
  $cmd .= " CDEF:totm=capm,uncapm,+";
  $cmd .= " CDEF:toty=capy,uncapy,+";
  $cmd .= " CDEF:tot=cap,uncap,+";
  $cmd .= " CDEF:utild=totd,entd,/,$cpu_max_filter,GT,UNKN,totd,entd,/,IF";
  $cmd .= " CDEF:utilm=totm,entm,/,$cpu_max_filter,GT,UNKN,totm,entm,/,IF";
  $cmd .= " CDEF:utily=toty,enty,/,$cpu_max_filter,GT,UNKN,toty,enty,/,IF";
  $cmd .= " CDEF:util=tot,ent,/,$cpu_max_filter,GT,UNKN,tot,ent,/,IF";
  $cmd .= " CDEF:utilperct=util,100,*";
  $cmd .= " CDEF:utiltotd=utild,curd,*";
  $cmd .= " CDEF:utiltotm=utilm,curm,*";
  $cmd .= " CDEF:utiltoty=utily,cury,*";
  $cmd .= " CDEF:utiltot=util,cur,*";
  $cmd .= " VDEF:Dd=utiltotd,LSLSLOPE";
  $cmd .= " VDEF:Hd=utiltotd,LSLINT";
  $cmd .= " CDEF:utiltottrendd=utiltotd,POP,Dd,COUNT,*,Hd,+";
  $cmd .= " VDEF:Dm=utiltotm,LSLSLOPE";
  $cmd .= " VDEF:Hm=utiltotm,LSLINT";
  $cmd .= " CDEF:utiltottrendm=utiltotm,POP,Dm,COUNT,*,Hm,+";
  $cmd .= " VDEF:Dy=utiltoty,LSLSLOPE";
  $cmd .= " VDEF:Hy=utiltoty,LSLINT";
  $cmd .= " CDEF:utiltottrendy=utiltoty,POP,Dy,COUNT,*,Hy,+";
  $cmd .= " COMMENT:\"   Average   \\n\"";
  $cmd .= " AREA:cur$pastel_green:\" Entitled processor cores \"";
  $cmd .= " GPRINT:cur:AVERAGE:\" %4.2lf\"";
  $cmd .= " $t2";
  $cmd .= " LINE1:utiltot#FF0000:\" Utilization in CPU cores\"";
  $cmd .= " GPRINT:utiltot:AVERAGE:\" %5.2lf\"";
  $cmd .= " $t2";
  $cmd .= " COMMENT:\"Entitled CPU utilization   \"";
  $cmd .= " GPRINT:utilperct:AVERAGE:\" %4.2lf\"";
  $cmd .= " COMMENT:\"\%\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:utiltottrendd#0088FF:\" Utilization in CPU cores - last 1 month trend\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:utiltottrendm#80FFFF:\" Utilization in CPU cores - last 3 months trend\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:utiltottrendy#FF8080:\" Utilization in CPU cores - last year trend\"";
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;

}

sub graph_ams {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $upper       = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;             # 1 do not show entitle area
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT:\" \"";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT:\" \"";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_ams: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
    }
  }

  my $rrd = "$wrkdir/$server/$host/$lpar.rm$type_sam";

  # print "001 AMS $rrd\n";

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacemnt for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "Memory: $lpar_slash_nmon :$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "Memory: $lpar_slash_nmon : $start_human - $end_human";
    }
  }

  if ( $type =~ "d" ) {
    my $rrd_last = rrd_file_actual("$rrd");
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further ony if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;

          #my $curr_mem = sprintf("%e",$m_arr[1]);
          #my $phys_run_mem    = sprintf("%e",$m_arr[2]);
          if ( $m_arr[2] > 0 ) {
            my $last_mem   = sprintf( "%6.2d", $m_arr[2] ) / 1024;
            my $last_mem_g = sprintf( "%.2f",  $m_arr[2] / 1024 );
            $last = "COMMENT:\"Last memory consuption in GB         $last_mem_g\"";
          }
        }
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $vertical_label = "--vertical-label=\"Memory in GB\"";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # `echo "809: detail-graph-cgi AMS-lpar : $host:$server:$lpar_slash:$type_sam:$type:$start_unix:$end_unix" >> /tmp/xAMS-lpar`;
  #print "graphing AMS   : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;

  my $cmd = "";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  # for LPM
  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first

  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "ams", \@rrd_files, $cgi );

  #print STDERR "lpm_find_files is returning @rrd_files\n";

  my $i = -1;
  my $j;

  foreach $rrd (@rrd_files) {    # LPM cycle
    chomp($rrd);
    $i++;
    $j = $i - 1;
    $rrd =~ s/:/\\:/g;

    $cmd .= " DEF:cur${i}=\"$rrd\":phys_run_mem:AVERAGE";
    $cmd .= " DEF:ent${i}=\"$rrd\":curr_mem:AVERAGE";
    $cmd .= " DEF:io${i}=\"$rrd\":io_ent:AVERAGE";

    if ( $i == 0 ) {
      $cmd .= " CDEF:curr${i}=cur${i}";
      $cmd .= " CDEF:entr${i}=ent${i}";
      $cmd .= " CDEF:ior${i}=io${i}";
      next;
    }
    $cmd .= " CDEF:curr${i}=curr${j},UN,cur${i},curr${j},IF";
    $cmd .= " CDEF:entr${i}=entr${j},UN,ent${i},entr${j},IF";
    $cmd .= " CDEF:ior${i}=ior${j},UN,io${i},ior${j},IF";
  }
  $cmd .= " CDEF:cur=curr${i}";
  $cmd .= " CDEF:ent=entr${i}";
  $cmd .= " CDEF:io=ior${i}";

  $cmd .= " CDEF:entg=ent,1024,/";
  $cmd .= " CDEF:curg=cur,1024,/";
  $cmd .= " CDEF:iog=io,1024,/";
  $cmd .= " COMMENT:\"   Average   \\n\"";
  $cmd .= " AREA:entg#00FF00:\" Current allocated memory    \"";
  $cmd .= " GPRINT:entg:AVERAGE:\" %6.2lf\"";
  $cmd .= " $t2";
  $cmd .= " LINE1:iog#0080FF:\" Current allocated IO memory \"";
  $cmd .= " GPRINT:iog:AVERAGE:\" %6.2lf\"";
  $cmd .= " $t2";
  $cmd .= " LINE1:curg#FF0000:\" Actuall physical consumption\"";
  $cmd .= " GPRINT:curg:AVERAGE:\" %6.2lf\"";
  $cmd .= " $t2";
  $cmd .= " $last";
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  #  "VRULE:0#000000"

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_ams : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_ent_sum {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $item       = shift;    # "slan" or "ssan1" or "ssan2" or "ssea"
  my $start_unix = shift;
  my $end_unix   = shift;

  my $t          = "COMMENT: ";
  my $t2         = "COMMENT:\\n";
  my $step_new   = $step;
  my $last       = "COMMENT: ";
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains
    }
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_ent_sum : $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }
  my $dir = "";
  if ( $item eq "solaris_ldom_sum" ) {
    $dir = "$wrkdir/Solaris/$lpar/";
  }
  else {
    $dir = "$wrkdir/$server/$host/$lpar/";
  }

  my $iops = "IOPS";
  opendir( my $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ );
  my @files_iops = grep { /^san-host/ && /\.mmm$/ } readdir($dh) if $item ne "solaris_ldom_sum";
  closedir $dh;
  if ( @files_iops > 0 ) {

    # Linux standalones provide only SAN frames
    $iops = "Frames";
  }

  #print STDERR"@files_sum\n";
  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  my $san2nmon  = ( $item =~ /^ssan2/ && index( $lpar, "--NMON--" ) ne -1 );
  my $minus_one = -1;

  my $fpn                  = "lan";              # according to $item
  my $gpr_ave              = "8.1lf";
  my $gpr_max              = "8.1lf";
  my $divider              = 1073741824;
  my $last_txt             = " last ";
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $header_prefix = "Eth:";
  if ( $detail == 1 ) {
    $header_prefix = "SUM Eth:";
  }
  if ( $detail == 2 ) {
    $last_txt             = "";
    $lpar_slash_nmon_head = "" if $server eq "Linux";
    $header_prefix        = "ETH SUM";
    if ( $wpar == 1 ) {
      $header_prefix = "ETH SUM";
    }
  }
  my $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

  my $twrite   = "WRITE    ";
  my $tread    = "READ     ";
  my $ds_name1 = "recv_bytes";
  my $ds_name2 = "trans_bytes";
  if ( $item eq "slan" ) {
    $ds_name2 = "recv_bytes";
    $ds_name1 = "trans_bytes";
    $twrite   = "WRITE";
    $tread    = "READ ";
  }
  if ( $item eq "solaris_ldom_sum" ) {
    $ds_name2 = "rbytes";
    $ds_name1 = "obytes";
    $twrite   = "WRITE";
    $tread    = "READ  ";
  }
  my $headline1      = "COMMENT:[ GB ]           Max";
  my $headline2      = "COMMENT:Interface     READ (Max)          WRITE (Max)";
  my $vertical_label = "--vertical-label=Read - Bytes - Write";

  my $filter = $filter_max_lansan;

  if ( $item eq "ssan1" ) {

    # $fpn = "san-fcs" ;
    $fpn    = "san-";
    $header = "FCS: $lpar_slash_nmon :$last_txt$text";
    if ( $detail == 1 ) {
      $header = "SUM FCS: $lpar_slash_nmon :$last_txt$text";
    }
  }

  if ( $item eq "ssea" ) {

    # $fpn = "sea-ent" ;
    $fpn = "sea-";
    my $header_prefix = "SEA:";
    if ( $detail == 1 ) {
      $header_prefix = "SUM SEA:";
    }
    my $lpar_slash_nmon_head = $lpar_slash_nmon;
    if ( $detail == 2 ) {
      $last_txt             = "";
      $lpar_slash_nmon_head = "" if $server eq "Linux";
      $header_prefix        = "SEA";
      if ( $wpar == 1 ) {
        $header_prefix = "SEA:";
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

    $ds_name2 = "recv_bytes";
    $ds_name1 = "trans_bytes";
    $twrite   = "WRITE";
    $tread    = "READ ";
  }

  if ( $item eq "ssan2" ) {
    $gpr_ave = "8.0lf";
    $gpr_max = "8.0lf";
    $divider = 1;

    # $fpn = "san-fcs" ;
    $fpn = "san-";
    my $header_prefix = "$iops:";
    if ( $detail == 1 ) {
      $header_prefix = "SUM $iops:";
    }
    my $lpar_slash_nmon_head = $lpar_slash_nmon;
    if ( $detail == 2 ) {
      $last_txt             = "";
      $lpar_slash_nmon_head = "" if $server eq "Linux";
      $header_prefix        = "$iops:";
      if ( $wpar == 1 ) {
        $header_prefix = "$iops:";
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

    if ( $iops =~ m/Frames/ ) {

      # Linux san-8host* have swapped in/out frames, fixed in 5.07-4
      $ds_name1 = "iops_out";
      $ds_name2 = "iops_in";
    }
    else {
      $ds_name1 = "iops_in";
      $ds_name2 = "iops_out";
    }

    $headline1      = "COMMENT:[ $iops/day ]        Max";
    $headline2      = "COMMENT:Interface     READ (Max)          WRITE (Max)";
    $vertical_label = "--vertical-label=$iops requests";
    if ($san2nmon) {
      $minus_one = 1;
      $tread     = "TOTAL    ";
    }
  }

  if ( $item =~ m/san2/ ) {
    $filter = $filter_max_iops;
  }

  if ( $type =~ m/y/ ) {

    # lower limits for yearly graphs as they are averaged ....
    $filter = $filter / 10;
  }
  if ( $type =~ m/m/ ) {

    # lower limits for monthly graphs as they are averaged ....
    $filter = $filter / 2;
  }

  my @files;
  opendir( $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @files_unsorted = grep { /^$fpn/ && /\.mmm$/ } readdir($dh);
  rewinddir($dh);
  my @files_sum = grep !/^\.\.?$|ZONE|_ldom\.mmm$|uuid|solaris11|solaris10|^san|ldom|\.txt$|pool/, readdir($dh) if $item eq "solaris_ldom_sum";
  if ( $item ne "solaris_ldom_sum" ) {
    @files = sort @files_unsorted;
  }
  else {
    @files = sort @files_sum;
  }
  closedir $dh;
  my @rev = reverse(@files);    #for case study purpose
                                # print STDERR "0001 ENT SUM \$fpn $fpn \@files @files\n";

  my $col_indx   = 0;
  my $line_indx  = 0;             # place enter every 3rd line
  my $file       = "";
  my $cmd        = "";
  my $j          = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $req_time   = 0;
  my ( @recb, @trab, @rname, @rpath, @avgx );
  my $days = 32;

  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
    $days     = 365;
  }

  #if ( $type =~ "y" ) {
  #   $step_new=86400;
  #}

  #print "graphing ENT_SUM   : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      $xgrid      = "COMMENT: ";    # just a trick

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
    }
  }

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # print STDERR "3744 \$detail $detail \$start_time $start_time \$end_time $end_time \$header $header\n";

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  #  $cmd .= 'RRDp::cmd qq(graph "$name_out"
  $cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"
        "--title" "$header"
        "--start" "$start_time"
        "--end" "$end_time"
        "--imgformat" "PNG"
        "--slope-mode"
        "--width=$width"
        "--height=$height"
        "--step=86400"
        "--color=BACK#$pic_col"
        "--color=SHADEA#$pic_col"
        "--color=SHADEB#$pic_col"
        "--color=CANVAS#$pic_col"
        "--alt-autoscale-max"
        "$vertical_label"
        "--alt-y-grid"
        "$xgrid"
        "$no_legend"
        "$disable_rrdtool_tag"
        "--base=1024"
        "$font_def"
        "$font_tit"
        "$headline1"
        "$t2"
     ';

  # sum the databases
  # take care: if all dtbs are old means nothing to graph
  #            either only one dtb or more dtbs

  my $i             = 0;
  my $summ_r        = "";
  my $summ_w        = "";
  my $count_avg_day = "";

  # variables for LPM use
  my $k = 0;    # indexes for LPM cycle
  my $l = 0;
  my ( @rb, @rbr, @tb, @tbr );
  my @rrd_files_names;
  my $ifn = -1;    # index for this array

  foreach $file (@files) {

    #   foreach $file (@rev)
    chomp($file);
    my $rrd = "";
    if ( $item ne "solaris_ldom_sum" ) {
      $rrd = "$wrkdir/$server/$host/$lpar/$file";
    }
    else {
      $rrd = "$wrkdir/Solaris/$lpar/$file";
    }

    # avoid old files which do not exist in the period
    my $rrd_upd_time = ( stat("$rrd") )[9];
    if ( $rrd_upd_time < $req_time ) {
      next;
    }
    $count_avg_day = 1;    #since we do not print AVERAGE any more

    #    if ($i == 0) {   # prepare better AVG
    #      $count_avg_day = rrd_running_days($rrd,$days);
    #      if ( ! ($count_avg_day eq ($count_avg_day+0))) {
    #         error ("error in rrd_running : $count_avg_day ");
    #         $count_avg_day = 1;
    #      }
    #      else {
    #         if ( "$type" =~ "m" ) {
    #            $count_avg_day = 32 / $count_avg_day ;
    #         }
    #         else {
    #            $count_avg_day = 365 / $count_avg_day ;
    #         }
    #      }
    #    }
    my $rrd_name = $file;
    $rrd_name =~ s/.mmm//;
    $rrd_name =~ s/lan-//;
    $rrd_name =~ s/san-//;
    $rrd_name =~ s/sea-//;
    $rrd_name = sprintf( "%-8s", $rrd_name );    #add spaces, 8 chars tot - format graph legend

    # print STDERR "graph_ent_sum $wrkdir/$server/$host/$lpar/$file
    #  $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3);

    # print STDERR "001 ENT SUM $rrd\n";

    my $rrd_orig_colon = $rrd;
    $rrd =~ s/:/\\:/g;    #anti ':'

    $rname[$i] = "$rrd_name";    # for graphing
    $rpath[$i] = "$rrd";
    $recb[$i]  = "rcb${i}";
    $trab[$i]  = "trb${i}";
    $avgx[$i]  = "avg${i}";

    # start of LPM fun

    # for LPM
    $l = $k;
    my @rrd_files;
    my $lpm_suff = "rrl";
    my $cgi      = 0;
    $rrd_files[0] = $rrd_orig_colon;    #actual is the first

    lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, $file, \@rrd_files, $cgi );

    # print STDERR "graph_ent_sum lpm_find_files is returning @rrd_files\n";

    foreach $rrd (@rrd_files) {         # LPM cycle
      chomp($rrd);
      $rrd =~ s/:/\\:/g;
      $ifn++;
      $rrd_files_names[$ifn] = "$rrd";
      $rb[$k]                = "data1_stream${k}";
      $rbr[$k]               = "data1_stream_lpm${k}";
      $tb[$k]                = "data2_stream${k}";
      $tbr[$k]               = "data2_stream_lpm${k}";

      $cmd .= '"DEF:$rb[$k]=$rrd_files_names[$ifn]:$ds_name1:AVERAGE"
             "DEF:$tb[$k]=$rrd_files_names[$ifn++]:$ds_name2:AVERAGE"
            ';
      if ( $k == $l ) {
        $cmd .= '"CDEF:$rbr[$k]=$rb[$k]"
             "CDEF:$tbr[$k]=$tb[$k++]"
             ';
        $k++;
        next;
      }
      $cmd .= '"CDEF:$rbr[$k]=$rbr[$l],UN,$rb[$k],$rbr[$l],IF"
             "CDEF:$tbr[$k]=$tbr[$l],UN,$tb[$k++],$tbr[$l++],IF"
            ';
      $l++;
      $k++;
    }
    $cmd .= '"CDEF:$recb[$i]_nf=$rbr[$l]"
           "CDEF:$trab[$i]_nf=$tbr[$l++]"
          ';

    # end of LPM fun

    # print STDERR "3923: detail-graph-cgi - $rrd_name:$rrd:rcb${i}:$recb[$i]:$font_def:$font_tit:@files\n";

    #$cmd .= '"DEF:$recb[$i]_nf=$rpath[$i]:$ds_name1:AVERAGE"
    #         "DEF:$trab[$i]_nf=$rpath[$i]:$ds_name2:AVERAGE"

    $cmd .= '"CDEF:$recb[$i]=$recb[$i]_nf,$filter,GT,0,$recb[$i]_nf,IF"
          "CDEF:$recb[$i]_n=$recb[$i],UN,0,$recb[$i],IF"
          "CDEF:$trab[$i]=$trab[$i]_nf,$filter,GT,0,$trab[$i]_nf,IF"
          "CDEF:$trab[$i]_n=$trab[$i],UN,0,$trab[$i++],IF"

          ';
    if ( $i == 0 ) {
      $summ_r = $recb[$i] . "_n";
      $summ_w = $trab[$i] . "_n";
    }
    else {
      $summ_r .= "," . $recb[$i] . "_n,+";
      $summ_w .= "," . $trab[$i] . "_n,+";
    }
    $i++;
  }    # end of foreach

  if ( $i == 0 ) {
    error( "$host:$server:$lpar_slash Graph rrdtool error : no active dbs ETH,FCS,SEA  " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  #  "GPRINT:trans_smb_n:AVERAGE: %$gpr_ave"
  #   "GPRINT:recv_smb_n:AVERAGE: %$gpr_ave"

  $cmd .= '"CDEF:recv=$summ_r"
           "CDEF:trans=$summ_w"
           "CDEF:recv_s=recv,86400,*"
           "CDEF:recv_smb=recv_s,$divider,/"
           "CDEF:recv_smb_n=recv_smb,$count_avg_day,*"
           "CDEF:trans_s=trans,86400,*"
           "CDEF:trans_smb=trans_s,$divider,/"
           "CDEF:trans_smb_n=trans_smb,$count_avg_day,*"
           "CDEF:recv_neg=recv_s,$minus_one,*"
  ';
  if ( !$san2nmon ) {
    $cmd .= '"AREA:trans_s#FFFF00:$twrite "
       "GPRINT:trans_smb:MAX: %$gpr_max"
       "$t2"
  ';
  }
  $cmd .= '"AREA:recv_neg#00FF00:$tread "
             "GPRINT:recv_smb:MAX: %$gpr_max"
             "$t2"
             "$t"
             "HRULE:0#000000"
    );';

  #       "VRULE:0#000000"    # --> it is causing sigsegv on linuxeS

  #"CDEF:recv=recv_nf,$filter,GT,UNKN,recv_nf,IF"
  #"CDEF:trans=trans_nf,$filter,GT,UNKN,trans_nf,IF"

  #if you want to see what is generated
  # print STDERR "5395 \$cmd $cmd\n";

  # if you want to see interpolated $cmd
  # care what file name is in sub alfa
  #   $i = 0;
  #   $k   = 0;
  #   $l   = 0;
  #   $ifn = 0;
  # print STDERR "5399 \$graph_cmd $graph_cmd\n";
  #  my $t_cmd = $cmd;
  #  $t_cmd =~ s/RRDp::cmd qq\(\$graph_cmd /alfa\(/;
  #  $t_cmd =~ s/\s\"/\n\.\"/g;
  #  eval($t_cmd);
  # return;
  $i   = 0;
  $k   = 0;
  $l   = 0;
  $ifn = 0;

  eval $cmd;

  if ($@) {
    error( "Graph error in eval cmd : !$@! " . __FILE__ . ":" . __LINE__ );
  }
  else {
    my $answ = RRDp::read;
    if ( $$answ =~ "ERROR" ) {
      error( "$host:$server Graph rrdtool error : $$answ : " . __FILE__ . ":" . __LINE__ );
    }
    $png_end_heading = ret_graph_param( $answ, $t, $iops );
  }
  return 0;

}

sub graph_ent {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $item        = shift;                 #lan or pg2 or san1 or san2 or sea, !?!?!?!?! if contains "a" then AREA STACK
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $step_new    = $step;
  my $t           = "";
  my $t2          = "COMMENT:\\n";
  my $last        = "COMMENT: ";
  my $upper_limit = 0.1;
  my $start_time  = "now-1$type";
  my $end_time    = "now-1$type+1$type";
  my $vertical_label;

  # print STDERR "10179 \$host $host \$server $server \$lpar $lpar \$item $item \$type_sam $type_sam \$start_unix $start_unix \$end_unix $end_unix\n";
  my $xgrid              = xgrid_set( $type, $detail );
  my $text               = text_set($type);
  my $human_ds_name      = "";
  my $human_cluster_name = "";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains
      }
      if ( $item eq 'ds-vmiops' ) {
        $human_ds_name = find_human_ds_name( $server, $host, $lpar );

        # print STDERR "4362 \$human_ds_name $human_ds_name\n";
      }
    }
  }
  if ( $item eq 'ds-vmiops' && $detail == 1 ) {
    $human_ds_name = find_human_ds_name( $server, $host, $lpar );
  }

  my $Int = "Int";
  $Int = "   " if ( $item eq "data_as" || $item eq "iops_as" || $item eq "data_ifcb" || $item eq "paket_ifcb" || $item eq "dpaket_ifcb" || $item eq "packets_lan" || $item eq "packets_sea" || $item eq "solaris_ldom_pack" || $item eq "hdt_latency" );

  my $headline2 = "COMMENT:$Int      READ     Avg      Max      WRITE     Avg      Max";
  $headline2 = "COMMENT:Int     READ   Avg      Max    WRITE   Avg      Max"                  if ( $item =~ "^lan" );
  $headline2 = "COMMENT:Datastore                  READ   Avg     Max    WRITE    Avg    Max" if ( $item eq "vmw-iops" );
  $headline2 = "COMMENT:VM                         READ   Avg     Max    WRITE    Avg    Max" if ( $item eq "ds-vmiops" );
  $headline2 = "COMMENT:Int     READ/IN   Avg      Max    WRITE/OUT   Avg      Max"           if ( $item eq "solaris_ldom_net" );
  $headline2 = "COMMENT:Int     READ/IN   Avg      Max    WRITE/OUT   Avg      Max"           if ( $item eq "ssolaris_ldom_vnet" );
  $headline2 = "COMMENT:Int     READ/WRITE   Avg      Max"                                    if ( $item eq "solaris_ldom_san_resp" );
  $headline2 = "COMMENT:server  READ   Avg      Max    WRITE   Avg      Max"                  if ( $item eq "clustlan" );
  $headline2 = "COMMENT:Volume  READ        Avg      Max    WRITE      Avg      Max"          if ( $item =~ "s2d_volume_agr_" );

  #if ( $detail == 1 ) {
  #  if ($item =~ "^lan") {
  #     $headline2 = "COMMENT:Int     READ   Avg      Max    WRITE   Avg      Max        Int      READ   Avg      Max     WRITE   Avg      Max";
  #  }
  #  else {
  #     $headline2 = "COMMENT:$Int      READ     Avg      Max      WRITE     Avg      Max        $Int       READ     Avg      Max       WRITE     Avg      Max";
  #  }
  #}

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_ent: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;                # some workaround, it should not go here
  }
  my @files;

  my $dir = "$wrkdir/$server/$host/$lpar/";
  if ( $item eq "hyppg2" ) {
    $dir = "$wrkdir/$server/$host/";
  }
  elsif ( $item eq "hdt_latency" ) {
    $dir = "$wrkdir/$server/$host/";
    if ( opendir( my $DIR, "$dir" ) ) {
      my @list = readdir($DIR);
      closedir($DIR);

      # take Local_Fixed_Disk & Cluster_Storages
      @files = grep ( /Local_Fixed_Disk_|Cluster_Storage_/, @list );

      # print STDERR "10252 \@files @files\n";
    }
  }
  elsif ( $item eq "data_as" || $item eq "iops_as" ) {
    $dir = "$wrkdir/$server/$host/$lpar--AS400--/ASP/";
  }
  elsif ( $item eq "clustlan" ) {
    @files = ();
    my $hosts_in_cluster = "$wrkdir/$server/$host/hosts_in_cluster";
    open( FF, "<$hosts_in_cluster" ) || error( "can't open $hosts_in_cluster: $! :" . __FILE__ . ":" . __LINE__ ) && return;
    my @hosts = (<FF>);
    close(FF);
    chomp @hosts;
    foreach (@hosts) {
      ( my $server, my $host ) = split( "XORUX", $_ );
      push @files, "$wrkdir/$server/$host/pool.rrm";
    }

    # print STDERR "6899 \$host $host \$server $server \@files @files\n";
  }
  elsif ( $item eq "data_ifcb" || $item eq "paket_ifcb" || $item eq "dpaket_ifcb" ) {
    $dir = "$wrkdir/$server/$host/$lpar--AS400--/IFC/";
  }
  elsif ( $item eq "hmcpgs" ) {
    $dir  = "$wrkdir/--HMC--$host/";
    $lpar = "$host";
  }
  elsif ( $item eq "vmw-iops" ) {

    # print STDERR "4079 $wrkdir/$server/$host/my_vcenter_name\n";
    if ( $host eq "nope" || $host =~ /cluster_/ ) {    # from server hist report - necessary to find vCenter, what about get it directly from histrep.pl ?
      my @path_temp = <$wrkdir/$server/*>;

      # print STDERR "4081 \@path_temp @path_temp\n";
      return if !defined $path_temp[0];                # some trash
      $host = ( split( /\//, $path_temp[0] ) )[-1];
    }

    # print STDERR "4084 $wrkdir/$server/$host/my_vcenter_name \$detail $detail\n";
    # if there is data for IOPS under any datastore in vCenter/datacenter/datastore/*.rrv
    my $vm_iops = 0;
    if ( open( FH, "< $wrkdir/$server/$host/my_vcenter_name" ) ) {
      my $vcenter_name = <FH>;
      close(FH);
      chomp $vcenter_name;    # e.g. '10.22.11.10|Regina-new'
                              # now look for the appropriate vCenter
      ( undef, $vcenter_name ) = split( /\|/, $vcenter_name );

      # print STDERR "3872 \$vcenter_name $vcenter_name\n";
      my $vCenter     = "";
      my $last_update = 0;

      foreach my $center (<$wrkdir/vmware_*>) {
        next if $center =~ "vmware_VMs";
        next if !open( FH, "< $center/vmware_alias_name" );
        my $vmware_alias_name = <FH>;
        close(FH);
        next if $vmware_alias_name !~ /$vcenter_name$/;

        # find the newest one vcenter
        my $update = ( stat("$center/vmware_alias_name") )[9];
        if ( $last_update < $update ) {
          $vCenter     = $center;
          $last_update = $update;
        }
      }

      # print STDERR "4185 found \$vCenter $vCenter $vCenter/*/*/$lpar.rrv\n";
      if ( $vCenter ne "" ) {
        @files = <$vCenter/*/*/$lpar.rrv>;

        # print STDERR "4189 \@files @files\n";
        $lpar = human_vmware_name($lpar);
      }
    }
  }
  elsif ( $item =~ /^solaris_ldom_net/ ) {
    if ( $server =~ /Solaris--unknown|Solaris\d+--unknown/ ) { $server = $lpar; }

    #print STDERR"==$wrkdir/Solaris/$server/==  \n";
    opendir( DIR, "$wrkdir/Solaris/$server/" ) || error( "can't opendir $wrkdir/Solaris/$server/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
    my @ldom_path = grep !/^\.\.?$|ZONE|_ldom\.mmm$|uuid|solaris11|solaris10|^san|^vlan|\.txt|pool|ldom$/, readdir(DIR);
    foreach my $ldom_file (@ldom_path) {
      chomp $ldom_file;
      push( @files, "$ldom_file\n" );
    }
  }
  elsif ( $item =~ /^solaris_ldom_vnet/ ) {
    if ( $server =~ /Solaris--unknown|Solaris\d+--unknown/ ) { $server = $lpar; }
    opendir( DIR, "$wrkdir/Solaris/$server/" ) || error( "can't opendir $wrkdir/Solaris/$server/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
    my @ldom_path = grep /^vlan-/, readdir(DIR);
    foreach my $ldom_file (@ldom_path) {
      chomp $ldom_file;
      push( @files, "$ldom_file\n" );
    }
  }
  elsif ( $item =~ /^solaris_ldom_san1|^solaris_ldom_san2/ ) {
    if ( $server !~ /Solaris--unknown|Solaris\d+--unknown/ ) {
      opendir( DIR, "$wrkdir/Solaris/$server/" ) || error( "can't opendir $wrkdir/Solaris/$server/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
      my @san_path = grep /^san-c/, readdir(DIR);
      foreach my $san_file (@san_path) {
        chomp $san_file;
        push( @files, "$san_file\n" );
      }
    }
    else {
      opendir( DIR, "$wrkdir/Solaris/$lpar/" ) || error( "can't opendir $wrkdir/Solaris/$lpar/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
      my @san_path = grep /^san-c/, readdir(DIR);
      foreach my $san_file (@san_path) {
        chomp $san_file;
        push( @files, "$san_file\n" );
      }
    }
  }
  elsif ( $item =~ /^san_no_ldom1|^san_no_ldom2/ ) {
    opendir( DIR, "$wrkdir/Solaris/$lpar/" ) || error( "can't opendir $wrkdir/Solaris/$lpar/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
    my @san_path = grep /^san-c/, readdir(DIR);
    foreach my $san_file (@san_path) {
      chomp $san_file;
      push( @files, "$san_file\n" );
    }
  }
  elsif ( $item =~ /solaris_ldom_san_resp/ ) {
    if ( $server !~ /Solaris--unknown|Solaris\d+--unknown/ ) {
      opendir( DIR, "$wrkdir/Solaris/$server/" ) || error( "can't opendir $wrkdir/Solaris/$server/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
      my @san_resp_path = grep /^san_tresp/, readdir(DIR);
      foreach my $san_resp_file (@san_resp_path) {
        chomp $san_resp_file;
        push( @files, "$san_resp_file\n" );
      }
    }
    else {
      opendir( DIR, "$wrkdir/Solaris/$lpar/" ) || error( "can't opendir $wrkdir/Solaris/$lpar/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
      my @san_resp_path = grep /^san_tresp/, readdir(DIR);
      foreach my $san_resp_file (@san_resp_path) {
        chomp $san_resp_file;
        push( @files, "$san_resp_file\n" );
      }
    }
  }
  elsif ( $item =~ /solaris_ldom_pack/ ) {
    opendir( DIR, "$wrkdir/Solaris/$lpar/" ) || error( "can't opendir $wrkdir/Solaris/$server/: $! :" . __FILE__ . ":" . __LINE__ ) && next;
    my @files_sum = grep !/^\.\.?$|ZONE|_ldom\.mmm$|uuid|solaris11|solaris10|^san|ldom|host|\.txt|pool/, readdir(DIR);
    foreach my $ldom_pack (@files_sum) {
      chomp $ldom_pack;
      push( @files, "$ldom_pack\n" );
    }
  }

  # print STDERR "4195 detail-graph-cgi.pl \$item $item $dir\n";
  my $lpar_slash = $lpar;
  if ( $item eq "hdt_latency" || $item eq "hyppg2" ) {
    $lpar_slash = $host;

    # print STDERR "10406 \$host $host\n";
  }
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $ds_name1 = "recv_bytes";
  my $ds_name2 = "trans_bytes";

  my $fpn = "lan-";                  # according to $item

  my $last_txt             = " last ";
  my $header_prefix        = "Eth:";
  my $lpar_slash_nmon_head = $lpar_slash_nmon;
  if ( $detail == 2 ) {
    $last_txt             = "";
    $lpar_slash_nmon_head = "" if $server eq "Linux";
    $header_prefix        = "ETH:";
    $header_prefix        = "ETH PCK" if $item =~ /packets_lan/;
    if ( $wpar == 1 ) {
      $header_prefix = "ETH";
    }
  }

  $header_prefix        = "DS:IOPS:"    if $item eq "ds-vmiops";
  $header_prefix        = "VM:IOPS:"    if $item eq "vmw-iops";
  $header_prefix        = "IOPS:"       if $item eq "vmw-iops" && $detail == 2;
  $lpar_slash_nmon_head = ""            if $item eq "ds-vmiops" or $item eq "clustlan";
  $header_prefix        = "Server:LAN"  if $item eq "clustlan";
  $header_prefix        = "VOLUMES : "  if $item =~ "s2d_volume_agr_";
  $header_prefix        = "FC errors:"  if $item eq "error_san";
  $header_prefix        = "ETH errors:" if $item eq "error_lan";

  my $header = "$header_prefix$lpar_slash_nmon_head:$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      $header = "$header_prefix$lpar_slash_nmon_head : $start_human - $end_human" if $item eq "ds-vmiops";
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
      }
      $last_txt = "$start_human - $end_human";
      $text     = "";
    }
  }

  my $headline1 = "COMMENT:Average [MB/sec]";
  $vertical_label = "--vertical-label=Read - Bytes/sec - Write";

  my $g_format = "6.2lf";
  my $divider  = 1000000;

  if ( $item =~ "^lan" ) {
    $ds_name2 = "recv_bytes";
    $ds_name1 = "trans_bytes";
  }

  if ( $item eq "vmw-iops" || $item eq "ds-vmiops" ) {
    $ds_name1 = "vm_iops_read";
    $ds_name2 = "vm_iops_write";
  }

  if ( $item =~ "packets_" ) {
    $ds_name2       = "recv_packets";
    $ds_name1       = "trans_packets";
    $headline1      = "COMMENT:Average [Packets/sec]";
    $vertical_label = "--vertical-label=Read - Packets/sec - Write";
    $divider        = 1;
    $g_format       = "6.0lf";
    if ( $detail == 2 ) {
      $last_txt             = "";
      $lpar_slash_nmon_head = "" if $server eq "Linux" || $server eq "AS400";

      # $header_prefix = "PACKETS";
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";
    if ( !$start_unix eq '' && !$end_unix eq '' ) {
      if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

        # historical reports
        my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
        my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
        $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $detail == 10 ) {
          $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        }
      }
    }
  }

  if ( $item =~ "clustlan" ) {
    $ds_name1       = "Network_received";
    $ds_name2       = "Network_transmitted";
    $headline1      = "COMMENT:Average [MB/sec]";
    $vertical_label = "--vertical-label=Read - Bytes/sec - Write";
    $divider        = 1000;
    $g_format       = "6.2lf";
    if ( $detail == 2 ) {
      $last_txt             = "";
      $lpar_slash_nmon_head = "" if $server eq "Linux" || $server eq "AS400";

      # $header_prefix = "PACKETS";
    }
    $header    = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";
    $no_legend = "--interlaced";
  }
  if ( $item =~ m/^san|^solaris_ldom_san1|^solaris_ldom_san2|^san_no_ldom1|^san_no_ldom2/ ) {
    $fpn = "san-";
    my $header_prefix = "SAN:";
    if ( $detail == 2 ) {
      $last_txt             = "";
      $lpar_slash_nmon_head = "" if $server eq "Linux";
      $header_prefix        = "SAN";
      if ( $wpar == 1 ) {
        $header_prefix = "SAN";
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

    if ( !$start_unix eq '' && !$end_unix eq '' ) {
      if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

        # historical reports
        my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
        my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
        $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $detail == 10 ) {
          $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        }
      }
    }
  }
  if ( $item =~ m/^data_as/ || $item =~ m/^iops_as/ || $item =~ m/^data_ifcb/ || $item =~ m/^paket_ifcb/ || $item eq "dpaket_ifcb" ) {
    $fpn = "";
    my $h_pref = "";
    $h_pref = "ASP DATA:"          if $item eq "data_as";
    $h_pref = "ASP IOPS:"          if $item eq "iops_as";
    $h_pref = "IFCB LAN:"          if $item eq "data_ifcb";
    $h_pref = "IFCB packets:"      if $item eq "paket_ifcb";
    $h_pref = "IFCB packets disc:" if $item eq "dpaket_ifcb";
    my $header_prefix = $h_pref;

    if ( $detail == 2 ) {
      $last_txt             = "";
      $lpar_slash_nmon_head = ""              if $server eq "Linux" || $server eq "as400";
      $h_pref               = "Packets:"      if $item eq "paket_ifcb";
      $h_pref               = "Packets disc:" if $item eq "dpaket_ifcb";
      $header_prefix        = $h_pref;
      if ( $wpar == 1 ) {
        $header_prefix = $h_pref;
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head:$last_txt$text";

    if ( !$start_unix eq '' && !$end_unix eq '' ) {
      if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

        # historical reports
        my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
        my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
        $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $detail == 10 ) {
          $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        }
      }
    }

    # 5.07-6 fix, read/write were wrong, replaced each other
    if ( $item =~ m/^data_ifcb/ ) {
      $ds_name1 = "par3";
      $ds_name2 = "par4";
    }

    # 5.05 fix, read/write were wrong, replaced each other
    if ( $item eq "data_as" ) {
      $ds_name1 = "par3";
      $ds_name2 = "par4";
    }
    if ( $item =~ "paket_ifcb" ) {

      # 5.07-6 fix, read/write were wrong, replaced each other
      $ds_name1       = "par7";
      $ds_name2       = "par8";
      $divider        = 1;
      $vertical_label = "--vertical-label=Read - Packets/sec - Write";
      $g_format       = "6.0lf";
      $headline1      = "COMMENT:Average [Packets/sec]";
      if ( $item eq "dpaket_ifcb" ) {
        $ds_name1 = "par5";
        $ds_name2 = "par6";
      }
    }
    if ( $item eq "iops_as" ) {
      $ds_name1 = "par5";
      $ds_name2 = "par6";
      $g_format = "6.0lf";
      $divider  = 1;
    }
  }
  if ( $item =~ m/^sea/ || $item =~ m/^packets_sea/ ) {
    $fpn = "sea-";
    my $header_prefix = "SEA:";
    if ( $detail == 2 ) {
      $last_txt = "";
      my $lpar_slash_nmon_head = "" if $server eq "Linux";
      $header_prefix = "SEA";
      $header_prefix = "SEA PCK" if $item =~ m/^packets_sea/;
      if ( $wpar == 1 ) {
        $header_prefix = "SEA";
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

    if ( !$start_unix eq '' && !$end_unix eq '' ) {
      if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

        # historical reports
        my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
        my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
        $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $detail == 10 ) {
          $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        }
      }
    }
    $ds_name2       = "recv_bytes";
    $ds_name1       = "trans_bytes";
    $ds_name2       = "recv_packets"                              if $item =~ m/packets_sea/;
    $ds_name1       = "trans_packets"                             if $item =~ m/packets_sea/;
    $vertical_label = "--vertical-label=Read - Bytes/sec - Write" if $item =~ m/^sea/;
    $headline1      = "COMMENT:Average [MB/sec]";
    $headline1      = "COMMENT:Average [Packets/sec]" if $item =~ m/packets_sea/;
    $headline2      = "COMMENT:Phys  (SEA)  READ  Avg      Max    WRITE   Avg      Max";

    if ( $detail == 1 ) {
      $headline2 .= "        Phys  (SEA)  READ   Avg      Max     WRITE   Avg      Max";
    }
  }
  if ( $item eq "pg2" || $item eq "hmcpgs" || $item eq "hyppg2" ) {
    $fpn = "pgs";
    my $header_prefix = "PAGING SPACE:";
    if ( $detail == 2 ) {
      $last_txt = "";
      my $lpar_slash_nmon_head = "" if $server eq "Linux";
      $header_prefix = "PG2";
      if ( $wpar == 1 ) {
        $header_prefix = "PG";
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

    $upper_limit = 100;
    if ( !$start_unix eq '' && !$end_unix eq '' ) {
      if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

        # historical reports
        my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
        my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
        $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $detail == 10 ) {
          $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        }
      }
    }
    $ds_name1  = "paging_space";
    $ds_name2  = "percent";
    $headline1 = "COMMENT:Usage [%]  AVRG   MAX";
    if ( $item eq "hyppg2" ) {
      $ds_name1 = "DiskBytesPersec";
      $ds_name2 = "DiskTransfersPersec";
    }

    #  $headline1 = "COMMENT:Average usage in %";
    $headline2      = "COMMENT:             ";
    $vertical_label = "--vertical-label=Paging utilization in %";
  }
  if ( $item =~ m/^san2/ ) {
    $fpn = "san-";
  }
  if ( $item =~ m/^san_resp/ ) {
    $fpn = "san_resp-";
  }
  if ( $item =~ m/^error_san$/ ) {
    $headline1      = "COMMENT:Errors";
    $headline2      = "COMMENT: Int          Avg      Max";
    $vertical_label = "--vertical-label= FC errors / sec";
    $fpn            = "san_error-";
    $ds_name1       = "error_fcs";
    $ds_name2       = "";
    $g_format       = "4.0lf";
    $upper_limit    = 1;
    $divider        = 1;
  }
  if ( $item =~ m/^error_lan$/ ) {
    $headline1      = "COMMENT:Errors";
    $headline2      = "COMMENT: Int          Avg      Max";
    $vertical_label = "--vertical-label= ETH errors / sec";
    $fpn            = "lan_error-";
    $ds_name1       = "error_lan";
    $ds_name2       = "";
    $g_format       = "4.0lf";
    $upper_limit    = 1;
    $divider        = 1;
  }
  if ( $item =~ m/^iops_as/ ) {
    $vertical_label = "--vertical-label=Read - IOPS - Write";
    $headline1      = "COMMENT:Average [IO per sec]";
  }
  if ( $item eq "vmw-iops" || $item eq "ds-vmiops" ) {
    $vertical_label = "--vertical-label=Read - IOPS - Write";
    $headline1      = "COMMENT: [IO per sec]";
    $g_format       = "4.0lf";
    $divider        = 1;
  }
  if ( $item eq "solaris_ldom_net" or $item eq "solaris_ldom_vnet" ) {
    $ds_name1 = "rbytes";
    $ds_name2 = "obytes";
    $g_format = "4.2lf";
    $divider  = 1000;
  }
  if ( $item eq "solaris_ldom_san1" || $item eq "san_no_ldom1" ) {
    $ds_name1 = "recv_bytes";
    $ds_name2 = "trans_bytes";
    $g_format = "4.2lf";
  }
  if ( $item eq "solaris_ldom_san2" ) {
    $ds_name1       = "iops_in";
    $ds_name2       = "iops_out";
    $g_format       = "4.0lf";
    $divider        = 1;
    $vertical_label = "--vertical-label=Read - IOPS - Write";
  }
  if ( $item eq "solaris_ldom_pack" ) {
    $ds_name1       = "ipackets";
    $ds_name2       = "opackets";
    $g_format       = "4.0lf";
    $divider        = 1;
    $headline1      = "COMMENT:Average [Packets/sec]";
    $vertical_label = "--vertical-label=Read - Packets/sec - Write";
  }
  if ( $item eq "s2d_volume_agr_iops" ) {
    $header         = "$header_prefix" . "IOPS :" . "$last_txt$text";
    $headline1      = "COMMENT:[IOPS]";
    $ds_name1       = "IOPS_Read";
    $ds_name2       = "IOPS_Write";
    $g_format       = "6.0lf";
    $divider        = 1;
    $vertical_label = "--vertical-label=Read - IOPS - Write";
  }
  if ( $item eq "s2d_volume_agr_data" ) {
    $header         = "$header_prefix" . "Data :" . "$last_txt$text";
    $headline1      = "COMMENT:[MB/sec]";
    $ds_name1       = "Throughput_Read_B";
    $ds_name2       = "Throughput_Write_B";
    $g_format       = "6.2lf";
    $divider        = 1024 * 1024;
    $vertical_label = "--vertical-label=Read - Bytes/sec - Write";
  }
  if ( $item eq "s2d_volume_agr_latency" ) {
    $header         = "$header_prefix" . "Latency :" . "$last_txt$text";
    $headline1      = "COMMENT:[Latency/ms]";
    $ds_name1       = "Latency_Read_sec";
    $ds_name2       = "Latency_Write_sec";
    $g_format       = "6.2lf";
    $divider        = 0.001;
    $vertical_label = "--vertical-label=Read - Latency/sec - Write";
  }
  if ( $item eq "hdt_latency" ) {

    # print STDERR "10754 \$dir $dir \$header_prefix $header_prefix \$header $header \$lpar_slash_nmon $lpar_slash_nmon \$lpar_slash_nmon_head $lpar_slash_nmon_head\n";
    $header_prefix = "";
    $header        = "$header_prefix" . "Latency :$host " . "$last_txt$text";
    if ( $detail == 2 ) {
      $header = "$header_prefix" . "Latency:" . "$last_txt$text";
    }
    $headline1 = "COMMENT:[Latency/ms]";

    #$ds_name1       = "Latency_Read_sec";  # hard coded in CDEF
    #$ds_name2       = "Latency_Write_sec"; # hard coded in CDEF
    $g_format = "6.2lf";
    $divider  = 1;

    # $filter         = 10000; # hard coded in CDEF
    $vertical_label = "--vertical-label=Read - Latency/ms - Write";
  }

  my $dh;
  if ( $item eq "hyppg2" ) {
    -f "$dir/pool.rrm" || error( "no file $dir/pool.rrm to graph: " . __FILE__ . ":" . __LINE__ ) && return 0;
    @files = ("pool.rrm");
  }
  elsif ( $item eq "data_as" || $item eq "iops_as" || $item =~ m/^data_ifcb/ || $item =~ m/^paket_ifcb/ || $item =~ m/^dpaket_ifcb/ ) {
    my $file_test = "4\.mmc";
    $file_test = "mmc" if $item =~ m/^data_ifcb/ || $item =~ m/^paket_ifcb/ || $item =~ m/^dpaket_ifcb/;
    opendir( $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
    my @files_unsorted = grep { (/$file_test$/) } readdir($dh);
    @files = sort @files_unsorted;
    closedir $dh;
    ( @files > 0 ) || error( "no files $dh to graph in $dir: " . __FILE__ . ":" . __LINE__ ) && return 0;

    # print STDERR "3409 detail-graph-cgi.pl \@files @files\n";
  }
  elsif ( $item eq "ds-vmiops" ) {
    opendir( $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
    @files = grep { (/\.rrv$/) } readdir($dh);
    closedir $dh;
    ( @files > 0 ) || error( "no files $dh to graph in $dir: " . __FILE__ . ":" . __LINE__ ) && return 0;
  }
  elsif ( $item =~ "s2d_volume_agr_" ) {
    $dir = "$wrkdir/$server/$host/volumes/";
    opendir( $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
    @files = grep { (/^vol_.*\.rrm$/) } readdir($dh);
    closedir($dh);
    ( @files > 0 ) || error( "no files $dh to graph in $dir: " . __FILE__ . ":" . __LINE__ ) && return 0;

    #print STDERR "9582 detail-graph-cgi.pl $dir $item @files\n";
  }
  elsif ( $item ne "vmw-iops" && $item ne "solaris_ldom_net" && $item ne "solaris_ldom_san1" && $item ne "solaris_ldom_san2" && $item ne "solaris_ldom_san_resp" && $item ne "solaris_ldom_pack" && $item ne "san_no_ldom1" && $item ne "solaris_ldom_vnet" && $item ne "clustlan" && $item ne "hdt_latency" ) {
    opendir( $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
    my @files_unsorted = grep { /^$fpn/ && ( /\.mmm$/ || /\.mmx$/ ) } readdir($dh);
    @files = sort @files_unsorted;
    closedir $dh;
    ( @files > 0 ) || error( "no files $dh to graph in $dir: " . __FILE__ . ":" . __LINE__ ) && return 0;
  }

  # print STDERR "4099 detail-graph-cgi.pl \$item $item \@files @files\n";

  my $iops       = "IOPS";
  my @files_iops = ();
  if ( $item ne "vmw-iops" && $item ne "ds-vmiops" && $item ne "solaris_ldom_net" && $item ne "solaris_ldom_san1" && $item ne "solaris_ldom_san2" && $item ne "solaris_ldom_san_resp" && $item ne "solaris_ldom_pack" && $item ne "san_no_ldom1" && $item ne "solaris_ldom_vnet" && $item ne "clustlan" && $item ne "hdt_latency" ) {
    opendir( $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
    @files_iops = grep { /^san-host/ && /\.mmm$/ } readdir($dh);
    closedir $dh;
    if ( @files_iops > 0 ) {

      # Linux standalones provide only SAN frames
      $iops = "Frames";
    }
  }

  # find date of latest file
  # prepare string in format: Updated: Fri Jul 17 10:40:01 2015

  my $col_index       = 0;
  my %file_color_hash = ();
  my $last_update     = 0;
  foreach my $file (@files) {
    my $rrd_ldom = "";
    if ( $item eq "solaris_ldom_net" or $item eq "solaris_ldom_san1" or $item eq "solaris_ldom_san2" or $item eq "solaris_ldom_san_resp" or $item eq "solaris_ldom_pack" or $item eq "solaris_ldom_vnet" ) {
      if ( $server !~ /Solaris--unknown|Solaris\d+--unknown/ ) {
        $rrd_ldom = "$wrkdir/Solaris/$server/$file";
        chomp $rrd_ldom;
      }
      else {
        if ( $server =~ /Solaris--unknown|Solaris\d+--unknown/ ) { $server = $lpar; }
        $rrd_ldom = "$wrkdir/Solaris/$lpar/$file";
        chomp $rrd_ldom;
      }
    }
    if ( $item eq "san_no_ldom1" ) {
      $rrd_ldom = "$wrkdir/Solaris/$lpar/$file";
      chomp $rrd_ldom;
    }
    my $update = 0;
    if ( $item eq "vmw-iops" or $item eq "clustlan" ) {
      $file =~ s/\\//g;
      $update = ( stat("$file") )[9];
    }
    elsif ( $item eq "solaris_ldom_net" or $item eq "solaris_ldom_san1" or $item eq "solaris_ldom_san2" or $item eq "solaris_ldom_san_resp" or $item eq "solaris_ldom_pack" or $item eq "san_no_ldom1" or $item eq "solaris_ldom_vnet" ) {
      $update = ( stat("$rrd_ldom") )[9];
    }
    else {
      $update = ( stat("$dir/$file") )[9];
      next if ( -f "$dir/$file" and ( -M "$dir/$file" > 365 ) );    # not older 1 year
    }

    # $update = ( stat("$file") )[9] if ( $item eq "vmw-iops" );
    # $update = ( stat("$rrd_ldom") )[9] if ( $item eq "s_ldom_n" or $item eq "s_ldom_san1" or $item eq "s_ldom_san2" or $item eq "s_ldom_san_resp" or $item eq "s_ldom_pack" or $item eq "s_ldom_vnet");
    # $update = ( stat("$rrd_ldom") )[9] if ( $item eq "san_no_ldom1" );

    if ( $update > $last_update ) {
      $last_update = $update;
    }
    $file_color_hash{$file} = $col_index++ % ( $color_max + 1 );    # this is color for read
    $col_index++;                                                   # this is color for write
  }

  # print STDERR "Updated: " . localtime($last_update) . "\n";
  my $ltime = localtime($last_update);
  $ltime =~ s/:/\\\:/g;
  $t = "COMMENT:Updated\\\: $ltime ";

  # prepare for later testing
  my $san2nmon  = 0;    #means xin/xout separately
  my $minus_one = -1;

  if ( $item =~ /^san2/ && index( $lpar, "--NMON--" ) ne -1 ) {
    my $name_cfg = "";
    my $file_cfg = "$dir$files[0]";
    $file_cfg =~ s/mmm$/cfg/;
    if ( -f "$file_cfg" ) {
      open( FF, "<$file_cfg" ) || error( "can't open $file_cfg: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
      $name_cfg = (<FF>);
      close(FF);
      if ( $name_cfg !~ /full/ ) { $san2nmon = 1; }

      # signal for detail-graph-cgi.pl to graph xin/xout NOT separately
    }
  }

  # print STDERR "san2nmon je $san2nmon\n";

  my $filter = $filter_max_lansan;
  if ( $item =~ m/^san2/ ) {
    $g_format = "6.0lf";
    $divider  = 1;
    $fpn      = "san-";
    my $header_prefix = "$iops:";
    if ( $detail == 2 ) {
      $last_txt = " ";
      my $lpar_slash_nmon_head = "" if $server eq "Linux";
      $header_prefix = "$iops";
      if ( $wpar == 1 ) {
        $header_prefix = "$iops";
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

    if ( !$start_unix eq '' && !$end_unix eq '' ) {
      if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

        # historical reports
        my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
        my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
        $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $detail == 10 ) {
          $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        }
      }
    }
    if ( $iops =~ m/Frames/ ) {

      # Linux san-host* have swapped in/out frames, fixed in 5.07-4
      $ds_name1 = "iops_out";
      $ds_name2 = "iops_in";
    }
    else {
      $ds_name1 = "iops_in";
      $ds_name2 = "iops_out";
    }
    $headline1      = "COMMENT:Average [IO per sec]";
    $vertical_label = "--vertical-label=Read - $iops - Write";
    $filter         = $filter_max_iops;
    if ($san2nmon) {
      $minus_one      = 1;
      $vertical_label = "--vertical-label=$iops Total";
      ( $headline2, undef ) = split( "WRITE", $headline2 );
      $headline2 =~ s/READ/TOTAL/;
      if ( $detail == 1 ) {
        ( undef, my $piece ) = split( ":", $headline2 );
        $headline2 .= $piece;
      }
    }
  }

  if ( $item =~ m/^san_resp/ || $item =~ m/^solaris_ldom_san_resp/ ) {
    $g_format = "6.2lf";
    $divider  = 1;
    $fpn      = "san_resp-";
    if ( $item =~ m/^solaris_ldom_san_resp/ ) {
      $fpn = "san_tresp-";
    }
    my $header_prefix = "Response time:";
    if ( $detail == 2 ) {
      $last_txt = " ";
      my $lpar_slash_nmon_head = "" if $server eq "Linux";
      $header_prefix = "RESP:";
      if ( $wpar == 1 ) {
        $header_prefix = "RESP:";
      }
    }
    $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

    if ( !$start_unix eq '' && !$end_unix eq '' ) {
      if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

        # historical reports
        my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
        my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
        $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $detail == 10 ) {
          $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        }
      }
    }
    if ( $item =~ m/^san_resp/ ) {
      $ds_name1 = "resp_t_r";
      $ds_name2 = "resp_t_w";
    }
    else {
      $ds_name1 = "resp_all";
    }
    $headline1      = "COMMENT:Average [ms]";
    $vertical_label = "--vertical-label=Read - ms - Write";
    $headline2      = "COMMENT:Int     READ/WRITE   Avg      Max" if ( $item eq "solaris_ldom_san_resp" );
  }

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  elsif ( $detail != 10 && $detail != 9 && $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
  }

  if ( $type =~ m/y/ ) {

    # lower limits for yearly graphs as they are averaged ....
    $filter = $filter / 10;
  }
  if ( $type =~ m/m/ ) {

    # lower limits for monthly graphs as they are averaged ....
    $filter = $filter / 2;
  }
  my $color_indx = -1;            # prepare color index
  my $line_indx  = 0;             # place enter every 3rd line
  my $file       = "";
  my $i          = 0;
  my $cmd        = "";
  my $cmdx       = "";
  my $j          = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $req_time   = 0;
  my ( @recb, @trab, @rname, @rpath, @avgx, @avgy, @rpathlegend, @rnamelegend, @bubble_info, @vm_dbi_uuid );

  # @bubble_info = ""; # legend bubble for lpar (ASP) name
  my $lnx = 0;

  # variables for LPM use
  my $k = 0;    # indexes for LPM cycle
  my $l = 0;
  my ( @rb, @rbr, @tb, @tbr );
  my @rrd_files_names;
  my $ifn = -1;    # index for this array

  my $gt_ind = 0;  # must be own index for gtype
  my @gtype;
  $gtype[0] = "LINE1";
  $gtype[1] = "LINE1";

  #  $gtype[1] = "STACK";
  # if ($item =~ /^iops/ ) { $item .="a" };
  # if ($item =~ /^fic/ ) { $item .="a" };
  # if ($item =~ /^en/ ) { $item .="a" };
  if ( $item =~ m/a/ ) { $gtype[0] = "AREA" }
  if ( $item =~ m/a/ ) { $gtype[1] = "STACK" }
  if ( $item =~ m/^san_resp|^solaris_ldom_san_resp/ || $item eq "s2d_volume_agr_latency" || $item eq "hdt_latency" ) {
    $gtype[0] = "LINE1";
    $gtype[1] = "LINE1";
  }
  if ( $item eq "ds-vmiops" || $item eq "solaris_ldom_net" or $item eq "solaris_ldom_vnet" ) {
    $gtype[0] = "AREA";
    $gtype[1] = "STACK";
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  my $page_file_name = "";
  my @file_arr       = ();
  foreach $file (@files) {    # generating RRD CMD string
                              # print STDERR "foreach 1 ".localtime()."\$file $file\n";
    chomp($file);
    $bubble_info[$i] = "";    # legend bubble for lpar (ASP) name
    $vm_dbi_uuid[$i] = "";

    my $fake_name = $file;
    my $rrd       = "";
    if ( $item eq "solaris_ldom_net" or $item eq "solaris_ldom_vnet" ) {
      $rrd = "$wrkdir/Solaris/$server/$file";
    }
    elsif ( $item eq "solaris_ldom_san1" or $item eq "solaris_ldom_san2" or $item eq "solaris_ldom_san_resp" or $item eq "solaris_ldom_pack" ) {
      if ( $server !~ /Solaris--unknown|Solaris\d+--unknown/ ) {
        $rrd = "$wrkdir/Solaris/$server/$file";
      }
      else {
        $rrd = "$wrkdir/Solaris/$lpar/$file";
      }
    }
    elsif ( $item eq "san_no_ldom1" ) {
      $rrd = "$wrkdir/Solaris/$lpar/$file";
    }
    elsif ( $item eq "clustlan" ) {
      $rrd       = $file;
      $fake_name = ( split( "/", $file ) )[-3];    # get server
    }
    elsif ( $item =~ "s2d_volume_agr_" ) {
      $rrd = "$wrkdir/$server/$host/volumes/$file";
      $fake_name =~ s/vol_//g;
      $fake_name =~ s/\.rrm//g;
    }
    elsif ( $item eq "hyppg2" || $item eq "hdt_latency" ) {
      $rrd = "$wrkdir/$server/$host/$file";

      # $item = "pg2";
      # avoid old files which do not exist in the period
      # this is not easy: if there is no file -> graph is not drawn -> better would be to keep at leat one file,
      # but which one in which graph d,w,m,y ??
      # my $rrd_upd_time = ( stat("$rrd") )[9];
      # if ( $rrd_upd_time < $req_time ) {
      #  if ( $type_sam !~ m/x/ ) {

      #$i++;
      #    next;    # aviod that for historical reports
      # --> not necessary as $req_time = 0
      #  }
      # }
    }
    else {
      $rrd = "$wrkdir/$server/$host/$lpar/$file";
    }
    if ( $item eq "data_as" || $item eq "iops_as" ) {
      $rrd = "$wrkdir/$server/$host/$lpar--AS400--/ASP/$file";
      ( $fake_name, $bubble_info[$i] ) = asp_fake_name($rrd);
      $bubble_info[$i] =~ s/:/\\:/g;
    }
    elsif ( $item eq "data_ifcb" || $item =~ m/^paket_ifcb/ || $item =~ m/^dpaket_ifcb/ ) {
      $rrd = "$wrkdir/$server/$host/$lpar--AS400--/IFC/$file";
      my $file_cfg = $rrd;
      $file_cfg =~ s/mmc/cfg/;
      if ( -f $file_cfg && open( FF, "<$file_cfg" ) ) {
        $bubble_info[$i] = (<FF>);
        close(FF);
        chomp( $bubble_info[$i] );
        $bubble_info[$i] =~ s/:/\\:/g;
      }
      else {
        print STDERR "can't open $file_cfg: $! :" . __FILE__ . ":" . __LINE__ . "\n";
      }
    }
    elsif ( $item eq "hmcpgs" ) {
      $rrd  = "$wrkdir/--HMC--$host/$file";
      $item = "pg2";
    }
    elsif ( $item eq "ds-vmiops" ) {

      # print STDERR "5369 \$file $file $wrkdir/$server/$host/$lpar/$file\n";
      # avoid old files which do not exist in the period
      my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$lpar/$file") )[9];
      if ( $rrd_upd_time < $req_time ) {
        if ( $type_sam !~ m/x/ ) {

          #$i++;
          next;    # aviod that for historical reports
                   # --> not necessary as $req_time = 0
        }
      }
      $fake_name = $file;
      $fake_name =~ s/\.rrv//;
      $fake_name = human_vmware_name($fake_name);

      # do not show UUID names, these are surely old & not interesting
      # no, do show them Jindra 11/2021
      # if ($fake_name =~ m{.{8}-.{4}-.{4}-.{4}-.{12}}) {
      #  next;
      #}
    }
    elsif ( $item eq "vmw-iops" ) {

      # print STDERR "4301 \$file $file\n";
      $rrd = "$file";

      # prepare datastore name
      my $datastore_uuid = ( split( /\//, $file ) )[-2];
      my $datastore_name = $datastore_uuid;
      my $datastore_path = $file;
      $datastore_path =~ s/$datastore_uuid.*//;
      my @names = <$datastore_path*.$datastore_uuid>;
      if ( @names > 0 && $names[0] ne "" ) {
        $datastore_name = basename( $names[0] );

        # remove extension
        $datastore_name =~ s/\.[^.]+$//;

        # $datastore_name =~ s/:/\\:/g;
        $fake_name = $datastore_name;

        # $fake_name =~ s/:/\\:/;
      }

      # print STDERR "4329 detail-graph-cgi.pl \$datastore_name $datastore_name\n";
    }

    # PH --> show all files here
    # avoid old files which do not exist in the period
    #my $rrd_upd_time = (stat("$rrd"))[9];
    # `echo "1200: detail-graph-cgi - $rrd:$rrd_upd_time:$req_time" >> /tmp/e1099`;
    #if ( $rrd_upd_time < $req_time ) {
    #if ( $type_sam !~ m/x/ ) {
    #    next; # aviod that for historical reports
    # --> not necessary as $req_time = 0
    #}
    #}

    my $rrd_name = $fake_name;    # prepare name for gprint
    $rrd_name =~ s/.mmm//;
    $rrd_name =~ s/lan-//;
    $rrd_name =~ s/san-//;
    $rrd_name =~ s/san_resp-//;
    $rrd_name =~ s/san_tresp-//;
    $rrd_name =~ s/.mmx//;
    $rrd_name =~ s/Parm4.mmc//;
    $rrd_name =~ s/.mmc//;
    $rrd_name =~ s/san_error-//;
    $rrd_name =~ s/lan_error-//;

    if ( $rrd_name =~ m/sea-/ && $item ne "vmw-iops" && $item ne "ds-vmiops" && $item ne "solaris_ldom_net" && $item ne "solaris_ldom_vnet" ) {
      my $name_cfg = "";
      my $file_cfg = "$wrkdir/$server/$host/$lpar/$rrd_name.cfg";
      if ( -f "$file_cfg" ) {
        open( FF, "<$file_cfg" ) || error( "can't open $file_cfg: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
        $name_cfg = (<FF>);
        close(FF);
        chomp($name_cfg);
        if ( length($name_cfg) == 4 ) { $name_cfg .= " "; }
      }
      if ( length($rrd_name) == 8 ) { $rrd_name .= " " }
      $rrd_name .= "(" . $name_cfg . ")";
      $rrd_name =~ s/sea-//;
    }
    my $rrd_name_legend = $rrd_name;
    $rrd_name_legend =~ s/:/\\:/g;
    $rrd_name_legend =~ s/%/%%/g;
    if ( $item eq "hdt_latency" ) {
      $rrd_name_legend =~ s/\.rrm$//;
    }

    # add spaces to rrd name to have xxx chars total (for formating graph legend)
    my $xxx = 8;
    $xxx = 25 if $item eq "vmw-iops" || $item eq "ds-vmiops";
    for ( my $k = length($rrd_name); $k < $xxx; $k++ ) {
      $rrd_name .= " ";
    }

    #print "$wrkdir/$server/$host/$lpar/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3);

    if ( $i eq 0 ) {    # first cycle only
      if ( ( $type =~ "d" ) && ( $t eq "" ) ) {
        RRDp::cmd qq(last "$rrd");
        my $last_tt = RRDp::read;
        my $l       = localtime( time_from_last_tt($last_tt) );

        # following must be for RRD 1.2+
        $l =~ s/:/\\\:/g;
        $t = "COMMENT:Updated\\\: $l ";
      }

      #if ( $type =~ "y" ) {
      #   $step_new=86400;
      #}

      # find rrd database file step

      if ( index( $lpar, "--NMON--" ) ne -1 ) {    #you can change step only for NMON
        RRDp::cmd qq("info" "$rrd");
        my $answer = RRDp::read;
        if ( $$answer =~ "ERROR" ) {
          error( "Rrdtool error : $$answer " . __FILE__ . ":" . __LINE__ );
        }
        else {
          my ($step_from_rrd) = $$answer =~ m/step = (\d+)/;
          if ( $step_from_rrd > 0 ) {
            $step_new = $step_from_rrd;
          }
        }
      }

      #$step_new = 600;

      # print STDERR "11242 graphing ENT   : $host:$server:$lpar_slash:$type_sam:$type \$header $header\n"; # if $DEBUG ;

      if ( $detail == 2 ) {
        $vertical_label = "--interlaced";    # nope string
      }

      # print STDERR "5504 \$detail $detail \$rrd_legend $rrd_legend \$item $item \$no_legend $no_legend\n";
      if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" && ( $item =~ m/^san/ || $item =~ m/^lan/ || $item =~ m/^sea/ || $item =~ m/^data_as/ || $item =~ m/^iops_as/ || $item =~ m/^data_ifcb/ || $item =~ m/^paket_ifcb/ || $item =~ m/^dpaket_ifcb/ || $item =~ m/packets_lan/ || $item =~ m/packets_sea/ || $item eq "vmw-iops" || $item eq "ds-vmiops" || $item eq "solaris_ldom_net" || $item eq "solaris_ldom_san1" || $item eq "solaris_ldom_san2" || $item eq "solaris_ldom_san_resp" || $item eq "solaris_ldom_pack" || $item eq "san_no_ldom1" || $item eq "solaris_ldom_vnet" || $item eq "clustlan" || $item =~ "s2d_volume_agr_" || $item eq "hdt_latency" || $item =~ m/^error/ ) ) {
        $no_legend = "--no-legend";
      }
      $cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"
        "--title" "$header"
        "--start" "$start_time"
        "--end" "$end_time"
        "--imgformat" "PNG"
        "--slope-mode"
        "--width=$width"
        "--height=$height"
        "--step=$step_new"
        "--color=BACK#$pic_col"
        "--color=SHADEA#$pic_col"
        "--color=SHADEB#$pic_col"
        "--color=CANVAS#$pic_col"
        "--upper-limit" "$upper_limit"
        "--lower-limit" "0"
        "$vertical_label"
        "--alt-y-grid"
        "$xgrid"
        "$no_legend"
        "$disable_rrdtool_tag"
        "$font_def"
        "$font_tit"
        "$headline1"
        "$t2"
       ';
      if ( $item ne "pg2" and $item ne "hyppg2" ) {
        $cmd .= '"$headline2"
              "$t2"
       ';
      }
    }

    # every cycle
    #   because of anti ':' moved here
    my $rrd_orig_colon = $rrd;
    $rrd =~ s/:/\\:/g;           #anti ':'
    $rname[$i] = "$rrd_name";    # for graphing
    if ( $item eq "hdt_latency" ) {
      $rname[$i] =~ s/\.rrm$//;
    }

    # anti ':' for vmw-iops legends
    $rname[$i] =~ s/:/\\:/g;

    $rpath[$i]       = "$rrd";
    $rpathlegend[$i] = "$rrd";
    $rpathlegend[$i] =~ s/&&1/\//g;
    $rpathlegend[$i] =~ s/%/%%/g;
    $rnamelegend[$i] = $rrd_name_legend;

    if ( $item eq "vmw-iops" || $item eq "ds-vmiops" ) {
      $rpathlegend[$i] = "rrd";
      $rnamelegend[$i] = "$rrd_name_legend";
    }

    $recb[$i] = "rcb${i}";
    $trab[$i] = "trb${i}";
    $avgx[$i] = "avg${i}";
    $avgy[$i] = "avgy${i}";

    # start of LPM fun

    # for LPM
    $l = $k;
    my @rrd_files;
    my $lpm_suff = "rrl";
    my $cgi      = 0;
    $rrd_files[0] = $rrd_orig_colon;    #actual is the first

    lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, $file, \@rrd_files, $cgi );

    # print STDERR "11320 detail-graph-cgi.pl lpm_find_files is returning @rrd_files\n";

    foreach $rrd (@rrd_files) {         # LPM cycle
                                        # print STDERR "foreach 2 ".localtime()."\n";
      chomp($rrd);
      $rrd =~ s/:/\\:/g;
      $ifn++;
      $rrd_files_names[$ifn] = "$rrd";
      $rb[$k]                = "data1_stream${k}";
      $rbr[$k]               = "data1_stream_lpm${k}";
      $tb[$k]                = "data2_stream${k}";
      $tbr[$k]               = "data2_stream_lpm${k}";

      if ( $item eq "data_as" ) {

        # fix 5.07-6, ASP data must be multiplayed by 512 to get real numbers
        $cmd .= '"DEF:$rb[$k]_tmp=$rrd_files_names[$ifn]:$ds_name1:AVERAGE"
                 "DEF:$tb[$k]_tmp=$rrd_files_names[$ifn++]:$ds_name2:AVERAGE"
                 "CDEF:$rb[$k]=$rb[$k]_tmp,512,*"
                 "CDEF:$tb[$k]=$tb[$k]_tmp,512,*"
                ';
      }
      elsif ( $item eq "solaris_ldom_san_resp" ) {
        $cmd .= '"DEF:$rb[$k]=$rrd_files_names[$ifn++]:$ds_name1:AVERAGE"
        ';
      }
      elsif ( $item =~ m/^error/ ) {
        $cmd .= '"DEF:$rb[$k]=$rrd_files_names[$ifn++]:$ds_name1:AVERAGE"
        ';
      }
      elsif ( $item eq "hdt_latency" ) {

        # data streams see csv_lat: ( "AvgDisksecPerRead", "AvgDisksecPerReadB", "AvgDisksecPerWrite", "AvgDisksecPerWriteB", "Frequency_PerfTime" )
        #my $kbmb   = 1000;
        #my $filter = 10000;

        $cmd .= '"DEF:$rb[$k]_PerRead=$rrd_files_names[$ifn]:AvgDisksecPerRead:AVERAGE"
                ';
        $cmd .= '"DEF:$rb[$k]_PerReadB=$rrd_files_names[$ifn]:AvgDisksecPerReadB:AVERAGE"
                ';
        $cmd .= '"DEF:$tb[$k]_PerWrite=$rrd_files_names[$ifn]:AvgDisksecPerWrite:AVERAGE"
                ';
        $cmd .= '"DEF:$tb[$k]_PerWriteB=$rrd_files_names[$ifn]:AvgDisksecPerWriteB:AVERAGE"
                ';
        $cmd .= '"DEF:$tb[$k]_Frequency=$rrd_files_names[$ifn++]:Frequency_PerfTime:AVERAGE"
                ';
        $cmd .= '"CDEF:$rb[$k]_read_tmp=$rb[$k]_PerReadB,0,EQ,0,$rb[$k]_PerRead,$rb[$k]_PerReadB,/,$tb[$k]_Frequency,/,1000,*,IF"
                ';
        $cmd .= '"CDEF:$rb[$k]=$rb[$k]_read_tmp,10000,GT,0,$rb[$k]_read_tmp,IF"
                ';
        $cmd .= '"CDEF:$tb[$k]_write_tmp=$tb[$k]_PerWriteB,0,EQ,0,$tb[$k]_PerWrite,$tb[$k]_PerWriteB,/,$tb[$k]_Frequency,/,1000,*,IF"
                ';
        $cmd .= '"CDEF:$tb[$k]=$tb[$k]_write_tmp,10000,GT,0,$tb[$k]_write_tmp,IF"
                ';

      }
      else {
        $cmd .= '"DEF:$rb[$k]=$rrd_files_names[$ifn]:$ds_name1:AVERAGE"
        "DEF:$tb[$k]=$rrd_files_names[$ifn++]:$ds_name2:AVERAGE"
        ';
      }
      if ( $item eq "solaris_ldom_san_resp" || $item =~ m/^error/ ) {
        if ( $k == $l ) {
          $cmd .= '"CDEF:$rbr[$k]=$rb[$k++]"
          ';
          $k++;
          next;
        }
        $cmd .= '"CDEF:$rbr[$k]=$rbr[$l],UN,$rb[$k++],$rbr[$l++],IF"
        ';
        $l++;
        $k++;
      }
      else {
        if ( $k == $l ) {
          $cmd .= '"CDEF:$rbr[$k]=$rb[$k]"
          "CDEF:$tbr[$k]=$tb[$k++]"
          ';
          $k++;
          next;
        }
        $cmd .= '"CDEF:$rbr[$k]=$rbr[$l],UN,$rb[$k],$rbr[$l],IF"
        "CDEF:$tbr[$k]=$tbr[$l],UN,$tb[$k++],$tbr[$l++],IF"
        ';
        $l++;
        $k++;
      }
    }

    # end of LPM fun

    # $cmd .= '"DEF:$recb[$i]_nf=$rpath[$i]:$ds_name1:AVERAGE" #until 4.69 without LPM
    #          "DEF:$trab[$i]_nf=$rpath[$i]:$ds_name2:AVERAGE"

    if ( $item eq "solaris_ldom_san_resp" || $item =~ m/^error/ ) {
      $cmd .= '"CDEF:$recb[$i]_nf=$rbr[$l++]"
            ';
      $cmd .= ' "CDEF:$recb[$i]=$recb[$i]_nf,$filter,GT,UNKN,$recb[$i]_nf,IF"
          "CDEF:$recb[$i]-mil=$recb[$i],$divider,/"
         ';
    }
    else {
      # print STDERR "11417 \$filter $filter \$g_format $g_format \$divider $divider\n";
      $cmd .= '"CDEF:$recb[$i]_nf=$rbr[$l]"
               "CDEF:$trab[$i]_nf=$tbr[$l++]"
              ';

      $cmd .= ' "CDEF:$recb[$i]=$recb[$i]_nf,$filter,GT,UNKN,$recb[$i]_nf,IF"
            "CDEF:$trab[$i]=$trab[$i]_nf,$filter,GT,UNKN,$trab[$i]_nf,IF"
            "CDEF:$recb[$i]-neg=$recb[$i],$minus_one,*"
            "CDEF:$recb[$i]-mil=$recb[$i],$divider,/"
            "CDEF:$trab[$i]-mil=$trab[$i],$divider,/"
           ';

      #  my $lpar_space_proc = $rrd_name;
      #  $lpar_space_proc =~ s/%/%%/g;  # anti '%'
    }
    if ( $item eq "pg2" ) {

      #    $color_indx = $color_indx + 2;
      $cmd .= '"CDEF:$avgx[$i]=$recb[$i],100000,/,$trab[$i],*"
              "CDEF:$avgy[$i]=$recb[$i],1000,/"
              "LINE1:$trab[$i]$color[++$color_indx % ($color_max +1)]: "
              "GPRINT:$trab[$i]:AVERAGE:       %2.1lf"
              "GPRINT:$trab[$i]:MAX:%2.1lf"
              "COMMENT:( from"
              "GPRINT:$avgy[$i++]:AVERAGE:%4.1lf GB )"
              "$t2"
             ';    #do you understand difference $i++ above and below ??
      $i++;
    }
    elsif ( $item eq "hyppg2" ) {
      $page_file_name = "";
      if ( open( my $fr, "<", "$dir/page_file_name.txt" ) ) {
        $page_file_name = <$fr>;
        close $fr;
        $page_file_name =~ s/:/\\:/g;
      }

      #    $color_indx = $color_indx + 2;
      $cmd .= '"CDEF:$avgx[$i]=$recb[$i],100000,/,$trab[$i],*"
              "CDEF:$avgy[$i]=$recb[$i],1000,/"
              "CDEF:$trab[$i]-sto=$trab[$i],100,/"
              "LINE1:$trab[$i]-sto$color[++$color_indx % ($color_max +1)]: "
              "GPRINT:$trab[$i]-sto:AVERAGE:       %2.1lf"
              "GPRINT:$trab[$i]-sto:MAX:%2.1lf"
              "COMMENT:( from"
              "GPRINT:$avgy[$i++]:AVERAGE:%4.1lf GB) $page_file_name"
              "$t2"
             ';    #do you understand difference $i++ above and below ??
      $i++;
    }
    else {         # LAN SAN1 SAN2 SEA
      if ( $item eq "solaris_ldom_san_resp" || $item =~ m/^error/ ) {

        # nothing
      }
      else {
        # print STDERR "10795 \$rnamelegend[$i] $rnamelegend[$i] $file $file\n";
        if ( $item eq 'ds-vmiops' ) {    #read section
          $file_arr[$i] = $file;
          $cmd .= '"COMMENT:$rname[$i]"
                   "$gtype[$gt_ind++>0]:$recb[$i]-neg$color[$file_color_hash{$file_arr[$i]} % ($color_max +1)]: "
                   "GPRINT:$recb[$i]-mil:AVERAGE:%$g_format"
          ';
        }
        else {
          if ( $item eq 'clustlan' ) {
            $cmd .= '"COMMENT:$rname[$i]"
                     "CDEF:$recb[$i]-tis=$recb[$i]-neg,1000,*"
                     "$gtype[$gt_ind++>0]:$recb[$i]-tis$color[++$color_indx % ($color_max +1)]: "
                     "GPRINT:$recb[$i]-mil:AVERAGE:%$g_format"
            ';
          }
          else {
            $cmd .= '"COMMENT:$rname[$i]"
                     "$gtype[$gt_ind++>0]:$recb[$i]-neg$color[++$color_indx % ($color_max +1)]: "
                     "GPRINT:$recb[$i]-mil:AVERAGE:%$g_format"
            ';
          }
        }
        if ($san2nmon) {
          $cmd .= '"PRINT:$recb[$i]-mil:AVERAGE:%$g_format $delimiter $item-nmon $delimiter $rnamelegend[$i] $delimiter $color[$color_indx % ($color_max +1)] $delimiter $rpathlegend[$i]"
          "PRINT:$recb[$i]-mil:MAX:%$g_format $delimiter"
          "GPRINT:$recb[$i++]-mil:MAX: %$g_format    "
          ';
        }
        else {
          # print STDERR "9335 \$server $server \$file $file".localtime()."\n";
          if ( $item eq 'ds-vmiops' ) {
            my $file_rrm = $file;
            $file_rrm =~ s/rrv$/rrm/;
            if ( -f "$wrkdir/vmware_VMs/$file_rrm" ) {
              $vm_dbi_uuid[$i] = $server . "_vm_" . $file;
              $vm_dbi_uuid[$i] =~ s/vmware_//;
              $vm_dbi_uuid[$i] =~ s/\..*$//g;
            }
            else {
              # these VMs files are removed after 3 months old
              # print STDERR "9351 file $file does not exist\n";
              $vm_dbi_uuid[$i] = "does_not_exist";
            }
          }
          $cmd .= '"GPRINT:$recb[$i]-mil:MAX: %$g_format    "
          ';
          if ( $item eq 'ds-vmiops' ) {

            # print STDERR "10831 \$i $i \$file_arr[$i] $file_arr[$i] $file_color_hash{$file} $file_color_hash{$file_arr[$i]}\n";
            # $cmd .= '"PRINT:$recb[$i]-mil:AVERAGE:%$g_format $delimiter $item $delimiter $rnamelegend[$i] $delimiter $color[$color_indx % ($color_max +1)]"
            # ';
            $cmd .= '"PRINT:$recb[$i]-mil:AVERAGE:%$g_format $delimiter $item $delimiter $rnamelegend[$i] $delimiter $color[$file_color_hash{$file_arr[$i]} % ($color_max +1)]"
            ';
          }
          else {
            $cmd .= '"PRINT:$recb[$i]-mil:AVERAGE:%$g_format $delimiter $item $delimiter $rnamelegend[$i] $delimiter $color[$color_indx % ($color_max +1)]"
            ';
          }
          $cmd .= '"PRINT:$recb[$i]-mil:AVERAGE:%$g_format $delimiter $rpathlegend[$i]"
          "PRINT:$recb[$i]-mil:MAX:%$g_format $delimiter $bubble_info[$i]"
          ';
          if ( $item eq 'ds-vmiops' ) {

            # print STDERR "10845 \$i $i \$file_arr[$i] $file_arr[$i] $file_color_hash{$file} $file_color_hash{$file_arr[$i]}\n";
            $cmd .= '"$gtype[$gt_ind>0]:$lnx$color[$file_color_hash{$file_arr[$i]}+1 % ($color_max +1)]: "
            ';
          }
          else {
            $cmd .= '"$gtype[$gt_ind>0]:$lnx$color[++$color_indx % ($color_max +1)]: "
            ';
          }
          $cmd .= '"GPRINT:$trab[$i]-mil:AVERAGE: %$g_format"
          ';
          if ( $item eq 'ds-vmiops' ) {    # write section
            $cmd .= '"PRINT:$trab[$i]-mil:AVERAGE:%$g_format $delimiter $color[$file_color_hash{$file_arr[$i]}+1 % ($color_max +1)]"
            ';
          }
          else {
            $cmd .= '"PRINT:$trab[$i]-mil:AVERAGE:%$g_format $delimiter $color[$color_indx % ($color_max +1)]"
            ';
          }
          $cmd .= '"PRINT:$trab[$i]-mil:MAX:%$g_format $delimiter $vm_dbi_uuid[$i]"
          "GPRINT:$trab[$i++]-mil:MAX: %$g_format    "
          ';

          # print STDERR "10827 $recb[$i]-mil:AVERAGE:%$g_format $delimiter $item $delimiter $rnamelegend[$i] $delimiter $color[$color_indx % ($color_max +1)] $delimiter $rpathlegend[$i]\n";
          #               PRINT:$recb[$i]-mil:AVERAGE:%$g_format $delimiter $item $delimiter $rnamelegend[$i] $delimiter $color[$color_indx % ($color_max +1)] $delimiter $rpathlegend[$i]"
        }
      }
      if ( $j == 0 ) {
        $cmdx .= '"LINE1:$lnx:"
                 ';
      }
      if ( $item eq "solaris_ldom_san_resp" || $item =~ m/^error/ ) {
        $cmd .= '"COMMENT:$rname[$i]"
        "$gtype[$gt_ind++>0]:$recb[$i]$color[++$color_indx % ($color_max +1)]: "
        "GPRINT:$recb[$i]-mil:AVERAGE:%$g_format"
        "GPRINT:$recb[$i]-mil:MAX: %$g_format    "
        "PRINT:$recb[$i]-mil:AVERAGE:%$g_format $delimiter $item $delimiter $rnamelegend[$i] $delimiter $color[$color_indx % ($color_max +1)] $delimiter $rpathlegend[$i] $delimiter"
        "PRINT:$recb[$i]-mil:MAX:%$g_format $delimiter $bubble_info[$i++]"
        ';
      }
      else {
        if ( $item eq 'ds-vmiops' ) {

          # print STDERR "10876 \$i $i \$j $j \$file $file \$file_color_hash{$file_arr[$j]} $file_color_hash{$file_arr[$j]}\n";
          # $cmdx .= '"$gtype[$j>0]:$trab[$j++]$color[(2*$j - 1) % ($color_max +1)]:"
          # ';
          $cmdx .= '"$gtype[$j>0]:$trab[$j]$color[$file_color_hash{$file_arr[$j++]}+1 % ($color_max +1)]:"
          ';
        }
        else {
          if ( $item eq 'clustlan' ) {
            $cmdx .= '"CDEF:$trab[$j]-tis=$trab[$j],1000,*"
            ';
            $cmdx .= '"$gtype[$j>0]:$trab[$j++]-tis$color[(2*$j - 1) % ($color_max +1)]:"
            ';
          }
          else {
            $cmdx .= '"$gtype[$j>0]:$trab[$j++]$color[(2*$j - 1) % ($color_max +1)]:"
            ';
          }
        }
      }

      #     "GPRINT:$trab[$i]-mil:AVERAGE: %$g_format"
      #     "GPRINT:$trab[$i++]-mil:MAX: %$g_format    "

      if ( $detail == 1 ) {

        #if (1 == $i % 2) {
        $cmd .= '  "$t2"
                ';    # There is remainder
                      #}
      }    #do you understand difference $i++ above and below ??
      else {
        $cmd .= '  "$t2"
                ';
      }
      $i++;
      $j++;
    }
  }
  if ( $cmd eq "" ) {

    #error( "Graph rrdtool error no valid rrd file : $item : " . __FILE__ . ":" . __LINE__ );
    $cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"
        "--title" "$header"
        "--start" "$start_time"
        "--end" "$end_time"
        "--imgformat" "PNG"
        "--slope-mode"
        "--width=$width"
        "--height=$height"
        "--step=$step_new"
        "--color=BACK#$pic_col"
        "--color=SHADEA#$pic_col"
        "--color=SHADEB#$pic_col"
        "--color=CANVAS#$pic_col"
        "--upper-limit" "$upper_limit"
        "--lower-limit" "0"
            ';

    #return 0;
  }

  if ( !$san2nmon ) {
    $cmd .= $cmdx;
  }

  if ( $detail == 1 ) {
    $cmd .= '"$t2"
      "$t"
      "HRULE:0#000000"
   );';
  }
  else {
    if ( $type =~ "d" ) {
      $cmd .= '"$t"
      "HRULE:0#000000"
     );';
    }
    else {
      $cmd .= '"HRULE:0#000000"
     );';
      $t = "";
    }
  }

  # "VRULE:0#000000" --> causing sigsegv on Linux

  # if you want to see non interpolated $cmd
  # print STDERR "6685 \$cmd $cmd\n";
  #  # if ( $item =~  /^san1/ ) {
  #     my $sss = "/var/tmp/sss.out";
  #     open (FF, ">>$sss");
  #     print FF "$cmd\n";
  #     close (FF);
  # # }

  # $i      = 0;
  # $j      = 0;
  # $k      = 0;
  # $l      = 0;
  # $ifn    = 0;
  # $gt_ind = 0;

  # if you want to see interpolated $cmd
  # care what file name is in sub alfa
  #  my $t_cmd = $cmd;
  #  $t_cmd =~ s/RRDp::cmd qq\(\$graph_cmd /alfa\(/;
  #  $t_cmd =~ s/\s\"/\n\.\"/g;
  #  eval($t_cmd);

  $i      = 0;
  $j      = 0;
  $k      = 0;
  $l      = 0;
  $ifn    = 0;
  $gt_ind = 0;
  eval $cmd;

  if ($@) {
    error( "Graph error in eval cmd : !$@! " . __FILE__ . ":" . __LINE__ );
  }
  else {
    my $answ = RRDp::read;
    if ( $$answ =~ "ERROR" ) {
      error( "$host:$server Graph rrdtool error : $$answ : " . __FILE__ . ":" . __LINE__ );
    }
    $png_end_heading = ret_graph_param( $answ, $t, $iops );
  }
  return 0;
}

sub rrd_running_days {
  my $rrd  = shift;
  my $days = shift;    #inspected time interval in days from now into the past, max 365 days

  # returns nr of days rounded up, so it is ( 1 up to $days - max is rrdtool first)
  # returns nr (1 .. 365) or text if any error
  # example of call
  #  my $nrd = rrd_running_days ($file,4);
  #
  # example of result :
  #                     recv_bytes         trans_bytes        recv_packets       trans_packets
  #
  # 1392508800: NaNQ NaNQ NaNQ NaNQ
  # 1392595200: NaNQ NaNQ NaNQ NaNQ
  # 1392681600: NaNQ NaNQ NaNQ NaNQ
  # 1392768000: 0.0000000000e+00 8.8804282407e+01 NaNQ NaNQ
  # 1392854400: NaNQ NaNQ NaNQ NaNQ
  #
  # in this case returns 2

  return "error file not existing" if !-f "$rrd";
  return "bad nr of days $days"    if ( $days < 1 || $days > 365 );

  my $ctime  = time;
  my $rrdres = 86400;
  my $daysd  = $days . "d";
  my @answer = `rrdtool fetch $rrd AVERAGE -r $rrdres -e @{[int($ctime/$rrdres)*$rrdres]} -s e-$daysd`;

  #  if ($answer[0] =~ m/rror/) { return $answer[0]; }
  for ( my $i = 2; $i < ( $days + 2 ); $i++ ) {

    # print "$i,$answer[$i]";
    ( undef, my $nan, undef ) = split( / /, $answer[$i] );
    next if ( $nan =~ m/NaN/ || $nan =~ m/nan/ );
    return ( $days - $i + 3 );
  }
  return (1);
}

sub graph_ame_mem {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t          = "COMMENT: ";
  my $t2         = "COMMENT:\\n";
  my $step_new   = $step;
  my $last       = "COMMENT: ";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  # due to historical reports where is specific time passed
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT: ";    # just a trick to place there something otherwise rrdtoll complains
    }
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_ent: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }

  my $dir        = "$wrkdir/$server/$host/$lpar/";
  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "AME: $lpar_slash_nmon :$last_txt$text";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "AME: $lpar_slash_nmon : $start_human - $end_human";
    }
  }

  # my $ds_name1 = "ame_mem";
  # my $ds_name2 = "ame_ratio";
  # my $ds_name3 = "ame_deficit";
  my $headline1      = "COMMENT:[GB]                    Avrg      Max";
  my $headline2      = "COMMENT:       ";
  my $vertical_label = "--vertical-label=Bytes";
  my $cmd            = "";
  my $act_time       = localtime();
  my $act_time_u     = time();
  my $req_time       = 0;
  my ( @recb, @trab, @rname, @rpath );

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  my $rrd = "$wrkdir/$server/$host/$lpar/ame.mmm";

  # avoid old files which do not exist in the period
  #my $rrd_upd_time = (stat("$rrd"))[9];
  #if ( $rrd_upd_time < $req_time ) {
  #  next;
  #}

  my $rrd_name = "ame.mmm";
  $rrd_name =~ s/.mmm//;

  # add spaces to rrd name to have 8 chars total (for formating graph legend)
  for ( my $k = length($rrd_name); $k < 8; $k++ ) {
    $rrd_name .= " ";
  }

  # print "001  AME_MEM  $rrd\n";

  # `echo "809: detail-graph-cgi - $rrd_name:$rrd" >> /tmp/e099`;

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\\:/g;
    $t = "COMMENT:Updated\\\: $l ";
  }

  #if ( $type =~ "y" ) {
  #   $step_new=86400;
  #}

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  #print "graphing AME_MEM  : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"
        "--title" "$header"
        "--end" "$end_time"
        "--start" "$start_time"
        "--imgformat" "PNG"
        "--slope-mode"
        "--width=$width"
        "--height=$height"
        "--step=$step_new"
        "--lower-limit=0"
        "--color=BACK#$pic_col"
        "--color=SHADEA#$pic_col"
        "--color=SHADEB#$pic_col"
        "--color=CANVAS#$pic_col"
        "--alt-autoscale-max"
        "$vertical_label"
        "--alt-y-grid"
        "$xgrid"
        "$no_legend"
        "$disable_rrdtool_tag"
        "$font_def"
        "$font_tit"
      "$headline1"
      "$t2"
';

  # for LPM
  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first

  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "ame.mmm", \@rrd_files, $cgi );

  # print STDERR "3824 $type lpm_find_files is returning @rrd_files\n";

  my $i = -1;
  my $j;

  foreach $rrd (@rrd_files) {    # LPM cycle
    chomp($rrd);
    $i++;
    $j = $i - 1;
    $rrd =~ s/:/\\:/g;

    $cmd .= " DEF:mem${i}=\"$rrd\":ame_mem:AVERAGE";
    $cmd .= " DEF:ratio_val${i}=\"$rrd\":ame_ratio:AVERAGE";
    $cmd .= " DEF:deficit${i}=\"$rrd\":ame_deficit:AVERAGE";

    if ( $i == 0 ) {
      $cmd .= " CDEF:memr${i}=mem${i}";
      $cmd .= " CDEF:ratio_valr${i}=ratio_val${i}";
      $cmd .= " CDEF:deficitr${i}=deficit${i}";
      next;
    }
    $cmd .= " CDEF:memr${i}=memr${j},UN,mem${i},memr${j},IF";
    $cmd .= " CDEF:ratio_valr${i}=ratio_valr${j},UN,ratio_val${i},ratio_valr${j},IF";
    $cmd .= " CDEF:deficitr${i}=deficitr${j},UN,deficit${i},deficitr${j},IF";
  }
  $cmd .= " CDEF:mem=memr${i}";
  $cmd .= " CDEF:ratio_val=ratio_valr${i}";
  $cmd .= " CDEF:deficit=deficitr${i}";

  # $cmd .= '"DEF:mem=$rrd:$ds_name1:AVERAGE"
  #          "DEF:ratio_val=$rrd:$ds_name2:AVERAGE"
  #          "DEF:deficit=$rrd:$ds_name3:AVERAGE"

  $cmd .= ' "CDEF:ratio=ratio_val,100,/"
          "CDEF:memg=mem,1024,/"
          "CDEF:memb=mem,1048576,*"
          "CDEF:deficitg=deficit,1024,/"
          "CDEF:deficitb=deficit,1048576,*"
         ';
  $cmd .= '"LINE1:memb#00FF00:Compressed memory"
          "GPRINT:memg:AVERAGE: %6.2lf"
          "GPRINT:memg:MAX: %6.2lf"
          "$t2"
          "LINE1:deficitb#FF0000:Deficit memory   "
          "GPRINT:deficitg:AVERAGE: %6.2lf"
          "GPRINT:deficitg:MAX: %6.2lf"
          "$t2"
          "GPRINT:ratio:AVERAGE:  Compression Ratio   %6.1lf"
          "GPRINT:ratio:MAX: %6.1lf"
          "$t2"
         ';
  $cmd .= '"$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
   );';

  # print STDERR "3882 $cmd\n/";
  #"LINE1:ratio#FF0000: "
  # in /var/tmp you can see what is generated
  #  my $ss1 = "/var/tmp/sss.out";
  #  open (FF, ">$ss1");
  #       print FF "$cmd\n";
  #  close (FF);

  # if you want to see interpolated $cmd
  # care what file name is in sub alfa
  #  my $t_cmd = $cmd;
  #  $t_cmd =~ s/RRDp::cmd qq\(graph /alfa\(/;
  #  $t_cmd =~ s/\s\"/\n\.\"/g;
  #  eval($t_cmd);

  eval $cmd;
  if ($@) {
    error( "Graph error in eval cmd : !$@! " . __FILE__ . ":" . __LINE__ );
  }
  else {
    my $answ = RRDp::read;
    if ( $$answ =~ "ERROR" ) {
      error( "$host:$server Graph rrdtool error : $$answ : " . __FILE__ . ":" . __LINE__ );
    }

    # print STDERR "3907 $$answ\n";
    $png_end_heading = ret_graph_param($answ);
  }
  return 0;
}

sub graph_lpm {
  my $host     = shift;
  my $server   = shift;
  my $lpar     = shift;
  my $type     = shift;
  my $name_out = shift;
  my $type_sam = shift;
  my $detail   = shift;
  $type_sam = "m";    # since 4.60 nothing else, no .rrd anymore
  my $step     = $ENV{SAMPLE_RATE};
  my $step_new = $step;
  my $act_time = time();
  my $lpm_suff = "rrl";

  my $xgrid = xgrid_set( $type, $detail );
  $xgrid =~ s/^--x-grid=//;    # exclude this
  my $text = text_set($type);

  #if ( $type =~ m/y/ ) {
  #  # detection of daily data source : rrm vrs rrd
  #  if ( ! -f "$wrkdir/$server/$host/IVM" && ! -f "$wrkdir/$server/$host/SDMC" ) {
  #    $type_sam = "d";
  #    $lpm_suff = "rrk";
  #  }
  #}
  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lpm: $type : $host:$server:$lpar:$type:$name_out:$type_sam " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  # LPM has been already detected in detail-cgi.pl

  my $rrd = "$wrkdir/$server/$host/$lpar.rm$type_sam";

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacemnt for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace

  lpm( "", "", "", "", "", "", "", "", $wrkdir, $name_out, $server, $host, $lpar, $lpar_slash, $text, $type_sam, $type, $step_new, $xgrid, $act_time, $pic_col, $DEBUG, $rrdtool, $lpm_suff, \@color );

  return 1;
}

sub find_human_cluster_name {

  # when cluster dir name is moref : from 4.82
  # find approprite dirname for given cluster name
  my $server_vmw_name;
  my $rrd     = "$wrkdir/$server/$host/cluster.rrc";
  my @files   = bsd_glob "$wrkdir/$server/*/cluster_name_*";
  my $rrd_res = "";
  foreach my $file (@files) {
    next if $file eq "";

    # print STDERR "4261 detail-graph-cgi.pl $file $host\n";
    next if ( index( $file, "/$host/" ) == -1 );

    # print STDERR "4263 detail-graph-cgi.pl $file $host\n";
    # example "/home/lpar2rrd/lpar2rrd/data/vmware_7f812c15-81a6-4dfe-85e3-6c9e973985f7/cluster_domain-c7/cluster_name_cluster_Cluster01 renamed"
    ( undef, $server_vmw_name ) = split( "cluster_name_cluster_", $file );
    $file =~ s/cluster_name_.*//;
    $file =~ s/.*cluster_//;

    # print STDERR "4078 $file\n";
    $rrd_res = "$wrkdir/$server/cluster_$file/cluster.rrc";
    last;
  }
  if ( !-f "$rrd" ) {
    $rrd = $rrd_res;
  }
  return ( $rrd, $server_vmw_name );
}

sub find_human_rpool_name {
  my $rpool_name = shift;
  my @files      = bsd_glob "$wrkdir/$server/$host/*.$rpool_name";
  foreach my $file (@files) {
    $rpool_name = ( split( /\//, $file ) )[-1];
    $rpool_name =~ s/\..*$//;
    last;
  }
  return $rpool_name;
}

sub graph_pool {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;

  # print STDERR "5585 \$host $host \$server $server \$lpar $lpar \$item $item \$detail $detail\n";

  my $t        = "COMMENT:\" \"";
  my $t2       = "COMMENT:\\n";
  my $step_new = $step;
  my $last     = "COMMENT:\" \"";

  #  my $in_cores = 1; # graph for vmware is in cores
  #  my $in_cores = 0; # graph for vmware is in MHz
  my $in_cores     = 2;         # graph for vmware has right axis
  my $one_core_hz  = 1000000;
  my $one_core_mhz = 1;

  #  my $vmware ;  # is global variable
  my $host_limit_total = 0;     # for clustcpu right axis

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_pool: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $rrd;
  my $max_cpu_cores = 0;        # for hyperv
  if ($hitachi) {
    $rrd = "$wrkdir/$server/$host/SYS-CPU.hrm";
  }
  elsif ($hyperv) {
    $rrd = "$wrkdir/$server/$host/$lpar.rr$type_sam";

    # print STDERR "5810 $wrkdir/$server/$host/$lpar.rr$type_sam\n";
    # find out max cores of the server from first line of cpu.html im comment
    if ( open( FR, "< $wrkdir/$server/$host/cpu.html" ) ) {
      my $firstLine = <FR>;    # example <BR><CENTER><TABLE class="tabconfig tablesorter"><!cores:8>
      close FR;
      ( undef, my $m_cpu_cores ) = split( "cores:", $firstLine );
      if ( defined $m_cpu_cores ) {
        $m_cpu_cores =~ s/>//;
        $max_cpu_cores = $m_cpu_cores;
        chomp $max_cpu_cores;
        if ( index( $max_cpu_cores, "," ) > -1 ) {
          ( $max_cpu_cores, undef ) = split( ",", $max_cpu_cores );
        }

        #print STDERR "8639 \$max_cpu_cores,$max_cpu_cores,\n";
      }
    }

  }
  elsif ( $server eq "Solaris" ) {
    $rrd = "$wrkdir/$server/$host/$lpar.mmm";
  }
  else {
    $rrd = "$wrkdir/$server/$host/$lpar.rr$type_sam";
  }
  my $server_vmw_name = "";
  my $vcenter_alias   = "vcenter_alias";

  if ( $item eq "clustcpu" or $item eq "clustser" or $item eq "clustser_power" ) {
    ( $rrd, $server_vmw_name ) = find_human_cluster_name();
    $in_cores = 0;                                                        # graph for vmware is in MHz
    $in_cores = 1 if $item eq "clustser" or $item eq "clustser_power";    # graph for vmware is in cores
  }
  if ( $item eq "multihmc" || $item eq "vcenter_power" ) {
    $in_cores = 1;
    $rrd      = "$wrkdir/$server/servers.txt";

    # print STDERR "8554 \$rrd $rrd\n";

    my $alias_file = "$wrkdir/$server/vmware_alias_name";
    if ( open( FH, "< $alias_file" ) ) {
      my $name = <FH>;
      close FH;
      chomp $name;
      ( undef, $name ) = split( /\|/, $name );
      $vcenter_alias = $name if $name ne "";
    }
  }
  if ( ( $detail < 1 || $detail == 9 ) && ( ( $item eq "clustser" ) or ( $item eq "multihmc" ) or ( $item eq "clustser_power" ) or ( $item eq "vcenter_power" ) ) ) {
    $no_legend = "--no-legend";
  }

  if ( $item eq "rpcpu" ) {
    ( undef, $server_vmw_name ) = find_human_cluster_name();
    my $rpool_name = find_human_rpool_name($lpar);
    $server_vmw_name .= ": $rpool_name";

    $rrd      = "$wrkdir/$server/$host/$lpar.rrc";
    $in_cores = 0;                                   # graph for vmware is in MHz
  }

  # print STDERR "8569 graph pool \$rrd $rrd ,$server,$lpar,$item,$type,$name_out,$type_sam,$detail,$graph_hours,$entitle,$start_unix,$end_unix,\$vmware,$vmware,\$hyperv,$hyperv,\n";
  if ( !-f "$rrd" || ( stat $rrd )[7] == 0 ) {
    error( "$rrd does not exists or 0B size for item $item " . __FILE__ . ":" . __LINE__ );
    return 0;
  }
  my $proc_limit_ghz = 0;
  my $total          = 0;
  my $res            = 0;
  my $unres          = 0;
  if ($vmware) {    # read cfg file
    if ( ( $item ne "clustcpu" ) && ( $item ne "rpcpu" ) && ( $item ne "clustser" ) && ( $item ne "clustser_power" ) && ( $item ne "multihmc" ) && ( $item ne "vcenter_power" ) ) {
      my $linepx = "";
      if ( -f "$wrkdir/$server/$host/host.cfg" ) {
        open( FR, "< $wrkdir/$server/$host/host.cfg" );
        foreach my $linep (<FR>) {
          if ( $linep =~ /CPU/ ) {
            $linepx = $linep;
            last;
          }
        }
      }
      close(FR);
      if ( $linepx =~ /CPU/ ) {
        ( undef, my $rest_line ) = split( " ", $linepx, 2 );

        # print STDERR "\$rest_line $rest_line\n";
        ( undef, $res, $unres, undef, undef, $total ) = split( " ", $rest_line );

        # print STDERR "\$res $res \$unres $unres \$total $total\n";
      }
    }
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $cpu_pool = "CPU pool";
  $cpu_pool = "CPU"        if $vmware;
  $cpu_pool = "CPU: $host" if $hyperv;    # windows server name

  my $header = "$cpu_pool :$last_txt$text";
  if ( $item =~ /pool-total/ ) {
    $header = "CPU Total:$last_txt$text";
  }
  if ( $item =~ /pool-total-max/ ) {
    $header = "CPU Total Max:$last_txt$text";
  }
  if ( $item eq "clustser_power" ) {
    $cpu_pool = "POWER";
    $header   = "$cpu_pool: $last_txt$text";
  }
  if ( $item eq "vcenter_power" ) {
    $cpu_pool = "POWER";
    $header   = "$cpu_pool: $vcenter_alias: $last_txt$text";
  }
  if ( $detail == 1 ) {
    $header = "$cpu_pool: $server :$last_txt$text";
    if ( $item eq "clustcpu" || $item eq "rpcpu" || $item eq "clustser" ) {

      # $header = "$cpu_pool: $host :$last_txt$text";
      $header = "$cpu_pool: $last_txt$text";
    }
    elsif ( $item eq "multihmc" ) {
      $header = "$cpu_pool $vcenter_alias: $last_txt$text";
    }
    elsif ($hitachi) {

      # $header = "$cpu_pool: $host :$last_txt$text";
      $header = "$cpu_pool: $host :$last_txt$text";
    }
  }

  if ( $detail == 2 ) {

    # $header = "$server :$last_txt$text";
    $header = "pool :$last_txt$text";
    if ( $item =~ /-max/ ) {
      $header = "pool :max:$last_txt$text";
    }
    if ( $item eq "clustcpu" || $item eq "rpcpu" || $item eq "clustser" || $item eq "clustser_power" ) {

      # $header = "$cpu_pool: $host :$last_txt$text";
      $header = "$cpu_pool: $last_txt$text";
    }
    elsif ( $item eq "multihmc" || $item eq "vcenter_power" ) {
      $header = "$cpu_pool $vcenter_alias: $last_txt$text";
    }
    if ($hyperv) {
      $header = "CPU pool : $last_txt$text";
    }
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$cpu_pool: $server : $start_human - $end_human";
      if ( $item eq "clustcpu" || $item eq "rpcpu" || $item eq "clustser" || $item eq "clustser_power" ) {
        $header = "$cpu_pool: $server_vmw_name : $start_human - $end_human";
      }
      elsif ( $item eq "multihmc" || $item eq "vcenter_power" ) {
        $header = "$cpu_pool $vcenter_alias: $last_txt$text";
      }
      elsif ($hitachi) {
        $header = "$cpu_pool: $host : $start_human - $end_human";
      }
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  #  if (($type =~ "d" && $graph_hours == 0 ) || ($type =~ "d" && $vmware)) left_curly
  if ( ( $item ne "multihmc" && $item ne "vcenter_power" ) && ( ( $type =~ "d" && $graph_hours == 0 ) || ($vmware) ) ) {
    my $rrd_last = $rrd;
    $rrd_last = rrd_file_actual("$rrd") if !$hyperv;    #

    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # print STDERR "5728 \$rrd_last $rrd_last \$last_tt $last_tt \$l $l\n";

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    if ( $type =~ "d" ) {
      $t = "COMMENT:Updated\\:\" $l \"";
    }

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );
        if ($vmware) {

          # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
          if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ && $m_arr[13] =~ /\d/ ) {

            #print "m : $m\n" if $DEBUG ;
            #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
            my $utiltot_mhz = 1;

            # my $one_core_hz    = 1;

            if ( ( $item eq "clustcpu" ) || ( $item eq "rpcpu" ) ) {
              $utiltot_mhz = sprintf( "%e", $m_arr[1] );
            }
            else {
              $utiltot_mhz = sprintf( "%e", $m_arr[2] );
            }
            $one_core_hz = sprintf( "%e", $m_arr[3] );

            # prepare right axis %
            if ( $item eq "rpcpu" ) {
              if ( $m_arr[13] != 0 ) {
                $proc_limit_ghz = sprintf( "%e", 100 / ( $m_arr[13] / 1000 ) );
              }
            }

            if ($in_cores) {
              my $util = sprintf( "%6.1f", $utiltot_mhz / $one_core_hz * 1000000 );
              if ( $type !~ "d" ) {next}
              $last = "COMMENT:\"Last CPU usage in cores     $util\"";
              if ( $item eq "pool-max" ) {
                $last = "COMMENT:\"Last CPU usage in cores       $util\"";
              }
              if ( $in_cores == 2 ) {
                my $utlt_mhz = sprintf( "%7.0f", $utiltot_mhz );
                my $utlt_ghz = sprintf( "%6.1f", $utiltot_mhz / 1000 );
                $last = "COMMENT:\"Last CPU usage             $util  $utlt_ghz\"";
                if ( $item eq "pool-max" ) {
                  $last = "COMMENT:\"Last CPU usage               $util   $utlt_ghz\"";
                }
              }
            }
            else {
              my $util = sprintf( "%6.2f", $utiltot_mhz / 1000 );
              $last = "COMMENT:\"Last utilization in CPU GHz   $util\"";
              if ( $item eq "pool-max" ) {
                $last = "COMMENT:\"Last utilization in CPU GHz     $util\"";
              }
            }
          }
        }
        elsif ($hyperv) {

          # print STDERR "8728 detail-graph-cgi.pl \@m_arr @m_arr\n";
          if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ ) {
            my $util = 0;

            # testing standalone
            if ( -f "$wrkdir/$server/$host/standalone" ) {

              # $cmd .= " CDEF:cpuutiltot=1,cpu_perc,cpu_time,/,-,$max_cpu_cores,*";    # to be in cores
              # print STDERR "8749 $m_arr[1] $m_arr[2] $max_cpu_cores $wrkdir/$server/$host/standalone\n";
              $util = sprintf( "%6.1f", ( 1 - ( $m_arr[1] / $m_arr[2] ) ) * $max_cpu_cores );
            }
            else {
              $util = sprintf( "%6.1f", $m_arr[1] / $m_arr[2] * $m_arr[3] / 100000 / 100 );
            }

            #$last = "COMMENT:\"Last CPU usage in cores  $util\"";
            my $right_perc = "";
            $right_perc = $util / $max_cpu_cores * 100;
            $right_perc = sprintf( "%3.1f", $right_perc );
            $last       = "COMMENT:\"Last CPU usage     $util           $right_perc\"";
          }
        }
        elsif ($hitachi) {
          if ( $m_arr[4] =~ /\d/ ) {
            my $usedp = sprintf( "%e",   $m_arr[4] );
            my $util  = sprintf( "%.2f", $usedp );
            $last = "COMMENT:\"Last CPU usage in cores  $util\"";
          }
        }
        else {
          # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
          if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ && $m_arr[4] =~ /\d/ ) {

            #print "m : $m\n" if $DEBUG ;
            #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
            my $total_pool_cycles = sprintf( "%e", $m_arr[1] );
            my $utilized_pool_cyc = sprintf( "%e", $m_arr[2] );
            my $conf_proc_units   = sprintf( "%e", $m_arr[3] );
            my $bor_proc_units    = sprintf( "%e", $m_arr[4] );
            if ( $total_pool_cycles != 0 ) {
              my $util = sprintf( "%.2f", ( $conf_proc_units + $bor_proc_units ) * ( $utilized_pool_cyc / $total_pool_cycles ) );

              #print ("\n $util $curr_proc $entitled_cycles $capped_cycles $uncapped_cycles\n");

              $last = "COMMENT:\"Last utilization in CPU cores $util\"";
              if ( $item eq "pool-max" ) {
                $last = "COMMENT:\"Last utilization in CPU cores   $util\"";
              }
            }
          }
        }
      }
    }
  }

  #  if ( $type =~ "y" ) {
  #    $step_new=86400;
  #  }

  #my $rrd_y = "";
  #if ( $type_sam =~ "y" ) left_curly
  #  # u rocnich grafu nejdrive pouzit rrm data a pokud nejsou tak teprve rrd
  #  if ( $rrd !~ m/\.rrd$/ ) {
  #    $rrd_y = $rrd;
  #    $rrd_y =~ s/\.rrm$/\.rrd/;
  #    if ( -f $rrd_y ) {
  #     $rrd = $rrd_y;
  #    }
  #}

  #print "creating graph : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;
  #  my $start_time = "now-1$type";
  if ( !( $graph_hours eq '' ) && $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label;

  if    ( $vmware && !$in_cores )                                                { $vertical_label = "--vertical-label=\"CPU usage in GHz\""; }
  elsif ( $vmware && ( $item eq "clustser_power" || $item eq "vcenter_power" ) ) { $vertical_label = "--vertical-label=\"kWatt\""; }
  elsif ($hitachi)                                                               { $vertical_label = "--vertical-label=\"CPU usage %\""; }
  elsif ( $item eq "solaris_pool" )                                              { $vertical_label = "--vertical-label=\"Usage\""; }
  else                                                                           { $vertical_label = "--vertical-label=\"CPU cores\""; }

  #$vertical_label="--vertical-label=\"CPU usage in %\"" if -f "$wrkdir/$server/$host/hyperv.txt";

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  $rrd =~ s/:/\\:/g;
  my $cmd = "";

  $cmd .= "$graph_cmd \"$name_out\"";
  if ( $in_cores == 2 && $vmware ) {

    #  $cmd .= " --right-axis-label \"CPU usage in MHz\"";
    $one_core_mhz = int( $one_core_hz / 1000000 );
    my $one_core_ghz = $one_core_hz / 1000000000;
    if ($yes_right_axis) {
      $cmd .= " --right-axis $one_core_ghz:0";
      $cmd .= " --right-axis-format %1.1lf";
    }
  }

  if ( $item eq "rpcpu" && $proc_limit_ghz != 0 ) {    # right axis limit
    $cmd .= " --right-axis $proc_limit_ghz:0";
    $cmd .= " --right-axis-format %3.0lf";
  }

  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $xgrid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";

  my $file_pth = "$wrkdir/$server/*/$lpar.rr$type_sam";

  if ($vmware) {

    if ( $item eq "clustcpu" ) {

      # for Total MHz create sum of all ESXi CPU pool Total MHz (CPU_Alloc) in this cluster
      my $hosts_in_cluster = $rrd;
      $hosts_in_cluster =~ s/cluster.rrc/hosts_in_cluster/;
      open( FF, "<$hosts_in_cluster" ) || error( "can't open $hosts_in_cluster: $! :" . __FILE__ . ":" . __LINE__ ) && return;
      my @hosts = (<FF>);
      close(FF);

      # print STDERR "5260 \@hosts @hosts\n"; # e.g. 10.22.11.8XORUX10.22.11.10

      # for cluster right axis as percentage there is a need to have CPU host limit summ before (not enough from rrd files during graphing)
      # it is in file like '/home/lpar2rrd/lpar2rrd/data/10.22.111.2/10.22.111.4/host.cfg'
      # InfO maxUsage reservationUsed unreservedForPool reservationUsedForVm unreservedForVm cpu_res cpu_shares hw_numCpuThreads host_limit
      # CPU 107826 1024 106802 1024 106802 64656 4096000 48 64656
      #
      # my $host_limit_total = 0; #global for the whole sub

      my $i       = 0;
      my $rpn_sum = "";
      foreach my $one_host (@hosts) {
        chomp $one_host;
        ( my $host, my $cluster ) = split( "XORUX", $one_host );

        # print STDERR " testing $wrkdir/$host/$cluster/pool.rrm\n";
        if ( -f "$wrkdir/$host/$cluster/pool.rrm" ) {
          $cluster =~ s/:/\\:/;    # if there is port
                                   #          $cmd .= " DEF:hosts_cpux${i}=\"$wrkdir/$host/$cluster/pool.rrm\":CPU_Alloc:AVERAGE";
          $cmd .= " DEF:hosts_cpu${i}=\"$wrkdir/$host/$cluster/pool.rrm\":CPU_Alloc:AVERAGE";

          #          $cmd .= " CDEF:hosts_cpu${i}=hosts_cpux${i},UN,0,hosts_cpux${i},IF";
          if ( $i == 0 ) {
            $rpn_sum = "hosts_cpu0";
          }
          else {
            $rpn_sum .= ",hosts_cpu${i},+";
          }
          $i++;

          # for host limit
          my $host_limit_file = "$wrkdir/$host/$cluster/host.cfg";
          next if !-f $host_limit_file;
          open( my $ff, "<$host_limit_file" ) || error( "can't open $host_limit_file: $! :" . __FILE__ . ":" . __LINE__ ) && next;
          my @host_info = (<$ff>);
          close($ff);
          chomp @host_info;

          # print STDERR "10197 \@host_info @host_info\n";
          # get index of 'host_limit'
          my @names      = split( " ", $host_info[0] );
          my ($index)    = grep { $names[$_] eq 'host_limit' } ( 0 .. @names - 1 );
          my $host_limit = ( split( " ", $host_info[1] ) )[$index];

          #print STDERR "10203 \$host_limit $host_limit\n";
          $host_limit_total += $host_limit;

        }

      }
      $i > 0 || error( "Cluster has no ESXi servers in $hosts_in_cluster: $! :" . __FILE__ . ":" . __LINE__ ) && return;

      $host_limit_total = $host_limit_total / 1000;    # for GHz

      # print STDERR "5279 \$rpn_sum $rpn_sum\n";
      $cmd .= " CDEF:hosts_cpu=$rpn_sum,1000,/";
      $cmd .= " DEF:cpu_MHz=\"$rrd\":CPU_total_MHz:AVERAGE";
      $cmd .= " CDEF:cpu=cpu_MHz,1000,/";
      $cmd .= " DEF:cpuutiltot_MHz=\"$rrd\":CPU_usage_MHz:AVERAGE";
      $cmd .= " CDEF:cpuutiltot=cpuutiltot_MHz,1000,/";
      if ( $yes_right_axis && ( $host_limit_total > 0 ) ) {
        $cmd .= " COMMENT:\"   GHz                          Avg      Max      Avg \%(right axis)\\n\"";
      }
      else {
        $cmd .= " COMMENT:\"   GHz                          Avg      Max\\n\"";
      }
    }

    elsif ( $item eq "clustser" or $item eq "clustser_power" or $item eq "multihmc" or $item eq "vcenter_power" ) {

      # for Total cores create sum of all ESXi CPU pool (CPU_Alloc) in this cluster
      my $hosts_in_cluster = $rrd;
      $hosts_in_cluster =~ s/cluster.rrc/hosts_in_cluster/ if $item eq "clustser" or $item eq "clustser_power";
      $hosts_in_cluster = "$wrkdir/$server/servers.txt"    if $item eq "multihmc" or $item eq "vcenter_power";
      open( FF, "<$hosts_in_cluster" ) || error( "can't open $hosts_in_cluster: $! :" . __FILE__ . ":" . __LINE__ ) && return;
      my @hosts = (<FF>);
      close(FF);

      # print STDERR "8934 \@hosts @hosts\n"; # e.g. 10.22.11.8XORUX10.22.11.10
      my $i                       = 0;
      my $rpn_sum                 = "";
      my $gtype                   = "AREA";
      my $color_indx              = 0;
      my $local_host              = "";
      my $managedname             = "";
      my $managed_ok              = "";
      my $managed_systems_exclude = "";
      my $j                       = 0;
      my $managedname_exl         = "";
      my @m_excl                  = "";
      my $cmdq                    = "";
      $in_cores = 0;

      foreach my $one_host (@hosts) {
        chomp $one_host;
        ( my $host, my $cluster ) = split( "XORUX", $one_host );

        # print STDERR "8941 testing $wrkdir/$host/$cluster/pool.rrm\n";
        if ( -f "$wrkdir/$host/$cluster/pool.rrm" ) {
          $cluster =~ s/:/\\:/;    # if there is port
          my $line       = $host;
          my $local_host = $cluster;

          # ($managedname, my $model, my $serial) = split(/,/,$line);
          $managedname = $line;

          $managed_ok = 1;
          if ( $managed_systems_exclude ne '' ) {
            @m_excl = split( /:/, $managed_systems_exclude );
            foreach $managedname_exl (@m_excl) {
              chomp($managedname_exl);
              if ( $managedname =~ m/^$managedname_exl$/ ) {
                $managed_ok = 0;
              }
            }
          }
          if ( $managed_ok == 0 ) {
            next;
          }

          my $file = "pool.rrm";

          # avoid old servers which do not exist in the period
          #my $rrd_upd_time = ( stat("$wrkdir/$managedname/$local_host/$file") )[9];
          #if ( $rrd_upd_time < $req_time ) {
          #  next;
          #}

          my $managedname_space      = $managedname;
          my $managedname_space_proc = $managedname;
          $managedname_space_proc =~ s/:/\\:/g;
          $managedname_space_proc =~ s/%/%%/g;    # anti '%

          for ( my $k = length($managedname); $k < 35; $k++ ) {
            $managedname_space .= " ";
          }
          $managedname_space = substr( $managedname_space, 0, 34 );    # not longer

          $managedname_space =~ s/:/\\:/g;                             # anti ':'
          my $wrkdir_managedname_host_file = "$wrkdir/$managedname/$local_host/$file";

          # print "2 creating CMD for $wrkdir_managedname_host_file\n" if $DEBUG ;

          $wrkdir_managedname_host_file =~ s/:/\\:/g;
          my $wrkdir_managedname_host_file_legend = $wrkdir_managedname_host_file;
          $wrkdir_managedname_host_file_legend =~ s/%/%%/g;

          # my in_cores = 1;
          # bulid RRDTool cmd
          if ( $item eq "clustser_power" || $item eq "vcenter_power" ) {
            $cmd .= " DEF:power_usage_watt${i}=\\\"$wrkdir_managedname_host_file\\\":Power_usage_Watt:AVERAGE";
            $cmd .= " CDEF:power_usage_kwatt${i}=power_usage_watt${i},1000,/";
            $cmd .= " CDEF:ncpu${i}=power_usage_kwatt${i}";

            # if it does not exist for some time period then put 0 there
            $cmd .= " CDEF:cpu${i}=ncpu${i},UN,0,ncpu${i},IF";

            $cmd .= " PRINT:power_usage_kwatt${i}:AVERAGE:\"%6.2lf $delimiter multihmcframepower $delimiter $managedname_space_proc $delimiter $color[$color_indx]\"";
            $cmd .= " PRINT:power_usage_kwatt${i}:MAX:\" %6.2lf $delimiter $wrkdir_managedname_host_file_legend\"";

            $cmdq .= " $gtype:power_usage_kwatt${i}$color[$color_indx++]:\\\"$managedname_space\\\"";
            $cmdq .= " GPRINT:power_usage_kwatt${i}:AVERAGE:\\\"%6.2lf \\\"";
            $cmdq .= " GPRINT:power_usage_kwatt${i}:MAX:\\\"%6.2lf \\l\\\"";

          }
          else {
            $cmd .= " DEF:cpu_entitl_mhz${i}=\\\"$wrkdir_managedname_host_file\\\":CPU_Alloc:AVERAGE";
            $cmd .= " DEF:utiltot_mhz${i}=\\\"$wrkdir_managedname_host_file\\\":CPU_usage:AVERAGE";
            $cmd .= " DEF:one_core_hz${i}=\\\"$wrkdir_managedname_host_file\\\":host_hz:AVERAGE";

            #    $cmd .= " COMMENT:\"   Average                   cores      Ghz (right axis)\\n\"";
            #    if ($in_cores) left curly
            $cmd .= " CDEF:cpuutiltot${i}=utiltot_mhz${i},one_core_hz${i},/,1000000,*";
            $cmd .= " CDEF:ncpu${i}=cpu_entitl_mhz${i},one_core_hz${i},/,1000000,*";
            $cmd .= " CDEF:cpu_entitl_ghz${i}=cpu_entitl_mhz${i},1000,/";
            $cmd .= " CDEF:utiltot_ghz${i}=utiltot_mhz${i},1000,/";

            # if it does not exist for some time period then put 0 there
            $cmd .= " CDEF:cpu${i}=ncpu${i},UN,0,ncpu${i},IF";

            $cmd .= " PRINT:cpuutiltot${i}:AVERAGE:\"%6.2lf $delimiter multihmcframe $delimiter $managedname_space_proc $delimiter $color[$color_indx]\"";
            $cmd .= " PRINT:cpuutiltot${i}:MAX:\" %6.2lf $delimiter $wrkdir_managedname_host_file_legend\"";

            $cmdq .= " $gtype:cpuutiltot${i}$color[$color_indx++]:\\\"$managedname_space\\\"";
            $cmdq .= " GPRINT:cpuutiltot${i}:AVERAGE:\\\"%6.2lf \\\"";
            $cmdq .= " GPRINT:cpuutiltot${i}:MAX:\\\"%6.2lf \\l\\\"";
          }
          $gtype = "STACK";
          $i++;
          if ( $color_indx > $color_max ) {
            $color_indx = 0;
          }
        }
      }

      # add count of all CPU in pools
      for ( $j = 0; $j < $i; $j++ ) {
        if ( $j == 0 ) {
          $cmd .= " CDEF:tcpu${j}=cpu${j}";
        }
        else {
          my $k = $j - 1;

          #      $cmd .= " CDEF:tcpu_tmp${j}=cpu${j},cpubor${j},+";
          $cmd .= " CDEF:tcpu${j}=tcpu${k},cpu${j},+";
        }
      }
      if ( $j > 0 ) {
        $j--;
      }
      my $cpu_pool_total = "CPUs total available in pools";
      $cpu_pool_total = "Total" if $item eq "clustser_power" || $item eq "vcenter_power";
      for ( my $k = length($cpu_pool_total); $k < 35; $k++ ) {
        $cpu_pool_total .= " ";
      }
      $cmd .= " CDEF:tcpun${j}=tcpu${j},0,EQ,UNKN,tcpu${j},IF";
      $cmd .= " LINE2:tcpun${j}#888888:\\\"$cpu_pool_total\\\"" if $item ne "clustser_power" && $item ne "vcenter_power";

      #$cmd .= " GPRINT:tcpu${j}:AVERAGE:\\\"%6.2lf \\\"";
      # excluded as it is a bit misleading there there is any even small data gap
      $cmd .= " GPRINT:tcpun${j}:MAX:\\\"         %6.2lf \\l\\\"" if $item ne "clustser_power" && $item ne "vcenter_power";
      $cmd .= $cmdq;
      $cmd .= " PRINT:tcpun${j}:MAX:\\\"         %6.2lf MAXTCPU $delimiter\\\"";

      #      $cmd .= " HRULE:0#000000";

      # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
    }
    elsif ( $item eq "rpcpu" ) {
      $cmd .= " DEF:cpuutiltot_MHz=\"$rrd\":CPU_usage_MHz:AVERAGE";
      $cmd .= " CDEF:cpuutiltot=cpuutiltot_MHz,1000,/";
      $cmd .= " DEF:cpu_limit_MHz=\"$rrd\":CPU_limit:AVERAGE";
      $cmd .= " CDEF:cpu_limit=cpu_limit_MHz,1000,/";
      $cmd .= " DEF:cpu_reservation_MHz=\"$rrd\":CPU_reservation:AVERAGE";
      $cmd .= " CDEF:cpu_reservation=cpu_reservation_MHz,1000,/";
      if ( $proc_limit_ghz != 0 ) {
        $cmd .= " COMMENT:\"   GHz                           Avg      Max  (right axis = % of Limit)\\n\"";
      }
      else {
        $cmd .= " COMMENT:\"   GHz                           Avg      Max\\n\"";
      }
    }

    else {
      my ( $result_cmd, $CPU_Alloc, $CPU_usage, $host_hz ) = LPM_easy( "AVERAGE", $file_pth, "0", "0", "CPU_Alloc", "CPU_usage", "host_hz" );

      $cmd .= $result_cmd;

      # print STDERR "12666 \$result_cmd $result_cmd\n \$CPU_Alloc $CPU_Alloc \$CPU_usage $CPU_usage \$host_hz $host_hz\n";
      $cmd .= " CDEF:cpu_entitl_mhz=$CPU_Alloc";
      $cmd .= " CDEF:utiltot_mhz=$CPU_usage";
      $cmd .= " CDEF:one_core_hz=$host_hz";
      $cmd .= " COMMENT:\"   Average                   cores      Ghz (right axis)\\n\"";
    }

    if ($in_cores) {
      $cmd .= " CDEF:cpuutiltot=utiltot_mhz,one_core_hz,/,1000000,*";
      $cmd .= " CDEF:cpu=cpu_entitl_mhz,one_core_hz,/,1000000,*";
      $cmd .= " CDEF:cpu_entitl_ghz=cpu_entitl_mhz,1000,/";
      $cmd .= " CDEF:utiltot_ghz=utiltot_mhz,1000,/";

      #         $cmd .= " CDEF:reserved=cpu,POP,$res,one_core_hz,/,1000000,*";
      #         $cmd .= " AREA:reserved#00FF00:\" Reserved for VM          \"";
      #         $cmd .= " GPRINT:reserved:AVERAGE:\" %2.1lf\"";
      #         $cmd .= " CDEF:reserve=cpu,POP,$res,1,*";
      #         $cmd .= " GPRINT:reserve:AVERAGE:\" %6.0lf\"";
      #         $cmd .= " $t2";
      #         $cmd .= " CDEF:unreserved=cpu,POP,$unres,one_core_hz,/,1000000,*";
      #         $cmd .= " STACK:unreserved#FFFF00:\" Unreserved               \"";
      #         $cmd .= " GPRINT:unreserved:AVERAGE:\" %2.1lf\"";
      #         $cmd .= " CDEF:unreserve=cpu,POP,$unres,1,*";
      #         $cmd .= " GPRINT:unreserve:AVERAGE:\" %6.0lf\"";
      #         $cmd .= " $t2";
      my $system = $total - $res - $unres;

      #         $cmd .= " CDEF:system=cpu,POP,$system,one_core_hz,/,1000000,*";
      #         $cmd .= " STACK:system#0080FF:\" System                   \"";
      #         $cmd .= " GPRINT:system:AVERAGE:\" %2.1lf\"";
      #         $cmd .= " CDEF:syste=cpu,POP,$system,1,*";
      #         $cmd .= " GPRINT:syste:AVERAGE:\" %6.0lf\"";
      #         $cmd .= " $t2";
      my $form_dec = "%6.1lf";
      $cmd .= " AREA:cpu$pastel_green:\" Total                 \"";
      $cmd .= " GPRINT:cpu:AVERAGE:\"$form_dec\"";
      $cmd .= " GPRINT:cpu_entitl_ghz:AVERAGE:\"$form_dec\"";
      $cmd .= " $t2";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization           \"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\"$form_dec\"";
      $cmd .= " GPRINT:utiltot_ghz:AVERAGE:\"$form_dec\"";
      $cmd .= " $t2";
    }
    else {
      if ( $item eq "rpcpu" ) {
        $cmd .= " AREA:cpu_reservation#00FF00:\" Reservation             \"";
        $cmd .= " GPRINT:cpu_reservation:AVERAGE:\" %6.1lf\"";
        $cmd .= " GPRINT:cpu_reservation:MAX:\" %6.1lf\"";
        $cmd .= " $t2";
        $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization             \"";
        $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %6.1lf\"";
        $cmd .= " GPRINT:cpuutiltot:MAX:\" %6.1lf\"";
        $cmd .= " $t2";
        $cmd .= " LINE1:cpu_limit#000000:\" Limit                   \"";
        $cmd .= " GPRINT:cpu_limit:AVERAGE:\" %6.1lf\"";
        $cmd .= " GPRINT:cpu_limit:MAX:\" %6.1lf\"";
        $cmd .= " $t2";
      }
      elsif ( $item eq "clustcpu" ) {

        if ( $yes_right_axis && ( $host_limit_total > 0 ) ) {
          my $ratio = 100 / $host_limit_total;

          # print STDERR "10441 \$ratio $ratio \$host_limit_total $host_limit_total\n";
          $cmd .= " --right-axis $ratio:0";
          $cmd .= " --right-axis-format %1.0lf";

          # $cmd .= " --right-axis-label %"; #looks awful

          $cmd .= " LINE1:hosts_cpu#000000:\" Total                   \"";
          $cmd .= " GPRINT:hosts_cpu:AVERAGE:\" %6.1lf\"";
          $cmd .= " GPRINT:hosts_cpu:MAX:\" %6.1lf\"";
          $cmd .= " CDEF:hosts_cpu_proc=hosts_cpu,$ratio,*";
          $cmd .= " GPRINT:hosts_cpu_proc:AVERAGE:\" %6.1lf\"";
          $cmd .= " $t2";
          $cmd .= " AREA:cpu$pastel_green:\" Total effective         \"";
          $cmd .= " GPRINT:cpu:AVERAGE:\" %6.1lf\"";
          $cmd .= " GPRINT:cpu:MAX:\" %6.1lf\"";
          $cmd .= " CDEF:cpu_proc=cpu,$ratio,*";
          $cmd .= " GPRINT:cpu_proc:AVERAGE:\" %6.1lf\"";
          $cmd .= " $t2";
          $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization             \"";
          $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %6.1lf\"";
          $cmd .= " GPRINT:cpuutiltot:MAX:\" %6.1lf\"";
          $cmd .= " CDEF:cpuutiltot_proc=cpuutiltot,$ratio,*";
          $cmd .= " GPRINT:cpuutiltot_proc:AVERAGE:\" %6.1lf\"";
          $cmd .= " $t2";

        }
        else {
          $cmd .= " LINE1:hosts_cpu#000000:\" Total                   \"";
          $cmd .= " GPRINT:hosts_cpu:AVERAGE:\" %6.1lf\"";
          $cmd .= " GPRINT:hosts_cpu:MAX:\" %6.1lf\"";
          $cmd .= " $t2";
          $cmd .= " AREA:cpu$pastel_green:\" Total effective         \"";
          $cmd .= " GPRINT:cpu:AVERAGE:\" %6.1lf\"";
          $cmd .= " GPRINT:cpu:MAX:\" %6.1lf\"";
          $cmd .= " $t2";
          $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization             \"";
          $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %6.1lf\"";
          $cmd .= " GPRINT:cpuutiltot:MAX:\" %6.1lf\"";
          $cmd .= " $t2";
        }
      }
      elsif ( $item eq "clustser" or $item eq "multihmc" or $item eq "clustser_power" or $item eq "vcenter_power" ) {
      }
      else {
        $cmd .= " AREA:cpu#00FF00:\" Total                   \"";
        $cmd .= " GPRINT:cpu:AVERAGE:\" %6.1lf\"";
        $cmd .= " GPRINT:cpu:MAX:\" %6.1lf\"";
        $cmd .= " $t2";
        $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization             \"";
        $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %6.1lf\"";
        $cmd .= " GPRINT:cpuutiltot:MAX:\" %6.1lf\"";
        $cmd .= " $t2";
      }
    }
  }
  elsif ($hitachi) {
    $cmd .= " --upper-limit=100";
    $cmd .= " DEF:cpu_usedp=\"$rrd\":cpu_usedp:AVERAGE";
    $cmd .= " COMMENT:\"[%]                      Avrg\\n\"";
    $cmd .= " LINE1:cpu_usedp#FF0000:\" Usage           \"";
    $cmd .= " GPRINT:cpu_usedp:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
  }
  elsif ( $item eq "solaris_pool" ) {
    $cmd .= " DEF:size_c=\"$rrd\":size_in_cores:AVERAGE";
    $cmd .= " DEF:used_s=\"$rrd\":used:AVERAGE";
    $cmd .= " COMMENT:\"                       Avrg\\n\"";
    $cmd .= " COMMENT:\"Average   \\n\"";
    $cmd .= " AREA:size_c#00FF00:\" Size CPU      \"";
    $cmd .= " GPRINT:size_c:AVERAGE:\"    %3.1lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:used_s#FF0000:\" Used CPU   \"";
    $cmd .= " GPRINT:used_s:AVERAGE:\"       %3.2lf\"";
    $cmd .= " $t2";
  }
  else {
    #       my $file_pth = "$wrkdir/$server/*/$lpar.rr$type_sam";

    my ( $result_cmd, $total_pool_cycles, $utilized_pool_cyc, $conf_proc_units, $bor_proc_units ) = LPM_easy( "AVERAGE", $file_pth, "0", "0", "total_pool_cycles", "utilized_pool_cyc", "conf_proc_units", "bor_proc_units" );

    if ( $item eq "pool-max" || $item eq "pool-total-max" ) {
      my $file_pth_max = "$wrkdir/$server/*/$lpar.xr$type_sam";

      my ( $result_cmd_max, $total_pool_cycles_max, $utilized_pool_cyc_max, $conf_proc_units_max, $bor_proc_units_max ) = LPM_easy( "MAX", $file_pth_max, "0", "0", "total_pool_cycles", "utilized_pool_cyc", "conf_proc_units", "bor_proc_units" );

      # prepare DEF|CDEF for max
      $total_pool_cycles_max =~ s/var/varmax/g;
      $utilized_pool_cyc_max =~ s/var/varmax/g;
      $conf_proc_units_max   =~ s/var/varmax/g;
      $bor_proc_units_max    =~ s/var/varmax/g;

      my $result_to_parse = $result_cmd_max;
      $result_to_parse =~ s/^\s+//g;
      $result_to_parse =~ s/\s+$//g;
      $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

      my @result_cmd_lines = split( "\n", $result_to_parse );
      my $result_cmd_max_new;

      foreach my $cmd_line (@result_cmd_lines) {
        chomp $cmd_line;

        #print "$cmd_line\n";
        $cmd_line =~ s/^\s+//g;
        $cmd_line =~ s/\s+$//g;

        my $line_max = $cmd_line;

        if ( $cmd_line =~ "^DEF:" ) {
          $line_max =~ s/^DEF:var/DEF:varmax/;
          $line_max =~ s/:AVERAGE$/:MAX/;
        }
        if ( $cmd_line =~ "^CDEF:" ) {
          $line_max =~ s/var/varmax/g;
        }

        $result_cmd_max_new .= " $line_max";
      }

      $cmd .= $result_cmd_max_new;
      $cmd .= " CDEF:totcyc_max=$total_pool_cycles_max";
      $cmd .= " CDEF:uticyc_max=$utilized_pool_cyc_max";
      $cmd .= " CDEF:cpu_max=$conf_proc_units_max";
      $cmd .= " CDEF:cpubor_max=$bor_proc_units_max";

      $cmd .= " CDEF:totcpu_max=cpu_max,cpubor_max,+";
      $cmd .= " CDEF:fail_max=uticyc_max,totcyc_max,GT,1,0,IF";
      $cmd .= " CDEF:cpuutil_max=uticyc_max,totcyc_max,GT,UNKN,uticyc_max,totcyc_max,/,IF";
      $cmd .= " CDEF:cpuutiltot_max=cpuutil_max,totcpu_max,*";
      $cmd .= " CDEF:utilisa_max=cpuutil_max,100,*";

      $cmd .= $result_cmd;
      $cmd .= " CDEF:totcyc=$total_pool_cycles";
      $cmd .= " CDEF:uticyc=$utilized_pool_cyc";
      $cmd .= " CDEF:cpu=$conf_proc_units";
      $cmd .= " CDEF:cpubor=$bor_proc_units";

      $cmd .= " CDEF:totcpu=cpu,cpubor,+";
      $cmd .= " CDEF:fail=uticyc,totcyc,GT,1,0,IF";
      $cmd .= " CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF";
      $cmd .= " CDEF:cpuutiltot=cpuutil,totcpu,*";
      $cmd .= " CDEF:utilisa=cpuutil,100,*";

      $cmd .= " COMMENT:\"Average [CPU cores]\\n\"";
      if ( defined $ENV{DEMO} && $ENV{DEMO} && $item =~ /pool-total/ ) {
        $cmd .= " LINE2:32#777777:\" Configured\"";
      }

      if ( !( defined $ENV{DEMO} && $ENV{DEMO} && $item =~ /pool-total/ ) ) {
        $cmd .= " AREA:cpu$pastel_green:\" Configured   \"";
      }
      $cmd .= " GPRINT:cpu:AVERAGE:\" %3.1lf\"";
      $cmd .= " $t2";
      if ( !( defined $ENV{DEMO} && $ENV{DEMO} && $item =~ /pool-total/ ) ) {
        $cmd .= " STACK:cpubor$pastel_yellow:\" Not assigned \"";
        $cmd .= " GPRINT:cpubor:AVERAGE:\" %3.1lf\"";
        $cmd .= " $t2";
      }
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization  \"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %3.2lf\"";
      $cmd .= " COMMENT:(";
      $cmd .= " GPRINT:utilisa:AVERAGE:\" %2.1lf\"";
      $cmd .= " COMMENT:\%)";
      $cmd .= " $t2";
      if ( $graph_cmd =~ m/graphv$/ ) {
        $cmd .= " LINE1:cpuutiltot_max#0088FF:\" Maximum peaks\":dashes=1,2";
      }
      else {
        # RRDTool 1.2.x does not support dashed lines
        $cmd .= " LINE1:cpuutiltot_max#0088FF:\" Maximum peaks\"";
      }
      $cmd .= " GPRINT:cpuutiltot_max:MAX:\" %3.2lf\"";
      $cmd .= " $t2";

    }

    elsif ($hyperv) {

      # print STDERR "6181 detail-graph-cgi.pl pool hyperv \$rrd $rrd\n";
      $cmd .= " DEF:cpu_perc=\"$rrd\":PercentTotalRunTime:AVERAGE";
      $cmd .= " DEF:cpu_time=\"$rrd\":Timestamp_PerfTime:AVERAGE";
      $cmd .= " DEF:cpu_freq=\"$rrd\":Frequency_PerfTime:AVERAGE";

      # testing standalone
      if ( -f "$wrkdir/$server/$host/standalone" ) {

        # print STDERR "11627 testing standalone $wrkdir/$server/$host/standalone\n";
        $cmd .= " CDEF:cpuutiltot=1,cpu_perc,cpu_time,/,-,$max_cpu_cores,*";    # to be in cores
      }
      else {
        #$cmd .= " CDEF:cpuutiltot=cpu_perc,cpu_time,/,cpu_freq,*,100000,/,100,/,$max_cpu_cores,*";    # to be in cores
        $cmd .= " CDEF:cpuutiltot=cpu_perc,cpu_time,/,cpu_freq,*,100000,/,100,/";    # to be in cores
      }

      #         $cmd .= " COMMENT:\"   Average   \\n\"";
      #         $cmd .= " AREA:cpu#00FF00:\" Configured CPU cores    \"";
      #         $cmd .= " GPRINT:cpu:AVERAGE:\" %3.1lf\"";
      #         $cmd .= " $t2";
      #         $cmd .= " STACK:cpubor#FFFF00:\" Not assigned CPU cores  \"";
      #         $cmd .= " GPRINT:cpubor:AVERAGE:\" %3.1lf\"";
      #         $cmd .= " $t2";

      my $ratio = 100 / $max_cpu_cores;
      if ( $in_cores == 2 ) {
        if ($yes_right_axis) {

          #$max_cpu_cores = 2;
          $cmd .= " --right-axis $ratio:0";

          #$cmd .= " --right-axis-label \"percent \%\"";
          $cmd .= " --right-axis-format %1.0lf";
        }
      }

      #$cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization in cores\"";
      $cmd .= " COMMENT:\"                     Cores          Avg\%(right axis)\"";
      $cmd .= " $t2";

      #$cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization\"";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization    \"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %3.1lf\"";
      $cmd .= " CDEF:cpuutiltotperc=cpuutiltot,$max_cpu_cores,/,100,*";
      $cmd .= " GPRINT:cpuutiltotperc:AVERAGE:\"         %3.1lf\"";

      #$cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %3.2lf\"";
      $cmd .= " $t2";
      $cmd .= " COMMENT:\"Max cpu cores           $max_cpu_cores\"";
      $cmd .= " $t2";
    }
    else {
      $cmd .= $result_cmd;
      $cmd .= " CDEF:totcyc=$total_pool_cycles";
      $cmd .= " CDEF:uticyc=$utilized_pool_cyc";
      $cmd .= " CDEF:cpu=$conf_proc_units";
      $cmd .= " CDEF:cpubor=$bor_proc_units";

      $cmd .= " CDEF:totcpu=cpu,cpubor,+";
      $cmd .= " CDEF:fail=uticyc,totcyc,GT,1,0,IF";
      $cmd .= " CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF";
      $cmd .= " CDEF:cpuutiltot=cpuutil,totcpu,*";
      $cmd .= " CDEF:utilisa=cpuutil,100,*";

      $cmd .= " COMMENT:\"Average [CPU cores]  \\n\"";

=begin
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization   \"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %3.2lf\"";
      $cmd .= " COMMENT:(";
      $cmd .= " GPRINT:utilisa:AVERAGE:\" %2.1lf\"";
      $cmd .= " COMMENT:\%)";
      $cmd .= " $t2";
=cut

      if ( defined $ENV{DEMO} && $ENV{DEMO} && $item =~ /pool-total/ ) {

      }
      else {
        $cmd .= " AREA:cpu$pastel_green:\" Configured    \"";
      }
      if ( defined $ENV{DEMO} && $ENV{DEMO} && $item =~ /pool-total/ ) {
        $cmd .= " LINE2:32#777777:\" Configured \"";
      }
      $cmd .= " GPRINT:cpu:AVERAGE:\" %3.1lf\"";
      $cmd .= " $t2";
      if ( !( defined $ENV{DEMO} && $ENV{DEMO} && $item =~ /pool-total/ ) ) {
        $cmd .= " STACK:cpubor$pastel_yellow:\" Not assigned  \"";
        $cmd .= " GPRINT:cpubor:AVERAGE:\" %3.1lf\"";
        $cmd .= " $t2";
      }
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization   \"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\" %3.2lf\"";
      $cmd .= " COMMENT:(";
      $cmd .= " GPRINT:utilisa:AVERAGE:\" %2.1lf\"";
      $cmd .= " COMMENT:\%)";
      $cmd .= " $t2";
    }
  }

  #$cmd .= " $last";
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  $cmd =~ s/\\"/"/g;

  # print STDERR "001 $cmd\n";

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

# Note!!
# this function is defined in detail-graph-cgi.pl as LPM_easy and in XoruxEdition.pm as LPM_easy_premium
# when you make any change then replicate it in both files!!
#

sub LPM_easy {

  # this is for case e.g. HMC change, similar to LPM
  # join data streams from rrd files in one data_stream
  # call:
  #  my ($result_cmd,$result_stream_1,...,$result_stream_x) = LPM_easy($path_to_find_files,$var_indx,$req_time,$data_stream_1,...,$data_stream_x);
  # no limit for x
  # $result_cmd is CMD string for RRD
  my $cf       = shift;
  my $file_pth = shift @_;    # path to find files
  my $var_indx = shift @_;    # to make variables unique in aggregated graphs
  my $req_time = shift @_;    # only files with newer timestamp are taken into consideration
  $file_pth =~ s/ /\\ /g;
  my $no_name = "";

  my @files    = (<$file_pth$no_name>);    # unsorted, workaround for space in names
                                           # print STDERR "found pool files: @files\n";
  my @ds       = @_;
  my $item_uid = "";

  #print STDERR "000 in sub LPM_easy \@ds @ds\n";

  # prepare help variables
  my $prep_names = "";
  for ( my $x = 0; $x < @ds; $x++ ) { $prep_names .= "var" . $var_indx . $x . "," }
  my @ids = split( ",", "$prep_names" );
  $prep_names = "";
  for ( my $x = 0; $x < @ds; $x++ ) { $prep_names .= "var_r" . $var_indx . $x . "," }
  my @rids = split( ",", "$prep_names" );

  my $i = -1;
  my $j;
  my $rrd = "";
  my $cmd = "";

  foreach my $rrd (@files) {    # LPM alias cycle
    chomp($rrd);
    if ( $req_time > 0 ) {
      my $rrd_upd_time = ( stat("$rrd") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
    }

    $i++;
    $j = $i - 1;
    $rrd =~ s/\:/\\:/g;
    $rrd =~ s/\:/\\:/g if ( $rrd =~ m/SharedPool/ );
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}=\"$rrd\":$ds[$k]:$cf"; }

    if ( $i == 0 ) {
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$ids[$k]${i}"; }
      next;
    }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$rids[$k]${j},UN,$ids[$k]${i},$rids[$k]${j},IF"; }
  }

  if ( $i == -1 ) {

    # no fresh file has been found, do it once more qithout restriction to show at least the empty graph
    foreach my $rrd (@files) {    # LPM alias cycle
      chomp($rrd);
      $i++;
      $j = $i - 1;
      $rrd =~ s/\:/\\:/g;
      $rrd =~ s/\:/\\:/g if ( $rrd =~ m/SharedPool/ );
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}=\"$rrd\":$ds[$k]:$cf"; }

      if ( $i == 0 ) {
        for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$ids[$k]${i}"; }
        next;
      }
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$rids[$k]${j},UN,$ids[$k]${i},$rids[$k]${j},IF"; }
    }
  }

  my $ret_string = "";
  for ( my $k = 0; $k < @ds; $k++ ) {
    $ret_string .= "$rids[$k]${i},";
  }

  #print STDERR "001 $cmd,split(",",$ret_string)\n";
  return ( $cmd, split( ",", $ret_string ) );
}

sub graph_shpool {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT: ";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT: ";
  my $xgrid       = xgrid_set( $type, $detail );
  my $text        = text_set($type);

  #ACL Check
  if ( $xormon && $power ) {
    my $server_uid = PowerDataWrapper::get_item_uid( { type => "SERVER", label => $server } );
    my $lpar_uid   = PowerDataWrapper::get_item_uid( { type => "SHPOOL", label => $lpar, parent => $server_uid } );
    my $aclitem    = { hw_type => 'POWER', item_id => $lpar_uid, match => 'granted' };
    if ( !$acl->isGranted($aclitem) ) {
      $aclitem->{label} = $host;
      my $str = join( ", ", map {"$_=>$aclitem->{$_}"} keys %{$aclitem} );
      error( "ACL: object not allowed for user " . ACL::getUser() . ": $str " . __FILE__ . ":" . __LINE__ );
      return 1;
    }
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_ams: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  my $server_no_colon = $server;
  $server_no_colon =~ s/\:/\\:/g;
  my $rrd = "$wrkdir/$server/$host/$lpar.rr$type_sam";

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/SharedPool//g;    # to show slash and not &&1 which is general replacemnt for it

  my $lpar_pool_alias = $lpar;
  $lpar_pool_alias =~ s/SharedPool/CPU pool /g;

  # add CPU pool alias into png header (if exists and it is not a default CPU pool)
  my $pool_id = $lpar;
  $pool_id =~ s/SharedPool//g;

  if ( -f "$wrkdir/$server/$host/cpu-pools-mapping.txt" ) {
    open( FR, "< $wrkdir/$server/$host/cpu-pools-mapping.txt" );
    foreach my $linep (<FR>) {
      chomp($linep);
      ( my $id, my $pool_name ) = split( /,/, $linep );
      if ( $id == $pool_id ) {
        $lpar_pool_alias = "$pool_name";
        last;
      }
    }
    close(FR);
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "CPU pool: $lpar_pool_alias :$last_txt$text";

  if ( $detail == 1 ) {
    $header = "CPU pool: $server $lpar_pool_alias :$last_txt$text";
  }

  if ( $detail == 2 ) {

    # $header = "$server $lpar_pool_alias :$last_txt$text";
    $header = "$lpar_pool_alias :$last_txt$text";
    if ( $item =~ /-max/ ) {
      $header = "$lpar_pool_alias :max:$last_txt$text";
    }
  }
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "CPU pool: $server $lpar_pool_alias : $start_human - $end_human";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  #print "Graph pool :$lpar\n";
  if ( $type =~ "d" && $graph_hours == 0 ) {
    my $rrd_last = rrd_file_actual("$rrd");
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\: $l ";

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further ony if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ && $m_arr[4] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
          my $total_pool_cycles = sprintf( "%e", $m_arr[1] );
          my $utilized_pool_cyc = sprintf( "%e", $m_arr[2] );
          my $max_pool_units    = sprintf( "%e", $m_arr[3] );
          my $res_pool_units    = sprintf( "%e", $m_arr[4] );
          if ( $total_pool_cycles != 0 ) {
            my $util = sprintf( "%.2f", ( $utilized_pool_cyc / $total_pool_cycles ) * $max_pool_units );

            #print ("\n $util $curr_proc $entitled_cycles $capped_cycles $uncapped_cycles\n");

            $last = "COMMENT:Last utilization in CPU cores  $util";
            if ( $item eq "shpool-max" ) {
              $last = "COMMENT:Last utilization in CPU cores    $util";
            }
          }
        }
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  #  my $start_time = "now-1$type";
  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=CPU cores";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  my $cmd = "";
  my ( $result_cmd,     $max_pool_units,     $res_pool_units,     $total_pool_cycles,     $utilized_pool_cyc );
  my ( $result_cmd_max, $max_pool_units_max, $res_pool_units_max, $total_pool_cycles_max, $utilized_pool_cyc_max );
  if ( $lpar =~ "SharedPool[1-9]" || $lpar =~ "SharedPool[1-9][0-9]" ) {

    #print "creating graph : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;

    $cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "--step=$step_new"
      "--lower-limit=0.00"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "--alt-autoscale-max"
      "--upper-limit=0.1"
      "$vertical_label"
      "--units-exponent=1.00"
      "--alt-y-grid"
      "$xgrid"
      "$no_legend"
      "$disable_rrdtool_tag"
      "$font_def"
      "$font_tit"
    ';

    my $file_pth = "$wrkdir/$server/*/$lpar.rr$type_sam";

    #$file_pth =~ s/\:/\\:/g;
    ( $result_cmd, $max_pool_units, $res_pool_units, $total_pool_cycles, $utilized_pool_cyc ) = LPM_easy( "AVERAGE", $file_pth, "0", "0", "max_pool_units", "res_pool_units", "total_pool_cycles", "utilized_pool_cyc" );

    if ( $item eq "shpool-max" ) {
      my $file_pth_max = "$wrkdir/$server/*/$lpar.xr$type_sam";

      ( $result_cmd_max, $max_pool_units_max, $res_pool_units_max, $total_pool_cycles_max, $utilized_pool_cyc_max ) = LPM_easy( "MAX", $file_pth_max, "0", "0", "max_pool_units", "res_pool_units", "total_pool_cycles", "utilized_pool_cyc" );

      # prepare DEF|CDEF for max
      $max_pool_units_max    =~ s/var/varmax/g;
      $res_pool_units_max    =~ s/var/varmax/g;
      $total_pool_cycles_max =~ s/var/varmax/g;
      $utilized_pool_cyc_max =~ s/var/varmax/g;

      my $result_to_parse = $result_cmd_max;
      $result_to_parse =~ s/^\s+//g;
      $result_to_parse =~ s/\s+$//g;
      $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

      my @result_cmd_lines = split( "\n", $result_to_parse );
      my $result_cmd_max_new;

      foreach my $cmd_line (@result_cmd_lines) {
        chomp $cmd_line;

        #print "$cmd_line\n";
        $cmd_line =~ s/^\s+//g;
        $cmd_line =~ s/\s+$//g;

        my $line_max = $cmd_line;

        if ( $cmd_line =~ "^DEF:" ) {
          $line_max =~ s/^DEF:var/DEF:varmax/;
          $line_max =~ s/:AVERAGE$/:MAX/;
        }
        if ( $cmd_line =~ "^CDEF:" ) {
          $line_max =~ s/var/varmax/g;
        }

        $result_cmd_max_new .= " $line_max";
      }

      $cmd .= $result_cmd;
      $cmd .= $result_cmd_max_new;
      $cmd .= '
        "CDEF:max_max=$max_pool_units_max"
        "CDEF:res_max=$res_pool_units_max"
        "CDEF:totcyc_max=$total_pool_cycles_max"
        "CDEF:uticyc_max=$utilized_pool_cyc_max"
        "CDEF:max1_max=max_max,res_max,-"
        "CDEF:cpuutil_max=uticyc_max,totcyc_max,GT,UNKN,uticyc_max,totcyc_max,/,IF"
        "CDEF:cpuutiltot_max=cpuutil_max,max_max,*"
        "CDEF:utilisa_max=cpuutil_max,100,*"
        "CDEF:max=$max_pool_units"
        "CDEF:res=$res_pool_units"
        "CDEF:totcyc=$total_pool_cycles"
        "CDEF:uticyc=$utilized_pool_cyc"
        "CDEF:max1=max,res,-"
        "CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF"
        "CDEF:cpuutiltot=cpuutil,max,*"
        "CDEF:utilisa=cpuutil,100,*"
        "COMMENT:Average [CPU cores]   \\n"
        "$t2"
        "AREA:res#00FF00: Reserved      "
        "GPRINT:res:AVERAGE: %2.1lf"
        "$t2"
        "STACK:max1#FFFF00: Max           "
        "GPRINT:max:AVERAGE: %2.1lf"
        "$t2"
        "LINE1:cpuutiltot#FF0000: Utilization   "
        "GPRINT:cpuutiltot:AVERAGE: %2.2lf"
        "COMMENT:("
        "GPRINT:utilisa_max:AVERAGE: %2.1lf"
        "COMMENT:\%)"
        "$t2"';
      if ( $graph_cmd =~ m/graphv$/ ) {
        $cmd .= ' "LINE1:cpuutiltot_max#0088FF: Maximum peaks :dashes=1,2"';
      }
      else {
        # RRDTool 1.2.x does not support dashed lines
        $cmd .= ' "LINE1:cpuutiltot_max#0088FF: Maximum peaks "';
      }
      $cmd .= '
        "GPRINT:cpuutiltot_max:MAX: %3.2lf"
        "$t2"
        "$t"
        "HRULE:0#000000"
      );';    #      "GPRINT:max:AVERAGE: %2.1lf"  # must be max , not max1, fixed in 4.54

    }
    else {
      $cmd .= $result_cmd;
      $cmd .= '
        "CDEF:max=$max_pool_units"
        "CDEF:res=$res_pool_units"
        "CDEF:totcyc=$total_pool_cycles"
        "CDEF:uticyc=$utilized_pool_cyc"
        "CDEF:max1=max,res,-"
        "CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF"
        "CDEF:cpuutiltot=cpuutil,max,*"
        "CDEF:utilisa=cpuutil,100,*"
        "COMMENT:Average [CPU cores]  \\n"
        "$t2"
        "AREA:res#00FF00: Reserved      "
        "GPRINT:res:AVERAGE: %2.1lf"
        "$t2"
        "STACK:max1#FFFF00: Max           "
        "GPRINT:max:AVERAGE: %2.1lf"
        "$t2"
        "LINE1:cpuutiltot#FF0000: Utilization   "
        "GPRINT:cpuutiltot:AVERAGE: %2.2lf"
        "COMMENT:("
        "GPRINT:utilisa:AVERAGE: %2.1lf"
        "COMMENT:\%)"
        "$t2"
        "$t"
        "HRULE:0#000000"
      );';    #      "GPRINT:max:AVERAGE: %2.1lf"  # must be max , not max1, fixed in 4.54
    }
  }
  else {
    #print "creating graph : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;
    $cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "--step=$step_new"
      "--lower-limit=0.00"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "--alt-autoscale-max"
      "--upper-limit=0.1"
      "$vertical_label"
      "--units-exponent=1.00"
      "--alt-y-grid"
      "$xgrid"
      "$no_legend"
      "$disable_rrdtool_tag"
      "$font_def"
      "$font_tit"
    ';

    my $file_pth = "$wrkdir/$server/*/$lpar.rr$type_sam";

    ( $result_cmd, $max_pool_units, $total_pool_cycles, $utilized_pool_cyc ) = LPM_easy( "AVERAGE", $file_pth, "0", "0", "max_pool_units", "total_pool_cycles", "utilized_pool_cyc" );

    if ( $item eq "shpool-max" ) {
      my $file_pth_max = "$wrkdir/$server/*/$lpar.xr$type_sam";

      ( $result_cmd_max, $max_pool_units_max, $total_pool_cycles_max, $utilized_pool_cyc_max ) = LPM_easy( "MAX", $file_pth_max, "0", "0", "max_pool_units", "total_pool_cycles", "utilized_pool_cyc" );

      # prepare DEF|CDEF for max
      $max_pool_units_max    =~ s/var/varmax/g;
      $total_pool_cycles_max =~ s/var/varmax/g;
      $utilized_pool_cyc_max =~ s/var/varmax/g;

      my $result_to_parse = $result_cmd_max;
      $result_to_parse =~ s/^\s+//g;
      $result_to_parse =~ s/\s+$//g;
      $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

      my @result_cmd_lines = split( "\n", $result_to_parse );
      my $result_cmd_max_new;

      foreach my $cmd_line (@result_cmd_lines) {
        chomp $cmd_line;

        #print "$cmd_line\n";
        $cmd_line =~ s/^\s+//g;
        $cmd_line =~ s/\s+$//g;

        my $line_max = $cmd_line;

        if ( $cmd_line =~ "^DEF:" ) {
          $line_max =~ s/^DEF:var/DEF:varmax/;
          $line_max =~ s/:AVERAGE$/:MAX/;
        }
        if ( $cmd_line =~ "^CDEF:" ) {
          $line_max =~ s/var/varmax/g;
        }

        $result_cmd_max_new .= " $line_max";
      }

      $cmd .= $result_cmd;
      $cmd .= $result_cmd_max_new;
      $cmd .= '
        "CDEF:max_max=$max_pool_units_max"
        "CDEF:totcyc_max=$total_pool_cycles_max"
        "CDEF:uticyc_max=$utilized_pool_cyc_max"
        "CDEF:cpuutil_max=uticyc_max,totcyc_max,GT,UNKN,uticyc_max,totcyc_max,/,IF"
        "CDEF:cpuutiltot_max=cpuutil_max,max_max,*"
        "CDEF:utilisa_max=cpuutil_max,100,*"
        "CDEF:max=$max_pool_units"
        "CDEF:totcyc=$total_pool_cycles"
        "CDEF:uticyc=$utilized_pool_cyc"
        "CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF"
        "CDEF:cpuutiltot=cpuutil,max,*"
        "CDEF:utilisa=cpuutil,100,*"
        "COMMENT:Average [CPU cores]   \\n"
        "$t2"
        "AREA:max#00FF00: Max           "
        "GPRINT:max:AVERAGE: %2.1lf"
        "$t2"
        "LINE1:cpuutiltot#FF0000: Utilization   "
        "GPRINT:cpuutiltot:AVERAGE: %2.2lf"
        "COMMENT:("
        "GPRINT:utilisa:AVERAGE: %2.1lf"
        "COMMENT:\%)"
        "$t2"';
      if ( $graph_cmd =~ m/graphv$/ ) {
        $cmd .= ' "LINE1:cpuutiltot_max#0088FF: Maximum peaks :dashes=1,2"';
      }
      else {
        # RRDTool 1.2.x does not support dashed lines
        $cmd .= ' "LINE1:cpuutiltot_max#0088FF: Maximum peaks "';
      }
      $cmd .= '
        "GPRINT:cpuutiltot_max:MAX: %3.2lf"
        "$t2"
        "$t"
        "HRULE:0#000000"
      );';
    }
    else {
      $cmd .= $result_cmd;
      $cmd .= '
        "CDEF:max=$max_pool_units"
        "CDEF:totcyc=$total_pool_cycles"
        "CDEF:uticyc=$utilized_pool_cyc"
        "CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF"
        "CDEF:cpuutiltot=cpuutil,max,*"
        "CDEF:utilisa=cpuutil,100,*"
        "COMMENT:Average [CPU cores] \\n"
        "$t2"
        "AREA:max#00FF00: Max            "
        "GPRINT:max:AVERAGE: %2.1lf"
        "$t2"
        "LINE1:cpuutiltot#FF0000: Utitlization    "
        "GPRINT:cpuutiltot:AVERAGE: %2.2lf"
        "COMMENT:("
        "GPRINT:utilisa:AVERAGE: %2.1lf"
        "COMMENT:\%)"
        "$t2"
        "$t"
        "HRULE:0#000000"
      );';
    }
  }
  $cmd =~ s/\\"/"/g;

  #$cmd =~ s/\:/\\:/g;
  #print STDERR "ORIG cmd\n"; print STDERR "$cmd\n";
  eval($cmd);
  if ($@) {
    error( "Graph error in eval cmd : !$@! " . __FILE__ . ":" . __LINE__ );
  }
  else {
    my $answ = RRDp::read;
    if ( $$answ =~ "ERROR" ) {
      error( "$host:$server Graph rrdtool error : $$answ " . __FILE__ . ":" . __LINE__ );
    }
    $png_end_heading = ret_graph_param($answ);
  }
  return 0;
}

sub graph_osmem_agg {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $item       = shift;
  my $amax       = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $ds_name1   = "page_in";
  my $ds_name2   = "page_out";
  my $headline1  = "COMMENT:             [MB/s]        READ   Avg    Max   WRITE  Avg    Max";

  if ( $detail == 1 ) {
    $headline1 = "COMMENT:             [MB/s]        READ   Avg    Max   WRITE  Avg    Max                  [MB/s]        READ   Avg    Max   WRITE  Avg    Max";
  }

  my $vertical_label = "--vertical-label=READ  Paging MB/s  WRITE";
  my $t              = "COMMENT: ";
  my $t2             = "COMMENT:\\n";
  my $step_new       = $step;
  my $last           = "COMMENT: ";
  my $act_time       = localtime();
  my $act_time_u     = time();
  my $req_time       = 0;
  my $line_items     = 0;                                             # how many items in the legend per a line (default 2, when detail then 3)

  if ( $detail == 1 ) {
    $line_items = 2;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_osmem_agg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "Paging activity aggregated :$last_txt$text";

  if ( $detail == 1 ) {
    $header = "Paging activity aggregated: $server :$last_txt$text";
  }

  if ( $detail == 2 ) {

    # $header = "Paging: $server :$last_txt$text";
    $header = "Paging agg:$last_txt$text";
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "Paging activity aggregated: $server : $start_human - $end_human";
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my $i   = 0;
  my $cmd = "";

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }    #"--units-exponent=1.00"

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"
        "--title" "$header"
        "--start" "$start_time"
        "--end" "$end_time"
        "--imgformat" "PNG"
        "--slope-mode"
        "--width=$width"
        "--height=$height"
        "--step=$step"
        "--lower-limit=0.00"
        "--color=BACK#$pic_col"
        "--color=SHADEA#$pic_col"
        "--color=SHADEB#$pic_col"
        "--color=CANVAS#$pic_col"
        "--alt-autoscale-max"
        "$vertical_label"
        "--units-exponent=1.00"
        "--alt-y-grid"
        "$xgrid"
        "$no_legend"
        "$disable_rrdtool_tag"
        "--base=1024"
        "$font_def"
        "$font_tit"
        "$headline1"
        "$t2"
';
  my $color_indx = -1;
  my $line_indx  = 0;    # place enter every 3rd line

  my $server_space = $server;
  if ( $server =~ m/ / ) {    # workaround for server name with a space inside, nothing else works, grrr
    $server_space = "\"" . $server . "\"";
  }
  my $wrkdir_space = $wrkdir;
  if ( $wrkdir =~ m/ / ) {    # workaround for server name with a space inside, nothing else works, grrr
    $wrkdir_space = "\"" . $wrkdir . "\"";
  }
  my $host_space = $host;
  if ( $host =~ m/ / ) {      # workaround for server name with a space inside, nothing else works, grrr
    $host_space = "\"" . $host . "\"";
  }

  # print STDERR "7127 $wrkdir_space/$server_space/$host_space\n";
  $server_space = urldecode($server_space);
  $host_space   = urldecode($host_space);

  # print STDERR "7137 $wrkdir_space/$server_space/$host_space\n";

  my @files_unsorted = (<$wrkdir_space/$server_space/$host_space/*/pgs\.mmm>);

  #  my @files_unsorted = grep(/pgs\.mmm$/,readdir(DIR));
  my @files = sort { lc $a cmp lc $b } @files_unsorted;

  if ( $type_sam =~ "d" ) {
    $req_time = $act_time_u - 31536000;
  }

  my $filter = $filter_max_paging;

  # values in rrdtool are in pages == 4096B
  if ( $type =~ m/y/ ) {

    # lower limits for yearly graphs as they are averaged ....
    $filter = $filter / 10;
  }
  if ( $type =~ m/m/ ) {

    # lower limits for monthly graphs as they are averaged ....
    $filter = $filter / 2;
  }

  my $alimit = 10;

  # print STDERR  "7154 amax:$amax, alimit:$alimit, detail:$detail\n";
  if ( $amax !~ m/none=/ ) {

    #( undef, $alimit ) = split( /=/, $amax );
    # $amax = $amax/1024; # so you can put the limit in kB/sec
    $amax   = $amax / 10;    # so you can put the limit in kB/sec
    $alimit = $amax;
    chomp($alimit);
    if ( !isdigit($alimit) ) { $alimit = 10; }
    if ( $alimit <= 0 )      { $alimit = 0; }
    if ( $detail == 2 )      { $alimit = 10; }    # for dashboard only default
  }
  $alimit = $alimit * 1024;                       # to bytes ...

  my $last_dir = "";
  my ( @recb, @trab, @rname, @rpath, @avgx, @avgy, @lpnames );
  my $lpar_space                     = "";
  my @lpar_space_proc                = "";
  my @wrkdir_server_host_file_legend = "";
  my $i_lpar                         = 0;

  foreach my $file (@files) {
    chomp($file);

    if ( $file =~ m/--NMON--/ ) {
      next;    # skip nmon files
    }

    #`echo "2913: detail-graph-cgi - $file" >> /tmp/e099`;

    # avoid old files - lpars which do not exist in the period
    my $rrd_upd_time = ( stat("$file") )[9];
    if ( $rrd_upd_time < $req_time ) {
      next;
    }

    # get MAX value from RRD
    my $answer;

    #      $file =~ s/:/\\:/g;

    my $file_space = $file;
    $file_space =~ s/:/\\:/g;

    # print STDERR "testing pagingagg files \$file $file\n";

    RRDp::cmd qq(graph "$name_out"
      "--start" "now-1$type"
      "--end" "now-1$type+1$type"
      "--step=$step"
      "DEF:item_nf=$file_space:$ds_name1:AVERAGE"
      "DEF:item2_nf=$file_space:$ds_name2:AVERAGE"
      "CDEF:item_nf_b=item_nf,4096,*"
      "CDEF:item2_nf_b=item2_nf,4096,*"
      "CDEF:item=item_nf_b,$filter,GT,UNKN,item_nf_b,IF"
      "CDEF:item2=item2_nf_b,$filter,GT,UNKN,item2_nf_b,IF"
      "PRINT:item:MAX: %10.0lf"
      "PRINT:item2:MAX: %10.0lf"
  );

    $answer = RRDp::read;
    if ( $$answer =~ m/NaN/ || $$answer =~ m/nan/ ) {

      # error ( "Graph rrdtool error instead of MAX returns : $$answer in osmem_agg detail-graph-cgi");
      next;    #return 0;
    }
    chomp($$answer);
    my $addr   = "";
    my $maxin  = "";
    my $maxout = "";
    ( $addr, $maxin, $maxout ) = split( / +/, $$answer );
    chomp($maxout);
    chomp($maxin);

    # `echo  "01 $file - amax:$amax, alimit:$alimit, maxin:$maxin, maxout:$maxout" >> /tmp/e099`;
    # when it is called from DB then it contains none=1402990627
    if ( !isdigit($maxin) || !isdigit($maxout) ) {
      next;    # no data
    }
    if ( $maxin < $alimit && $maxout < $alimit ) {
      next;
    }

    # print STDERR "7235 $file - amax:$amax, alimit:$alimit, maxin:$maxin, maxout:$maxout\n";
    #lpar name is last but one
    my @n_parts = split( /\//, $file );
    my $len     = @n_parts;
    $lpar = $n_parts[ $len - 2 ];

    $lpar_space = $lpar;
    $lpar_space_proc[$i_lpar] = $lpar;
    $lpar_space =~ s/\&\&1/\//g;

    # add spaces to lpar name to have 25 chars total (for formatting graph legend)
    # to keep same count of characters
    $lpar_space =~ s/\\:/:/g;
    $lpar_space = sprintf( "%-25s", $lpar_space );
    $lpar_space               =~ s/:/\\:/g;
    $lpar_space_proc[$i_lpar] =~ s/:/\\:/g;
    $lpar_space_proc[$i_lpar] =~ s/%/%%/g;    # anti '%'

    $wrkdir_server_host_file_legend[$i_lpar] = "$file";
    $wrkdir_server_host_file_legend[$i_lpar] =~ s/%/%%/g;
    $wrkdir_server_host_file_legend[$i_lpar] =~ s/:/\\:/g;

    $rpath[$i] = "$file";
    $rpath[$i] =~ s/:/\\:/g;
    $lpnames[$i] = "$lpar_space";
    $recb[$i]    = "rcb${i}";
    $trab[$i]    = "trb${i}";
    $avgx[$i]    = "avg${i}";
    $avgy[$i]    = "avgy${i}";

    # it is stored in pages 1 page == 4096 bytes
    $cmd .= '"DEF:$recb[$i]=$rpath[$i]:$ds_name1:AVERAGE"
           "DEF:$trab[$i]=$rpath[$i]:$ds_name2:AVERAGE"
           "CDEF:$recb[$i]_b=$recb[$i],4096,*"
           "CDEF:$trab[$i]_b=$trab[$i],4096,*"
           "CDEF:$recb[$i]_b_nf=$recb[$i]_b,$filter,GT,0,$recb[$i]_b,IF"
           "CDEF:$trab[$i]_b_nf=$trab[$i]_b,$filter,GT,0,$trab[$i]_b,IF"
           "CDEF:$recb[$i]_mb=$recb[$i]_b_nf,1048576,/"
           "CDEF:$trab[$i]_mb=$trab[$i]_b_nf,1048576,/"
           "CDEF:$recb[$i]_mbn=$recb[$i]_mb,UN,0,$recb[$i]_mb,IF"
           "CDEF:$recb[$i]_mbnm=0,$recb[$i]_mbn,-"
           "CDEF:$trab[$i]_mbn=$trab[$i]_mb,UN,0,$trab[$i]_mb,IF"
          ';
    $cmd .= '"COMMENT:$lpnames[$i]"
                   ';

    $cmd .= '"LINE1:$recb[$i]_mbnm$color[++$color_indx % ($color_max +1)]: "
                "GPRINT:$recb[$i]_mb:AVERAGE:%5.1lf"
            ';
    $cmd .= '"PRINT:$recb[$i]_mb:AVERAGE:%5.1lf $delimiter $item $delimiter $lpar_space_proc[$i_lpar] $delimiter $color[$color_indx % ($color_max +1)] $delimiter $wrkdir_server_host_file_legend[$i_lpar++]"
            ';
    $cmd .= '"GPRINT:$recb[$i]_mb:MAX:%5.1lf"
                "PRINT:$recb[$i]_mb:MAX:%5.1lf $delimiter"
                "LINE1:$trab[$i]_mbn$color[++$color_indx % ($color_max +1)]: "
                "GPRINT:$trab[$i]_mb:AVERAGE:%5.1lf"
                "PRINT:$trab[$i]_mb:AVERAGE:%5.1lf $delimiter $color[$color_indx % ($color_max +1)]"
                "PRINT:$trab[$i]_mb:MAX:%5.1lf $delimiter"
                "GPRINT:$trab[$i++]_mb:MAX:%5.1lf"
            ';

    if ( $detail == 1 ) {
      if ( 1 == $i % 2 ) {
        $cmd .= '  "$t2"
                  ';    # There is remainder
      }
    }    #do you understand difference $i++ above and below ??
    else {
      $cmd .= '  "$t2"
                ';
    }

    # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)
    $i++;
    $i_lpar++;
    if ( $line_indx == $line_items ) {

      # put carriage return after each second lpar in the legend
      #      $cmd .= " COMMENT:\\\"\\l\\\"";
      #       $cmd .= '" COMMENT: \\n"
      #        ';
      $line_indx = 0;
    }
    else {
      $line_indx++;
    }
  }
  $cmd .= '  "$t2" ';
  $cmd .= '"HRULE:0#000000"
 );';

  #          "VRULE:0#000000"

  #  $cmd =~ s/\\"/"/g;

  #if you want to see what is generated
  # my $sss = "/var/tmp/sss.out";
  # open (FF, ">$sss");
  # print FF "$cmd\n";
  # close (FF);

  # if you want to see interpolated $cmd
  # care what file name is in sub alfa
  #  $i_lpar = 0;
  #  $i = 0;
  #  $color_indx = -1;
  #  my $t_cmd = $cmd;
  #  $t_cmd =~ s/RRDp::cmd qq\(\$graph_cmd /alfa\(/;
  #  $t_cmd =~ s/\s\"/\n\.\"/g;
  #  eval($t_cmd);

  $cmd =~ s/\\"/"/g;
  $i_lpar     = 0;
  $i          = 0;
  $color_indx = -1;
  eval($cmd);
  if ($@) {
    error( "Graph error in eval cmd : !$@! " . __FILE__ . ":" . __LINE__ );
  }
  else {
    my $answ = RRDp::read;
    if ( $$answ =~ "ERROR" ) {
      error( "$host:$server Graph rrdtool error : $$answ " . __FILE__ . ":" . __LINE__ );
    }
    $png_end_heading = ret_graph_param($answ);
  }
  return 0;

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
}

sub graph_lparagg {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT:\" \" ";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT: ";
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $req_time    = 0;
  my $line_items  = 0;                  # how many items in the legend per a line (default 2, when detail then 3)

  my %vm_uuid_names = ();               # for quick lookup

  if ( $detail == 1 ) {
    $line_items = 2;
  }
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lparagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $head = "LPARs";
  $head = "VMs"      if $vmware;
  $head = "CLUSTERs" if ( $item eq "multicluster" );
  $head = "WLM_CPU"  if ( $item eq "wlm-cpu" );
  $head = "WLM_MEM"  if ( $item eq "wlm-mem" );
  $head = "WLM_DKIO" if ( $item eq "wlm-dkio" );
  my $header = "$head aggregated :$last_txt$text";

  if ( $detail == 1 ) {
    $header = "$head aggregated: $server :$last_txt$text";
    $header = "$head aggregated: $lpar :$last_txt$text" if ( $item =~ "wlm" );
    $header = "$head aggregated: $last_txt$text"        if ( $item eq "multicluster" );
    $header = "$head aggregated: $host :$last_txt$text" if ($hitachi);
  }

  if ( $detail == 2 ) {

    # $header = "$server :$last_txt$text";
    $header = "LPARs aggregated :$last_txt$text";
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # my $start_time = "now-1$type";
  # my $end_time = "now-1$type+1$type";

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  # print STDERR "$start_time $end_time \n";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "";                # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$head aggregated: $server : $start_human - $end_human";
      $header = "$head aggregated: $lpar : $start_human - $end_human" if ( $item =~ "wlm" );
      if ( $item eq "multicluster" ) {
        $header = "$head aggregated: $start_human - $end_human";
      }
      elsif ($hitachi) {
        $header = "$head aggregated: $host : $start_human - $end_human";
      }
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my @cluster_arr;
  my @files = "";
  my %wlm_colors;

  if ( $item eq "multicluster" ) {

    # print STDERR "multicluster ------- $wrkdir/$server/$host\n";

    # find if there are more clusters
    my $file_cluster = "$wrkdir/$server/*/cluster.rrc";

    # $file_cluster =~ s/ /\\ /g;
    my $no_name = "";
    @cluster_arr = <$file_cluster$no_name>;
    @files       = @cluster_arr;
    my $cluster_count = scalar @cluster_arr;

    #print STDERR "multicluster ....... \$cluster_count $cluster_count \@cluster_arr @cluster_arr\n";
  }
  elsif ( $vmware && ( $item ne "multicluster" ) ) {    # server ESXi

    my $hosting_file = "$wrkdir/$server/$host/VM_hosting.vmh";
    my @vm_hosting   = ();
    if ( -f "$hosting_file" ) {
      open( FHC, "< $hosting_file" ) || error( "cannot open file : $hosting_file " . __FILE__ . ":" . __LINE__ ) && return 0;
      @vm_hosting = <FHC>;
      close(FHC);
    }

    #prepare VM file names
    @files = @vm_hosting;

    #  print STDERR "6432 $wrkdir/$server/$host/VM_hosting.vmh \@files @files\n";

    my $vm_uuid_name_file = "$wrkdir/vmware_VMs/vm_uuid_name.txt";
    open( FH, " < $vm_uuid_name_file" ) || error( "Cannot open $vm_uuid_name_file: $!" . __FILE__ . ":" . __LINE__ );
    while (<FH>) {
      ( my $uuid, my $name, undef ) = split( ",", $_ );
      $vm_uuid_names{$uuid} = $name;
    }
    close FH;

  }
  elsif ( $hyperv && ( $item ne "multicluster" ) ) {    # server hyperv

    my $hosting_file = "$wrkdir/$server/$host/VM_hosting.vmh";
    my @vm_hosting   = ();
    if ( -f "$hosting_file" ) {
      open( FHC, "< $hosting_file" ) || error( "cannot open file : $hosting_file " . __FILE__ . ":" . __LINE__ ) && return 0;
      @vm_hosting = <FHC>;
      close(FHC);
    }

    #prepare VM file names
    @files = @vm_hosting;

    # print STDERR "6773 $wrkdir/$server/$host/VM_hosting.vmh \@files @files\n";
  }
  elsif ($hitachi) {
    opendir( DIR, "$wrkdir/$server/$host" ) || error( "can't opendir $wrkdir/$server/$host: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
    my @files_unsorted = grep( /\.hlm$/, readdir(DIR) );
    @files = sort { lc $a cmp lc $b } @files_unsorted;
    closedir(DIR);
  }
  elsif ( $item =~ "wlm-" ) {
    opendir( DIR, "$wrkdir/$server/$host/$lpar/" ) || error( " directory does not exists : $wrkdir/$server/$host/$lpar/ " . __FILE__ . ":" . __LINE__ ) && return 0;
    my @files_unsorted = grep( /^wlm-.*\.mmm$/, readdir(DIR) );
    my @files_temp     = sort { lc $a cmp lc $b } @files_unsorted;
    closedir(DIR);
    my $file_count = @files;
    $file_count--;    #last one is "\n"
    foreach my $wlm_file (@files_temp) {
      if ( $wlm_file =~ "TOTAL" ) {
        next;
      }
      push @files, $wlm_file;
    }
    my $temp       = @files;
    my $color_file = "$wrkdir/$server/$host/$lpar/wlm.col";
    if ( -f $color_file ) {
      open( WLM, "< $color_file" ) || error( "cannot open file : $color_file $!" . __FILE__ . ":" . __LINE__ ) && return 0;
      my @wlm_col        = <WLM>;
      my $wlm_file_count = @wlm_col;
      for ( my $k = 0; $k < $wlm_file_count; $k++ ) {
        chomp( $wlm_col[$k] );
        my $file_check = 0;
        $wlm_col[$k] =~ s/:[0-9]*//g;
        foreach my $file_tmp (@files) {    #get rid of TOTAL and classes with subclasses (it will save few colors)
          if ( $file_tmp eq $wlm_col[$k] ) { $file_check = 1; last }
          else                             { $file_check = 0; }
        }
        if ( $file_check == 0 ) { next; }
        $wlm_colors{ $wlm_col[$k] } = $k % 53;
      }
      close(WLM);
    }

    #print STDERR "AFTER 7405 detail-graph-cgi.pl \@files @files\n";
  }
  else {
    opendir( DIR, "$wrkdir/$server/$host" ) || error( "can't opendir $wrkdir/$server/$host: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
    if ( $type_sam =~ "m" ) {
      my @files_unsorted = grep( /\.rrm$/, readdir(DIR) );
      for (@files_unsorted) {s/\.rrm$/    /}
      @files = sort { lc $a cmp lc $b } @files_unsorted;
      for (@files) {s/    $/\.rrm/}
    }
    if ( $type_sam =~ "h" ) {
      my @files_unsorted = grep( /\.rrh$/, readdir(DIR) );
      @files = sort { lc $a cmp lc $b } @files_unsorted;
    }
    if ( $type_sam =~ "d" ) {
      my @files_unsorted = grep( /\.rrd$/, readdir(DIR) );
      @files    = sort { lc $a cmp lc $b } @files_unsorted;
      $req_time = $act_time_u - 31536000;
    }
    closedir(DIR);
  }

  my $file = "";
  my $i    = 0;

  #  my $lpar = "";
  my $aix_ser = $lpar;
  my $cmd     = "";
  my $j       = 0;

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=\"CPU cores\"";

  if ($vmware) {
    $vertical_label = "--vertical-label=\"CPU GHz\"";
  }
  elsif ( $item =~ "wlm-dkio" || $item =~ "wlm-cpu" ) {
    $vertical_label = "--vertical-label=\"%\"";
  }
  elsif ( $item =~ "wlm-mem" ) {
    $vertical_label = "--vertical-label=\"GB\"";
  }

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  my $units = "cores";
  $units = "GHz  " if $vmware;

  if ( $detail == 1 ) {
    if ( $item =~ "wlm-" ) {
      $cmd .= " COMMENT:\"Class                      average  maximum   Class                      average  maximum   Class                      average  maximum\\l\"";
    }
    else {
      $cmd .= " COMMENT:\"Utilization in CPU $units\\:    average  maximum                               average  maximum                               average  maximum\\l\"";
    }
  }
  else {
    $cmd .= " COMMENT:\"Utilization in CPU $units\\:    average  maximum\\l\"";
  }

  # open a file with stored colours
  my @color_save = ();
  if ( -f "$wrkdir/$server/$host/lpars.col" ) {
    open( FHC, "< $wrkdir/$server/$host/lpars.col" ) || error( "cannot open file : $wrkdir/$server/$host/lpars.col " . __FILE__ . ":" . __LINE__ ) && return 0;
    @color_save = <FHC>;
    close(FHC);
  }

  # print STDERR "8147 \@color_save @color_save\n";
  # print STDERR "rq_time: $req_time \n";
  my $lpar_color_index  = -1;
  my $color_WLM_counter = 0;
  my $gtype             = "AREA";
  my $color_indx        = -1;
  my $line_indx         = 0;        # place enter every 3rd line
  my $files_index       = -1;       # for vmware it is color index
  foreach $file (@files) {
    chomp($file);
    my $file_orig = $file;          # keep for vmware
                                    #    $files_index = $files_index++ % $color_max; # not possible !!!
    $files_index++;
    $files_index = $files_index % $color_max;

    $color_indx = ( $color_indx + 1 ) % ( $color_max + 1 );

    if ($vmware) {
      $lpar_color_index++;
      if ( $item eq "multicluster" ) {
        my @arr_path = split( "\/", $file );
        $file   = $arr_path[-1];
        $host   = $arr_path[-2];
        $server = $arr_path[-3];

        # avoid old lpars which do not exist in the period
        my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$file") )[9];

        # print STDERR "14537 \$file_orig $file_orig ,$wrkdir/$server/$host/$file,\n";
        next if ( $rrd_upd_time < $req_time );
      }
      else {
        $file =~ s/:.*/\.rrm/;
        next if !-f "$wrkdir/vmware_VMs/$file";

        # avoid old lpars which do not exist in the period
        my $rrd_upd_time = ( stat("$wrkdir/vmware_VMs/$file") )[9];
        next if ( $rrd_upd_time < $req_time );
      }
    }
    elsif ($hyperv) {
      $lpar_color_index++;
      if ( $item eq "multicluster" ) {
        my @arr_path = split( "\/", $file );
        $file   = $arr_path[-1];
        $host   = $arr_path[-2];
        $server = $arr_path[-3];

        # avoid old lpars which do not exist in the period
        my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$file") )[9];
        next if ( $rrd_upd_time < $req_time );
      }
      else {
        $file =~ s/:.*/\.rrm/;

        # print STDERR "13130 $wrkdir / $host / $server / $file\n";
        next if !-f "$wrkdir/$server/hyperv_VMs/$file";

        # avoid old lpars which do not exist in the period
        my $rrd_upd_time = ( stat("$wrkdir/$server/hyperv_VMs/$file") )[9];
        next if ( $rrd_upd_time < $req_time );
      }
    }
    elsif ( $item =~ "wlm-cpu" ) {
      next if !-f "$wrkdir/$server/$host/$aix_ser/$file";
      my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$aix_ser/$file") )[9];
      next if ( $rrd_upd_time < $req_time );
    }
    elsif ( $item =~ "wlm-mem" ) {
      next if !-f "$wrkdir/$server/$host/$aix_ser/$file";
      my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$aix_ser/$file") )[9];
      next if ( $rrd_upd_time < $req_time );
    }
    elsif ( $item =~ "wlm-dkio" ) {
      next if !-f "$wrkdir/$server/$host/$aix_ser/$file";
      my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$aix_ser/$file") )[9];
      next if ( $rrd_upd_time < $req_time );
    }
    else {
      # avoid old lpars which do not exist in the period
      my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$file") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
    }

    $lpar = $file;
    $lpar =~ s/.rrh//;
    $lpar =~ s/.rrm//;
    $lpar =~ s/.rrd//;
    $lpar =~ s/.mmm//;
    $lpar =~ s/.hlm//;                          # hitachi suffix
    $lpar =~ s/wlm-// if ( $item =~ "wlm-" );

    my $lpar_space_proc = $lpar;
    $lpar_space_proc = human_vmware_name( $lpar, "", $server ) if $hyperv;

    if ($vmware) {

      $lpar_space_proc = $vm_uuid_names{$lpar};    # quick lookup
                                                   #     $lpar_space_proc =~ s/\(.*\)//; # maybe get away uuid in brackets ?
      if ( $item eq "multicluster" ) {             # for legend
                                                   # print STDERR "5491 $file_orig,$file,$host,$server,\n";
        my $dir = $file_orig;
        $dir =~ s/$file$//;
        opendir( my $dh, $dir ) || error( "can't opendir $dir: $! :" . __FILE__ . ":" . __LINE__ ) && next;
        my @namefile = grep {/^cluster_name_/} readdir($dh);
        if ( defined $namefile[0] && $namefile[0] ne "" ) {
          $lpar_space_proc = $namefile[0];
          $lpar_space_proc =~ s/cluster_name_//;
        }
        else {
          $lpar_space_proc = $host;
        }
        closedir($dh);
      }
    }
    my $lpar_space = $lpar_space_proc;

    # add spaces to lpar name to have 25 chars total (for formating graph legend)
    $lpar_space =~ s/\&\&1/\//g;
    for ( my $k = length($lpar_space); $k < 25; $k++ ) {
      $lpar_space .= " ";
    }

    # max 25 chars
    $lpar_space = substr( $lpar_space, 0, 24 );

    # Exclude pools and  memory
    if ( $lpar =~ m/^pool$/ || $lpar =~ m/^mem$/ || $lpar =~ /^SharedPool[0-9]$/ || $lpar =~ m/^SharedPool[1-9][0-9]$/ || $lpar =~ m/^mem-pool$/ || $lpar =~ m/^cod$/ ) {
      next;
    }

    # Found out stored color index to keep same color for lpars across all graphs
    if ( !$vmware && !$hyperv && !$hitachi ) {
      unless ( $item =~ "wlm-" ) {
        $lpar_color_index = -1;
        for (@color_save) {
          $lpar_color_index++;

          #  last if "$_" =~ /$lpar_space_proc/;
          last if ( index( "$_", $lpar_space_proc ) != -1 );
        }
        if ( $lpar_color_index != -1 ) {
          ( $lpar_color_index, undef ) = split( " : ", $color_save[$lpar_color_index] );
        }
      }
    }

    #print "$wrkdir/$server/$host/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3);

    $lpar_space      =~ s/:/\\:/g;    # anti ':'
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;     # anti '%

    my $wrkdir_server_host_file = "$wrkdir/$server/$host/$file";
    $wrkdir_server_host_file =~ s/:/\\:/g;
    my $wrkdir_server_host_file_legend = $wrkdir_server_host_file;
    if ( $item eq "multicluster" ) {
      $wrkdir_server_host_file_legend = "$wrkdir/$server/$lpar_space_proc/$file";
      $wrkdir_server_host_file_legend = "$file_orig";
      $wrkdir_server_host_file_legend =~ s/:/\\:/g;
    }
    $wrkdir_server_host_file_legend =~ s/%/%%/g;

    my $wrkdir_server_host_file_lpm = "$wrkdir/$server/*/$file";
    $wrkdir_server_host_file_lpm =~ s/:/\\:/g;

    if ( $vmware || $hyperv ) {
      if ( $item eq "multicluster" ) {
        $cmd .= " DEF:utiltot_mhz${i}=\"$wrkdir_server_host_file\":CPU_usage_MHz:AVERAGE";
        $cmd .= " CDEF:utiltot${i}=utiltot_mhz${i},1000,/";
      }
      else {
        $wrkdir_server_host_file = "$wrkdir/vmware_VMs/$file"         if $vmware;
        $wrkdir_server_host_file = "$wrkdir/$server/hyperv_VMs/$file" if $hyperv;

        # analyse $file_orig
        # 502a854c-d67c-5015-8f48-f161d122eae0:start=1440417087:end=1440418087:start=144419087:end=1440420087:start=1440421087..."
        # for graphing -> there are $start_time and $end_time, both unix
        my @st_end = split( "start", $file_orig );
        if ( scalar @st_end == 2 && $st_end[1] !~ 'end' ) {    # one start, no end -> no problem
          $cmd .= " DEF:utiltot_mhzt${i}=\"$wrkdir_server_host_file\":CPU_usage:AVERAGE" if $vmware;
          if ($hyperv) {
            $cmd .= " DEF:utiltot_mhzt_perc${i}=\"$wrkdir_server_host_file\":PercentTotalRunTime:AVERAGE";
            $cmd .= " DEF:utiltot_mhzt_time${i}=\"$wrkdir_server_host_file\":Timestamp_PerfTime:AVERAGE";
            $cmd .= " DEF:utiltot_mhzt_freq${i}=\"$wrkdir_server_host_file\":Frequency_PerfTime:AVERAGE";
            $cmd .= " DEF:utiltot_mhzt_cpu${i}=\"$wrkdir_server_host_file\":vCPU:AVERAGE";
            $cmd .= " CDEF:utiltot_mhzt${i}=utiltot_mhzt_perc${i},utiltot_mhzt_time${i},/,utiltot_mhzt_freq${i},*,100000,/,100,/,utiltot_mhzt_cpu${i},*";
          }
          my $t_start = substr( $st_end[1], 1, 11 );
          $t_start = $t_start * 1;
          $cmd .= " CDEF:utiltot_mhz${i}=TIME,$t_start,LT,UNKN,utiltot_mhzt${i},IF";
        }
        else {    # more than only one start -> needs analyse
                  # print STDERR "7343 \$i $i more starts $file_orig\n @st_end\n";
          my $cmd_tmp = "";
          $cmd_tmp = " DEF:utiltot_m${i}=\"$wrkdir_server_host_file\":CPU_usage:AVERAGE" if $vmware;    #:start=$t_start:end=$t_end";
          if ($hyperv) {
            $cmd_tmp .= " DEF:utiltot_mhzt_perc${i}=\"$wrkdir_server_host_file\":PercentTotalRunTime:AVERAGE";                                               #:start=$t_start:end=$t_end";
            $cmd_tmp .= " DEF:utiltot_mhzt_time${i}=\"$wrkdir_server_host_file\":Timestamp_PerfTime:AVERAGE";
            $cmd_tmp .= " DEF:utiltot_mhzt_freq${i}=\"$wrkdir_server_host_file\":Frequency_PerfTime:AVERAGE";
            $cmd     .= " DEF:utiltot_mhzt_cpu${i}=\"$wrkdir_server_host_file\":vCPU:AVERAGE";
            $cmd_tmp .= " CDEF:utiltot_m${i}=utiltot_mhzt_perc${i},utiltot_mhzt_time${i},/,utiltot_mhzt_freq${i},*,100000,/,100,/,utiltot_mhzt_cpu${i},*";
          }
          my $ik = 1000;

          # Multi graph rrdtool error : ERROR: trying to reuse vname utiltot_mh130 at /home/lpar2rrd/lpar2rrd/bin/detail-graph-cgi.pl line 7772
          # there was a problem when v-motion was more than hundred in the picture time - day or week, that is why starts not 0 but 1000
          $cmd_tmp .= " CDEF:utiltot_mh${i}${ik}=utiltot_m${i},UN,UNKN,UNKN,IF";
          my $in = 1001;

          # print STDERR "----- @st_end\n";
          shift @st_end;    # remove VM name

          my ( $t_start, $t_end );
          foreach my $times (@st_end) {
            $times =~ s/:$//;
            ( undef, $t_start, $t_end ) = split( "=", $times );
            if ( !defined $t_end ) {
              $t_end = $end_time;
            }
            else {
              $t_end = substr( $t_end, 0, 10 );
            }
            $t_start = substr( $t_start, 0, 10 );
            $t_start = $t_start * 1;
            $t_end   = $t_end * 1;

            #print STDERR "\$start_time $start_time \$t_start $t_start \$end_time $end_time \$t_end $t_end\n";
            if ( $t_start < $start_time ) { $t_start = $start_time }
            if ( $t_end > $end_time )     { $t_end = $end_time }
            if ( $t_start >= $t_end )     {next}

            #print STDERR "graphing $t_start $t_end\n";

            $cmd_tmp .= " CDEF:utiltot_mha${i}${in}=TIME,$t_start,GE,TIME,$t_end,LE,+,2,EQ,utiltot_m${i},UNKN,IF";
            $cmd_tmp .= " CDEF:utiltot_mh${i}${in}=utiltot_mh${i}${ik},UN,utiltot_mha${i}${in},utiltot_mh${i}${ik},IF";
            $in++;
            $ik++;
          }

          if ( $t_end <= $start_time ) {    # out of start time of picture
            $i++;
            next;
          }
          $cmd .= "$cmd_tmp";
          $in--;
          $cmd .= " CDEF:utiltot_mhz${i}=utiltot_mh${i}${in},1,*";
        }
        $cmd .= " CDEF:utiltot${i}=utiltot_mhz${i},1000,/" if $vmware;
        $cmd .= " CDEF:utiltot${i}=utiltot_mhz${i},1,*"    if $hyperv;
        $lpar_color_index = $files_index;
      }
    }
    elsif ($hitachi) {
      $cmd .= " DEF:cores${i}=\"$wrkdir_server_host_file\":cores:AVERAGE";
      $cmd .= " CDEF:utiltot${i}=cores${i}";
    }
    elsif ( $item =~ "wlm-cpu" ) {
      $wrkdir_server_host_file_legend = "$wrkdir/$server/$host/$aix_ser/$file";
      $cmd .= " DEF:cpu_wlm${i}=\"$wrkdir_server_host_file_legend\":wlm_cpu:AVERAGE";
      $cmd .= " CDEF:utiltot${i}=cpu_wlm${i}";

      my $color_added = 0;
      my $tmp_val     = 0;
      foreach my $hash_test ( keys %wlm_colors ) {
        chomp($hash_test);
        my $tmp_a = $wlm_colors{$hash_test};
        if ( $tmp_a >= $tmp_val ) { $tmp_val = $tmp_a }
        $lpar_color_index = $tmp_val;
        if ( $hash_test eq $file ) {
          $lpar_color_index = $wlm_colors{$hash_test};
          $color_added      = 1;
          $color_WLM_counter++;
          last;
        }
      }
      if ( $color_added == "0" ) {
        $color_WLM_counter++;
        $lpar_color_index = $color_WLM_counter % 53;
      }
    }
    elsif ( $item =~ "wlm-mem" ) {

      $wrkdir_server_host_file_legend = "$wrkdir/$server/$host/$aix_ser/$file";
      $cmd .= " DEF:mem_wlm${i}=\"$wrkdir_server_host_file_legend\":wlm_mem:AVERAGE";
      $cmd .= " CDEF:mem_wlm_g${i}=mem_wlm${i},1024,/";
      $cmd .= " CDEF:utiltot${i}=mem_wlm_g${i}";

      my $color_added = 0;
      my $tmp_val     = 0;
      foreach my $hash_test ( keys %wlm_colors ) {
        chomp($hash_test);
        my $tmp_a = $wlm_colors{$hash_test};
        if ( $tmp_a >= $tmp_val ) { $tmp_val = $tmp_a }

        $lpar_color_index = $tmp_val;
        if ( $hash_test eq $file ) {
          $lpar_color_index = $wlm_colors{$hash_test};
          $color_added      = 1;
          $color_WLM_counter++;
          last;
        }
      }
      if ( $color_added == "0" ) {
        $color_WLM_counter++;
        $lpar_color_index = $color_WLM_counter % 53;
      }
    }
    elsif ( $item =~ "wlm-dkio" ) {

      $wrkdir_server_host_file_legend = "$wrkdir/$server/$host/$aix_ser/$file";
      $cmd .= " DEF:dkio_wlm${i}=\"$wrkdir_server_host_file_legend\":wlm_dkio:AVERAGE";
      $cmd .= " CDEF:utiltot${i}=dkio_wlm${i}";

      my $color_added = 0;
      my $tmp_val     = 0;
      foreach my $hash_test ( keys %wlm_colors ) {
        chomp($hash_test);
        my $tmp_a = $wlm_colors{$hash_test};
        if ( $tmp_a >= $tmp_val ) { $tmp_val = $tmp_a }

        $lpar_color_index = $tmp_val;
        if ( $hash_test eq $file ) {
          $lpar_color_index = $wlm_colors{$hash_test};
          $color_added      = 1;
          $color_WLM_counter++;
          last;
        }
      }
      if ( $color_added == "0" ) {
        $color_WLM_counter++;
        $lpar_color_index = $color_WLM_counter % 53;
      }
    }
    else {

      #ACL check when Power Aggregated graphs - do not insert the !isGranted lpars to the result CMD
      if ( $xormon && $power ) {
        my $lpar_uid = PowerDataWrapper::get_item_uid( { type => "VM", label => $lpar } );
        my $aclitem  = { hw_type => 'POWER', item_id => $lpar_uid, match => 'granted' };
        if ( !$acl->isGranted($aclitem) ) {
          next;
        }
      }

      # to use data from all HMCs (not real LPM, LPM is between servers what this does not do
      my ( $result_cmd, $CPU_cap, $CPU_uncap, $CPU_ent, $CPU_cur ) = LPM_easy( "AVERAGE", "$wrkdir_server_host_file_lpm", $i, $req_time, "capped_cycles", "uncapped_cycles", "entitled_cycles", "curr_proc_units" );

      $cmd .= $result_cmd;
      $cmd .= " CDEF:cap_peak${i}=$CPU_cap";
      $cmd .= " CDEF:uncap${i}=$CPU_uncap";
      $cmd .= " CDEF:ent${i}=$CPU_ent";
      $cmd .= " CDEF:cur${i}=$CPU_cur";

      # bulid RRDTool cmd
      #$cmd .= " DEF:cap${i}=\"$wrkdir_server_host_file\":capped_cycles:AVERAGE";
      #$cmd .= " DEF:uncap${i}=\"$wrkdir_server_host_file\":uncapped_cycles:AVERAGE";
      #$cmd .= " DEF:ent${i}=\"$wrkdir_server_host_file\":entitled_cycles:AVERAGE";
      #$cmd .= " DEF:cur${i}=\"$wrkdir_server_host_file\":curr_proc_units:AVERAGE";

      # filtering peaks caused by LPM or changing entitled, if cap CPU util is > entitled --> UNKN
      # usualy cap counter is affected only
      # sometimes might happen that even in normal load capped util is little higher than entitled! Therefore using 1.2
      $cmd .= " CDEF:cap${i}=cap_peak${i},ent${i},/,1.2,GT,UNKN,cap_peak${i},IF";

      $cmd .= " CDEF:tot${i}=cap${i},uncap${i},+";
      $cmd .= " CDEF:util${i}=tot${i},ent${i},/,$cpu_max_filter,GT,UNKN,tot${i},ent${i},/,IF";

      $cmd .= " CDEF:utiltotu${i}=util${i},cur${i},*";
      $cmd .= " CDEF:utiltot${i}=utiltotu${i},UN,0,utiltotu${i},IF";
    }
    my $index_to_display = $color_indx;
    if ( $lpar_color_index > -1 ) {
      $index_to_display = $lpar_color_index;
    }
    $cmd .= " $gtype:utiltot${i}$color[$index_to_display]:\"$lpar_space\"";

    # print STDERR "13451 \$gtype:utiltot${i}\$color[$index_to_display]:\"\$lpar_space\" $gtype:utiltot${i}$color[$index_to_display]:\"$lpar_space\"\n";
    #my $color_count = @color;

    # for CPU decimals in hyperv
    if ($hyperv) {
      $cmd .= " GPRINT:utiltot${i}:AVERAGE:\"%5.1lf \"";
      $cmd .= " GPRINT:utiltot${i}:MAX:\" %5.1lf \"";

      $cmd .= " PRINT:utiltot${i}:AVERAGE:\"%5.1lf $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$index_to_display]\"";
      $cmd .= " PRINT:utiltot${i}:MAX:\" %5.1lf $delimiter $wrkdir_server_host_file_legend\"";
    }
    else {
      $cmd .= " GPRINT:utiltot${i}:AVERAGE:\"%5.2lf \"";
      $cmd .= " GPRINT:utiltot${i}:MAX:\" %5.2lf \"";

      $cmd .= " PRINT:utiltot${i}:AVERAGE:\"%5.2lf $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$index_to_display]\"";

      #      $cmd .= " PRINT:utiltot${i}:AVERAGE:\"%5.2lf $delimiter $item $delimiter $host $delimiter $color[$index_to_display]\"";
      $cmd .= " PRINT:utiltot${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";

      #      print STDERR "14905 \$wrkdir_server_host_file_legend $wrkdir_server_host_file_legend\n";
    }

    #$cmd .= " GPRINT:utiltot${i}:MAX:\" %5.2lf \\l\"";
    # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)
    # $color_indx = ( $color_indx + 1 ) % ( $color_max + 1 );

    #    $col_indx++;
    $gtype = "STACK";
    $i++;
    if ( $line_indx == $line_items ) {

      # put carriage return after each second lpar in the legend
      $cmd .= " COMMENT:\"\\l\"";
      $line_indx = 0;
    }
    else {
      $line_indx++;
    }
  }

  $cmd .= " COMMENT:\"\\l\"";    # last legend line in detail not across whole line

  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;        # a trick, there was a problem with aggregated and "COMMENT: "

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  # print STDERR "7464 detail-graph-cgi.pl lparagg \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub isdigit {
  my $digit = shift;
  my $text  = shift;

  if ( !defined $digit || $digit eq '' ) {
    return 0;
  }
  if ( $digit eq 'U' ) {
    return 1;
  }

  my $digit_work = $digit;
  $digit_work =~ s/[0-9]//g;
  $digit_work =~ s/\.//;
  $digit_work =~ s/^-//;
  $digit_work =~ s/e//;
  $digit_work =~ s/\+//;
  $digit_work =~ s/\-//;

  if ( length($digit_work) == 0 ) {

    # is a number
    return 1;
  }

  #if (($digit * 1) eq $digit){
  #  # is a number
  #  return 1;
  #}

  # NOT a number
  return 0;
}

sub graph_cod_used {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $step        = 3600;            # --PH dodelat --> no problem it could be here 60 fixed
  my $t           = "COMMENT: ";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT: ";
  my $time_range  = "hour";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $type =~ m/m/ ) {
    $step       = 86400;    # daily step
    $time_range = "day";
  }
  if ( $type =~ m/y/ ) {
    $step       = 86400;    # daily step
    $time_range = "day";
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_ams: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $rrd = "$wrkdir/$server/$host/$lpar.rr$type_sam";

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "Capacity on Demand - used:$last_txt$text";

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  #my $rrd_y = "";
  #if ( $type_sam =~ "y" ) {
  #  # u rocnich grafu nejdrive pouzit rrm data a pokud nejsou tak teprve rrd
  #  if ( $rrd !~ m/\.rrd$/ ) {
  #    $rrd_y = $rrd;
  #    $rrd_y =~ s/\.rrm$/\.rrd/;
  #    if ( -f $rrd_y ) {
  #     $rrd = $rrd_y;
  #    }
  #}

  #print "creating graph : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;
  my $start_time = "now-1$type";
  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=CoD in minutes per $time_range";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  $rrd =~ s/:/\\:/g;
  RRDp::cmd qq(graph "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "now-1$type+1$type"
      "--imgformat" "PNG"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "--step=$step"
      "--lower-limit=0.00"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "--alt-autoscale-max"
      "--upper-limit=0.1"
      "$vertical_label"
      "--units-exponent=1.00"
      "--alt-y-grid"
      "$xgrid"
      "$no_legend"
      "$disable_rrdtool_tag"
      "$font_def"
      "$font_tit"
      "DEF:used=$rrd:used_proc_min:AVERAGE"
      "CDEF:used_null=used,UN,0,used,IF"
      "CDEF:used_s=used_null,$step,*"
      "AREA:used_s#00FF00: Used mins per $time_range  "
      "GPRINT:used_s:AVERAGE: %4.2lf"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
  );
  my $answer = RRDp::read;
  if ( $$answer =~ "ERROR" ) {
    error( "$host:$server Graph rrdtool error : $$answer " . __FILE__ . ":" . __LINE__ );
  }

  return 0;
}

sub graph_cod_unreport {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $t           = "COMMENT: ";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT: ";
  my $head        = "COMMENT:                            Average   \\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST: %4.0lf";
    $head = "COMMENT:                            Average   Last\\n";
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_cod: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $rrd = "$wrkdir/$server/$host/$lpar.rr$type_sam";

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "Capacity on Demand - unreported:$last_txt$text";

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  #my $rrd_y = "";
  #if ( $type_sam =~ "y" ) {
  #  # u rocnich grafu nejdrive pouzit rrm data a pokud nejsou tak teprve rrd
  #  if ( $rrd !~ m/\.rrd$/ ) {
  #    $rrd_y = $rrd;
  #    $rrd_y =~ s/\.rrm$/\.rrd/;
  #    if ( -f $rrd_y ) {
  #     $rrd = $rrd_y;
  #    }
  #}

  #print "creating graph : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;
  my $start_time = "now-1$type";
  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=CoD in minutes";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  $rrd =~ s/:/\\:/g;

  #   "--lower-limit=0.00" --> it might be negative
  RRDp::cmd qq(graph "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "now-1$type+1$type"
      "--imgformat" "PNG"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "--step=$step"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "--alt-autoscale-max"
      "--upper-limit=0.1"
      "$vertical_label"
      "--units-exponent=1.00"
      "--alt-y-grid"
      "$xgrid"
      "$no_legend"
      "$disable_rrdtool_tag"
      "$font_def"
      "$font_tit"
      "$head"
      "DEF:unrep=$rrd:unreported_proc_min:AVERAGE"
      "LINE1:unrep#FF0000: Unreported minutes      "
      "GPRINT:unrep:AVERAGE: %4.0lf"
      "$t"
      "$t2"
      "HRULE:0#000000"
      "VRULE:0#000000"
  );
  my $answer = RRDp::read;
  if ( $$answer =~ "ERROR" ) {
    error( "$host:$server Graph rrdtool error : $$answer " . __FILE__ . ":" . __LINE__ );
  }

  return 0;
}

sub graph_osmem {
  my ( $host, $server, $lpar, $type, $name_out, $type_sam, $detail, $start_unix, $end_unix ) = @_;
  my $t        = "COMMENT:\" \"";
  my $t2       = "COMMENT:\\n";
  my $step_new = $step;
  my $last     = "COMMENT:\" \"";
  my $head     = "COMMENT:\"                            Average   \\n\"";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST: %4.0lf";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtoll complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_osmem: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;                    # some workaround, it should not go here
  }

  my $rrd = "$wrkdir/$server/$host/$lpar/mem.mmm";

  # print STDERR "9555 \$rrd $rrd\n";

  if ( $item eq "hmcmem" ) {
    $rrd  = "$wrkdir/--HMC--$host/mem.mmx";
    $lpar = "$host";
  }
  elsif ($hyperv) {

    # print STDERR "8314 $wrkdir / $host / $server / $lpar\n";
    if ( $item =~ 'hyp-mem' ) {    # VM disk
      $rrd = "$wrkdir/$server/$all_hyperv_VMs/$lpar.rrm";
    }
  }

  # print "001 MEM $rrd\n";

  my $lpar_slash = $lpar;
  if ($hyperv) {
    $lpar_slash = human_vmware_name( $lpar, "", $server );
  }
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacemnt for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $last_txt      = " last ";
  my $header_prefix = "OS Memory:";

  if ( $detail == 2 ) {
    $last_txt             = "";
    $lpar_slash_nmon_head = "" if $server eq "Linux";
    $header_prefix        = "MEM";
    if ( $wpar == 1 ) {
      $header_prefix = "MEM:";
    }
  }

  my $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  my $availmem = "";
  if ( $type =~ "d" || $hyperv ) {

    # my $rrd_last = rrd_file_actual ("$rrd"); # no it is hard-linked through all HMCs
    my $rrd_last = $rrd;
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    if ( $type =~ "d" ) {
      $t = "COMMENT:Updated\\:\" $l \"";
    }

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $type =~ "d" && $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;

          $last = "";

          #if ( $m_arr[2] > 0 ) {
          #  my $last_mem = sprintf( "%6.2d",$m_arr[2]) / 1024;
          #  my $last_mem_g = sprintf( "%.2f",$m_arr[2] / 1024);
          #  $last ="COMMENT:Last memory consuption in GB         $last_mem_g";
          #}
        }
        $availmem = $m_arr[6];    # AvailableMemory for hyperv VM
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  #print STDERR "graphing OSMEM   : $host:$server:$lpar_slash:$type_sam:$type\n";
  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $vertical_label = "--vertical-label=GB";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $xgrid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";

  my $form_dec = "%6.1lf";

  #print "graphing OSMEM   : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;
  if ( $wpar == 0 ) {
    if ( $item eq "hmcmem" ) {
      $rrd =~ s/:/\\:/g;

      $cmd .= " DEF:size=$rrd:size:AVERAGE";
      $cmd .= " DEF:used=$rrd:nuse:AVERAGE";
      $cmd .= " DEF:free=$rrd:free:AVERAGE";
      $cmd .= " DEF:in_use_work=$rrd:in_use_work:AVERAGE";
      $cmd .= " DEF:in_use_clnt=$rrd:in_use_clnt:AVERAGE";
      $cmd .= " DEF:pin=$rrd:pin:AVERAGE";
      $cmd .= " CDEF:free_g=free,1048576,/";
      $cmd .= " CDEF:usedg=used,1048576,/";
      $cmd .= " CDEF:in_use_clnt_g=in_use_clnt,1048576,/";
      $cmd .= " CDEF:used_realg=usedg,in_use_clnt_g,-";
      $cmd .= " CDEF:pin_g=pin,1048576,/";
      $cmd .= " COMMENT:\"   [GB]             AVRG      MAX  \\n\"";
      $cmd .= " AREA:usedg#FF4040:\" Used memory \"";
      $cmd .= " GPRINT:usedg:AVERAGE:\" $form_dec\"";
      $cmd .= " GPRINT:usedg:MAX:\" $form_dec\"";
      $cmd .= " $t2";
      $cmd .= " STACK:pin_g#0080FF:\" FS cache    \"";
      $cmd .= " GPRINT:pin_g:AVERAGE:\" $form_dec\"";
      $cmd .= " GPRINT:pin_g:MAX:\" $form_dec\"";
      $cmd .= " $t2";
      $cmd .= " STACK:free_g#00FF00:\" Free        \"";
      $cmd .= " GPRINT:free_g:AVERAGE:\" $form_dec\"";
      $cmd .= " GPRINT:free_g:MAX:\" $form_dec\"";
      $cmd .= " $t2";
      $cmd .= " $t";
      $cmd .= " HRULE:0#000000";

      #     $cmd .= " VRULE:0#000000"
      # print STDERR "\$cmd $cmd\n";
    }
    elsif ( $item eq 'hyp-mem' ) {
      $rrd =~ s/:/\\:/g;
      $cmd .= " DEF:size=$rrd:TotalPhysMemory:AVERAGE";
      $cmd .= " CDEF:sizeg=size,1024,/";
      $cmd .= " COMMENT:\"   [GB]             AVRG      MAX  \\n\"";
      if ( $availmem < 100 ) {

        # print STDERR "7987 found lower than 100 %\n";
        $cmd .= " DEF:avmemproc=$rrd:MemoryAvailable:AVERAGE";
        $cmd .= " CDEF:sizeused=100,avmemproc,-,sizeg,*,100,/";
        $cmd .= " CDEF:sizefree=sizeg,sizeused,-";
        $cmd .= " AREA:sizeused#FF4040:\" Used memory \"";
        $cmd .= " GPRINT:sizeused:AVERAGE:\" $form_dec\"";
        $cmd .= " GPRINT:sizeused:MAX:\" $form_dec\"";
        $cmd .= " $t2";
        $cmd .= " STACK:sizefree#00FF00:\" Free memory \"";
        $cmd .= " GPRINT:sizefree:AVERAGE:\" $form_dec\"";
        $cmd .= " GPRINT:sizefree:MAX:\" $form_dec\"";
      }
      else {
        $cmd .= " AREA:sizeg#FF4040:\" Used memory \"";
        $cmd .= " GPRINT:sizeg:AVERAGE:\" $form_dec\"";
        $cmd .= " GPRINT:sizeg:MAX:\" $form_dec\"";
      }
      $cmd .= " $t2";
      $cmd .= " $t";
      $cmd .= " HRULE:0#000000";

    }
    else {    # OS MEM

      # for LPM
      my @rrd_files;
      my $lpm_suff = "rrl";
      my $cgi      = 0;
      $rrd_files[0] = $rrd;    #actual is the first

      lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "mem.mmm", \@rrd_files, $cgi );

      #print STDERR "lpm_find_files is returning @rrd_files\n";

      my $i = -1;
      my $j;

      foreach $rrd (@rrd_files) {    # LPM cycle
        chomp($rrd);
        $i++;
        $j = $i - 1;
        $rrd =~ s/:/\\:/g;

        $cmd .= " DEF:size${i}=\"$rrd\":size:AVERAGE";
        $cmd .= " DEF:used${i}=\"$rrd\":nuse:AVERAGE";
        $cmd .= " DEF:free${i}=\"$rrd\":free:AVERAGE";
        $cmd .= " DEF:in_use_work${i}=\"$rrd\":in_use_work:AVERAGE";
        $cmd .= " DEF:in_use_clnt${i}=\"$rrd\":in_use_clnt:AVERAGE";
        $cmd .= " DEF:pin${i}=\"$rrd\":pin:AVERAGE";

        if ( $i == 0 ) {
          $cmd .= " CDEF:sizer${i}=size${i}";
          $cmd .= " CDEF:usedr${i}=used${i}";
          $cmd .= " CDEF:freer${i}=free${i}";
          $cmd .= " CDEF:in_use_workr${i}=in_use_work${i}";
          $cmd .= " CDEF:in_use_clntr${i}=in_use_clnt${i}";
          $cmd .= " CDEF:pinr${i}=pin${i}";
          next;
        }
        $cmd .= " CDEF:sizer${i}=sizer${j},UN,size${i},sizer${j},IF";
        $cmd .= " CDEF:usedr${i}=usedr${j},UN,used${i},usedr${j},IF";
        $cmd .= " CDEF:freer${i}=freer${j},UN,free${i},freer${j},IF";
        $cmd .= " CDEF:in_use_workr${i}=in_use_workr${j},UN,in_use_work${i},in_use_workr${j},IF";
        $cmd .= " CDEF:in_use_clntr${i}=in_use_clntr${j},UN,in_use_clnt${i},in_use_clntr${j},IF";
        $cmd .= " CDEF:pinr${i}=pinr${j},UN,pin${i},pinr${j},IF";
      }
      $cmd .= " CDEF:size=sizer${i}";
      $cmd .= " CDEF:used=usedr${i}";
      $cmd .= " CDEF:free=freer${i}";
      $cmd .= " CDEF:in_use_work=in_use_workr${i}";
      $cmd .= " CDEF:in_use_clnt=in_use_clntr${i}";
      $cmd .= " CDEF:pin=pinr${i}";

      $cmd .= " CDEF:free_g=free,1048576,/";
      $cmd .= " CDEF:usedg=used,1048576,/";
      $cmd .= " CDEF:in_use_clnt_g=in_use_clnt,1048576,/";
      $cmd .= " CDEF:used_realg=usedg,in_use_clnt_g,-";
      $cmd .= " CDEF:pin_g=pin,1048576,/";
      $cmd .= " COMMENT:\"   [GB]             AVRG      MAX  \\n\"";
      $cmd .= " AREA:used_realg$pastel_red:\" Used memory \"";
      $cmd .= " GPRINT:used_realg:AVERAGE:\" $form_dec\"";
      $cmd .= " GPRINT:used_realg:MAX:\" $form_dec\"";
      $cmd .= " $t2";
      $cmd .= " STACK:in_use_clnt_g$pastel_blue:\" FS cache    \"";
      $cmd .= " GPRINT:in_use_clnt_g:AVERAGE:\" $form_dec\"";
      $cmd .= " GPRINT:in_use_clnt_g:MAX:\" $form_dec\"";
      $cmd .= " $t2";
      $cmd .= " STACK:free_g$pastel_green:\" Free        \"";
      $cmd .= " GPRINT:free_g:AVERAGE:\" $form_dec\"";
      $cmd .= " GPRINT:free_g:MAX:\" $form_dec\"";
      $cmd .= " $t2";

      if ( !( $rrd =~ /Solaris/ || $rrd =~ /Linux/ ) ) {
        $cmd .= " LINE1:pin_g#000000:\" Pinned      \"";
        $cmd .= " GPRINT:pin_g:AVERAGE:\" $form_dec\"";
        $cmd .= " GPRINT:pin_g:MAX:\" $form_dec\"";
        $cmd .= " $t2";
      }
      $cmd .= " $t";
      $cmd .= " HRULE:0#000000";

      #      "VRULE:0#000000"

      # below should be ideal but it does not work .....
      #"--legend-direction=bottomup"
      #
      # initially : in_use_work_g + in_use_clnt_g (cache) + free_g == size
      # problem on AIX 5.3 when large pages (16MB) are used, then in_use_work_g does not cover them
      # Solution : (used - in_use_clnt_g)  + in_use_clnt_g (cache) + free_g == size
      #
      #   "$last"
    }
  }
  else {
    # WPARs
    $rrd =~ s/:/\\:/g;
    $cmd .= " DEF:size=\"$rrd\":size:AVERAGE";
    $cmd .= " DEF:used=\"$rrd\":nuse:AVERAGE";
    $cmd .= " DEF:free=\"$rrd\":free:AVERAGE";
    $cmd .= " DEF:in_use_work=\"$rrd\":in_use_work:AVERAGE";
    $cmd .= " DEF:in_use_clnt=\"$rrd\":in_use_clnt:AVERAGE";
    $cmd .= " DEF:pin=\"$rrd\":pin:AVERAGE";
    $cmd .= " CDEF:free_g=free,1048576,/";
    $cmd .= " CDEF:usedg=used,1048576,/";
    $cmd .= " CDEF:in_use_clnt_g=in_use_clnt,1048576,/";
    $cmd .= " CDEF:used_realg=usedg,in_use_clnt_g,-";
    $cmd .= " CDEF:pin_g=pin,1048576,/";
    $cmd .= " COMMENT:\"   [GB]             AVRG      MAX  \\n\"";
    $cmd .= " AREA:used_realg#FF4040:\" Used memory \"";
    $cmd .= " GPRINT:used_realg:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:used_realg:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " STACK:in_use_clnt_g#0080FF:\" FS cache    \"";
    $cmd .= " GPRINT:in_use_clnt_g:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:in_use_clnt_g:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:pin_g#000000:\" Pinned      \"";
    $cmd .= " GPRINT:pin_g:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:pin_g:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";

    #   "VRULE:0#000000"
  }

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_osmem : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_osmem_trend {
  my ( $host, $server, $lpar, $type, $name_out, $type_sam, $detail, $start_unix, $end_unix ) = @_;
  my $t        = "COMMENT:\" \"";
  my $t2       = "COMMENT:\\n";
  my $last     = "COMMENT: ";
  my $step_new = $step;
  my $xgrid    = "--x-grid=MONTH:1:MONTH:1:MONTH:1:0:%b";
  my $text     = text_set($type);

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }

  my $rrd = "$wrkdir/$server/$host/$lpar/mem.mmm";

  # print STDERR "9555 \$rrd $rrd\n";

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacemnt for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $last_txt      = " last ";
  my $header_prefix = "OS Memory:";
  my $header        = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

  #print STDERR "graphing OSMEM   : $host:$server:$lpar_slash:$type_sam:$type\n";
  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $vertical_label = "--vertical-label=GB";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --end now+1$type";
  $cmd .= " --start now-1$type";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width_trend";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $xgrid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";

  my $form_dec = "%6.1lf";

  # for LPM
  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first

  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "mem.mmm", \@rrd_files, $cgi );

  #print STDERR "lpm_find_files is returning @rrd_files\n";

  my $i = -1;
  my $j;

  foreach $rrd (@rrd_files) {    # LPM cycle
    chomp($rrd);
    $i++;
    $j = $i - 1;
    $rrd =~ s/:/\\:/g;

    $cmd .= " DEF:used${i}=\"$rrd\":nuse:AVERAGE";
    $cmd .= " DEF:used${i}_1m=\"$rrd\":nuse:AVERAGE:start=-1m";
    $cmd .= " DEF:used${i}_3m=\"$rrd\":nuse:AVERAGE:start=-3m";
    $cmd .= " DEF:used${i}_1y=\"$rrd\":nuse:AVERAGE:start=-1y";
    $cmd .= " DEF:in_use_clnt${i}=\"$rrd\":in_use_clnt:AVERAGE";
    $cmd .= " DEF:in_use_clnt${i}_1m=\"$rrd\":in_use_clnt:AVERAGE:start=-1m";
    $cmd .= " DEF:in_use_clnt${i}_3m=\"$rrd\":in_use_clnt:AVERAGE:start=-3m";
    $cmd .= " DEF:in_use_clnt${i}_1y=\"$rrd\":in_use_clnt:AVERAGE:start=-1y";

    if ( $i == 0 ) {
      $cmd .= " CDEF:usedr${i}=used${i}";
      $cmd .= " CDEF:usedr${i}_1m=used${i}_1m";
      $cmd .= " CDEF:usedr${i}_3m=used${i}_3m";
      $cmd .= " CDEF:usedr${i}_1y=used${i}_1y";
      $cmd .= " CDEF:in_use_clntr${i}=in_use_clnt${i}";
      $cmd .= " CDEF:in_use_clntr${i}_1m=in_use_clnt${i}_1m";
      $cmd .= " CDEF:in_use_clntr${i}_3m=in_use_clnt${i}_3m";
      $cmd .= " CDEF:in_use_clntr${i}_1y=in_use_clnt${i}_1y";
      next;
    }
    $cmd .= " CDEF:usedr${i}=usedr${j},UN,used${i},usedr${j},IF";
    $cmd .= " CDEF:usedr${i}_1m=usedr${j}_1m,UN,used${i}_1m,usedr${j}_1m,IF";
    $cmd .= " CDEF:usedr${i}_3m=usedr${j}_3m,UN,used${i}_3m,usedr${j}_3m,IF";
    $cmd .= " CDEF:usedr${i}_1y=usedr${j}_1y,UN,used${i}_1y,usedr${j}_1y,IF";
    $cmd .= " CDEF:in_use_clntr${i}=in_use_clntr${j},UN,in_use_clnt${i},in_use_clntr${j},IF";
    $cmd .= " CDEF:in_use_clntr${i}_1m=in_use_clntr${j}_1m,UN,in_use_clnt${i}_1m,in_use_clntr${j}_1m,IF";
    $cmd .= " CDEF:in_use_clntr${i}_3m=in_use_clntr${j}_3m,UN,in_use_clnt${i}_3m,in_use_clntr${j}_3m,IF";
    $cmd .= " CDEF:in_use_clntr${i}_1y=in_use_clntr${j}_1y,UN,in_use_clnt${i}_1y,in_use_clntr${j}_1y,IF";
  }
  $cmd .= " CDEF:used=usedr${i}";
  $cmd .= " CDEF:used_1m=usedr${i}_1m";
  $cmd .= " CDEF:used_3m=usedr${i}_3m";
  $cmd .= " CDEF:used_1y=usedr${i}_1y";
  $cmd .= " CDEF:in_use_clnt=in_use_clntr${i}";
  $cmd .= " CDEF:in_use_clnt_1m=in_use_clntr${i}_1m";
  $cmd .= " CDEF:in_use_clnt_3m=in_use_clntr${i}_3m";
  $cmd .= " CDEF:in_use_clnt_1y=in_use_clntr${i}_1y";

  $cmd .= " CDEF:usedg=used,1048576,/";
  $cmd .= " CDEF:usedg_1m=used_1m,1048576,/";
  $cmd .= " CDEF:usedg_3m=used_3m,1048576,/";
  $cmd .= " CDEF:usedg_1y=used_1y,1048576,/";
  $cmd .= " CDEF:in_use_clnt_g=in_use_clnt,1048576,/";
  $cmd .= " CDEF:in_use_clnt_g_1m=in_use_clnt_1m,1048576,/";
  $cmd .= " CDEF:in_use_clnt_g_3m=in_use_clnt_3m,1048576,/";
  $cmd .= " CDEF:in_use_clnt_g_1y=in_use_clnt_1y,1048576,/";
  $cmd .= " CDEF:used_realg=usedg,in_use_clnt_g,-";
  $cmd .= " CDEF:used_realg_1m=usedg_1m,in_use_clnt_g_1m,-";
  $cmd .= " CDEF:used_realg_3m=usedg_3m,in_use_clnt_g_3m,-";
  $cmd .= " CDEF:used_realg_1y=usedg_1y,in_use_clnt_g_1y,-";

  $cmd .= " VDEF:Dd=used_realg_1m,LSLSLOPE";
  $cmd .= " VDEF:Hd=used_realg_1m,LSLINT";
  $cmd .= " CDEF:used_real_1m=used_realg_1m,POP,Dd,COUNT,*,Hd,+";
  $cmd .= " VDEF:Dm=used_realg_3m,LSLSLOPE";
  $cmd .= " VDEF:Hm=used_realg_3m,LSLINT";
  $cmd .= " CDEF:used_real_3m=used_realg_3m,POP,Dm,COUNT,*,Hm,+";
  $cmd .= " VDEF:Dy=used_realg_1y,LSLSLOPE";
  $cmd .= " VDEF:Hy=used_realg_1y,LSLINT";
  $cmd .= " CDEF:used_real_1y=used_realg_1y,POP,Dy,COUNT,*,Hy,+";

  $cmd .= " COMMENT:\"   [GB]             AVRG           \\n\"";
  $cmd .= " LINE1:used_realg#FF0000:\" Used memory \"";
  $cmd .= " GPRINT:used_realg:AVERAGE:\" $form_dec\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:used_real_1m#0080FF:\" Used memory    - last 1 month trend\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:used_real_3m#80FFFF:\" Used memory    - last 3 months trend\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:used_real_1y#FF8080:\" Used memory    - last year trend\"";
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_osmem : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_oscpu {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $item       = shift;                                                     # "slan" or "ssan1" or "ssan2" or "ssea"
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t          = "COMMENT:\" \"";
  my $t2         = "COMMENT:\\n";
  my $step_new   = $step;
  my $last       = "COMMENT:\" \"";
  my $head       = "COMMENT:\"                            Average   \\n\"";

  #$server =~ s/--unknown//;
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST:\" %4.0lf\"";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_cpuos: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;                    # some workaround, it should not go here
  }
  my $rrd      = "";
  my $rrd_stol = "";
  if ( $server =~ /Solaris$/ ) {
    $rrd = "$wrkdir/Solaris--unknown/no_hmc/$lpar/cpu.mmm";
  }
  else {
    $rrd = "$wrkdir/$server/$host/$lpar/cpu.mmm";
    if ( -f "$wrkdir/$server/$host/$lpar/st-cpu.mmm" ) {
      $rrd_stol = "$wrkdir/$server/$host/$lpar/st-cpu.mmm";
    }
  }
  if ( $item eq "hmccpu" ) {
    $rrd  = "$wrkdir/--HMC--$host/cpu.mmx";
    $lpar = "$host";
  }

  # print "001 CPUOS $rrd\n";
  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $last_txt      = " last ";
  my $header_prefix = "OS CPU:";
  if ( $detail == 2 ) {
    $lpar_slash_nmon_head = "" if $server =~ "^Linux";
    $last_txt             = "";

    #print STDERR "15101 \$server $server\n";
    $header_prefix = "OSCPU";
    if ( $wpar == 1 ) {
      $header_prefix = "";
    }
  }
  my $header = "$header_prefix $lpar_slash_nmon_head:$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  if ( $type =~ "d" ) {

    # my $rrd_last = rrd_file_actual ("$rrd"); # no it is hard-linked through all HMCs
    my $rrd_last = $rrd;
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;

          $last = "";

          #if ( $m_arr[2] > 0 ) {
          #  my $last_mem = sprintf( "%6.2d",$m_arr[2]) / 1024;
          #  my $last_mem_g = sprintf( "%.2f",$m_arr[2] / 1024);
          #  $last ="COMMENT:Last memory consuption in GB         $last_mem_g";
          #}
        }
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $vertical_label = "--vertical-label=%";
  $vertical_label = "--vertical-label=\"CPU cores\"" if $rrd =~ /wpar/;

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # common part
  my $cmd = "";

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $xgrid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";

  my $form_dec = "%6.1lf";

  if ( $item eq "hmccpu" ) {

    #print "graphing CPUOS for hmc   : $host:$type_sam:$type\n" if $DEBUG ;
    $rrd =~ s/:/\\:/g;

    $cmd .= " --upper-limit=100";
    $cmd .= " --rigid";

    $cmd .= " DEF:cpui=$rrd:cpu_id:AVERAGE";
    $cmd .= " DEF:cpus=$rrd:cpu_sy:AVERAGE";
    $cmd .= " DEF:cpuu=$rrd:cpu_us:AVERAGE";
    $cmd .= " DEF:cpuw=$rrd:cpu_wa:AVERAGE";
    $cmd .= " CDEF:summ=cpus,cpuu,cpuw,cpui,+,+,+";
    $cmd .= " CDEF:cpusy=cpus,summ,/,100,*";
    $cmd .= " CDEF:cpuus=cpuu,summ,/,100,*";
    $cmd .= " CDEF:cpuwa=cpuw,summ,/,100,*";
    $cmd .= " CDEF:stog=100,cpusy,-,cpuus,-,cpuwa,-";
    $cmd .= " COMMENT:\"   [%]              AVRG      MAX  \\n\"";
    $cmd .= " AREA:cpusy#0080FF:\" Sys         \"";
    $cmd .= " GPRINT:cpusy:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpusy:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " STACK:cpuus$pastel_yellow:\" User        \"";
    $cmd .= " GPRINT:cpuus:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpuus:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " STACK:cpuwa#FF4040:\" IO wait     \"";
    $cmd .= " GPRINT:cpuwa:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpuwa:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " STACK:stog$pastel_green:\" Idle        \"";
    $cmd .= " GPRINT:stog:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:stog:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";
    $cmd .= " VRULE:0#000000";

    $cmd =~ s/\\"/"/g;

    eval {
      RRDp::cmd qq($cmd);
      $ret = RRDp::read;
    };
    if ($@) {
      error( "$host : Graph rrdtool error : graph_oscpu : $@ " . __FILE__ . ":" . __LINE__ );
      return 1;
    }
    $png_end_heading = ret_graph_param($ret);
    return 0;
  }

  # for LPM

  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first

  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "cpu.mmm", \@rrd_files, $cgi );

  #print STDERR "lpm_find_files is returning @rrd_files\n";

  my $i = -1;
  my $j;

  if ( $wpar == 0 ) {

    #print "graphing CPUOS   : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;

    $cmd .= " --upper-limit=100";
    $cmd .= " --rigid";

    foreach $rrd (@rrd_files) {    # LPM cycle
      chomp($rrd);
      $i++;
      $j = $i - 1;
      $rrd =~ s/:/\\:/g;

      $cmd .= " DEF:entitled${i}=\"$rrd\":entitled:AVERAGE";
      $cmd .= " DEF:cpusy${i}=\"$rrd\":cpu_sy:AVERAGE";
      $cmd .= " DEF:cpuus${i}=\"$rrd\":cpu_us:AVERAGE";
      $cmd .= " DEF:cpuwa${i}=\"$rrd\":cpu_wa:AVERAGE";

      # CPU stolen has different file
      if ( defined $rrd_stol && $rrd_stol ne "" ) {
        $rrd_stol =~ s/:/\\:/g;
        $cmd .= " DEF:cpustol${i}=\"$rrd_stol\":cpu_stol:AVERAGE";
      }
      if ( $i == 0 ) {
        $cmd .= " CDEF:entitledr${i}=entitled${i}";
        $cmd .= " CDEF:cpusyr${i}=cpusy${i}";
        $cmd .= " CDEF:cpuusr${i}=cpuus${i}";
        $cmd .= " CDEF:cpuwar${i}=cpuwa${i}";
        if ( defined $rrd_stol && $rrd_stol ne "" ) {
          $cmd .= " CDEF:cpustolr${i}=cpustol${i}";
        }
        next;
      }
      $cmd .= " CDEF:entitledr${i}=entitledr${j},UN,entitled${i},entitledr${j},IF";
      $cmd .= " CDEF:cpusyr${i}=cpusyr${j},UN,cpusy${i},cpusyr${j},IF";
      $cmd .= " CDEF:cpuusr${i}=cpuusr${j},UN,cpuus${i},cpuusr${j},IF";
      $cmd .= " CDEF:cpuwar${i}=cpuwar${j},UN,cpuwa${i},cpuwar${j},IF";
      if ( defined $rrd_stol && $rrd_stol ne "" ) {
        $cmd .= " CDEF:cpustolr${i}=cpustolr${j},UN,cpustol${i},cpustolr${j},IF";
      }
    }
    $cmd .= " CDEF:entitled=entitledr${i}";
    $cmd .= " CDEF:cpusy=cpusyr${i}";
    $cmd .= " CDEF:cpuus=cpuusr${i}";
    $cmd .= " CDEF:cpuwa=cpuwar${i}";
    if ( defined $rrd_stol && $rrd_stol ne "" ) {
      $cmd .= " CDEF:cpustol=cpustolr${i}";
    }

    if ( defined $rrd_stol && $rrd_stol ne "" ) {
      $cmd .= " CDEF:cpustola=cpustol,UN,0,cpustol,IF";              # cpu stolen was created after the cpu.mmm
      $cmd .= " CDEF:stog=100,cpusy,-,cpuus,-,cpuwa,-,cpustola,-";
    }
    else {
      $cmd .= " CDEF:stog=100,cpusy,-,cpuus,-,cpuwa,-";
    }
    $cmd .= " COMMENT:\"   [%]              AVRG      MAX  \\n\"";
    $cmd .= " AREA:cpusy#0080FF:\" Sys         \"";
    $cmd .= " GPRINT:cpusy:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpusy:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " STACK:cpuus#FFFF00:\" User        \"";
    $cmd .= " GPRINT:cpuus:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpuus:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " STACK:cpuwa#FF4040:\" IO wait     \"";
    $cmd .= " GPRINT:cpuwa:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpuwa:MAX:\" $form_dec\"";
    $cmd .= " $t2";

    if ( defined $rrd_stol && $rrd_stol ne "" ) {
      $cmd .= " STACK:cpustol#00FFFF:\" Stolen      \"";
      $cmd .= " GPRINT:cpustol:AVERAGE:\" $form_dec\"";
      $cmd .= " GPRINT:cpustol:MAX:\" $form_dec\"";
      $cmd .= " $t2";
    }
    $cmd .= " STACK:stog$pastel_green:\" Idle        \"";
    $cmd .= " GPRINT:stog:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:stog:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";

    #  "VRULE:0#000000"
  }
  else {    # WPARs
    $rrd =~ s/:/\\:/g;

    $cmd .= " DEF:pc=\"$rrd\":entitled:AVERAGE";
    $cmd .= " DEF:cpusy=\"$rrd\":cpu_sy:AVERAGE";
    $cmd .= " DEF:cpuus=\"$rrd\":cpu_us:AVERAGE";
    $cmd .= " CDEF:proc=pc,100,/";
    $cmd .= " CDEF:cpusyc=cpusy,proc,*";
    $cmd .= " CDEF:cpuusc=cpuus,proc,*";
    $cmd .= " COMMENT:\"CPU cores           AVRG      MAX  \\n\"";
    $cmd .= " AREA:cpusyc#0080FF:\" Sys         \"";
    $cmd .= " GPRINT:cpusyc:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpusyc:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " STACK:cpuusc#FFFF00:\" User        \"";
    $cmd .= " GPRINT:cpuusc:AVERAGE:\" $form_dec\"";
    $cmd .= " GPRINT:cpuusc:MAX:\" $form_dec\"";
    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";

    # $cmd .= " VRULE:0#000000";
  }

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_oscpu : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_paging {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t          = "COMMENT:\" \"";
  my $t2         = "COMMENT:\"\\n\"";
  my $step_new   = $step;
  my $last       = "COMMENT: ";
  my $head       = "COMMENT:                            Average   Max\\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  # print STDERR "15396 $item $host\n";
  # due to historical reports where is specific time passed
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST: %4.0lf";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_paging: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;                    # some workaround, it should not go here
  }

  my $rrd = "$wrkdir/$server/$host/$lpar/pgs.mmm";

  if ($hyperv) {
    $rrd = "$wrkdir/$server/$host/pool.rrm";
  }

  # print "001 pgs $rrd\n";

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $last_txt      = " last ";
  my $header_prefix = "paging 1:";

  if ( $detail == 2 ) {
    $last_txt             = "";
    $header_prefix        = "PG1";
    $lpar_slash_nmon_head = "" if $server eq "Linux";
    if ( $wpar == 1 ) {
      $header_prefix = "PG1";
    }
  }

  my $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";
  if ( $item eq "hyppg1" && $detail != 2 ) {
    $header = "$header_prefix $host :$last_txt$text";
  }

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
      if ( $item eq "hyppg1" ) {
        $header = "$header_prefix $host:$start_human - $end_human";
      }
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
        if ( $item eq "hyppg1" ) {
          $header = "$server : $header_prefix $host : $start_human - $end_human";
        }
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  if ( $type =~ "d" ) {

    # my $rrd_last = rrd_file_actual ("$rrd"); # no it is hard-linked through all HMCs
    my $rrd_last = $rrd;
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;

          $last = "";

          #if ( $m_arr[2] > 0 ) {
          #  my $last_mem = sprintf( "%6.2d",$m_arr[2]) / 1024;
          #  my $last_mem_g = sprintf( "%.2f",$m_arr[2] / 1024);
          #  $last ="COMMENT:Last memory consumption in GB         $last_mem_g";
          #}
        }
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( !-f "$rrd" ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $filter = $filter_max_paging;
  if ($hyperv) {
    $filter *= 1000;    # seems to be better
  }

  # values in rrdtool are in pages == 4096B
  if ( $type =~ m/y/ ) {

    # lower limits for yearly graphs as they are averaged ....
    $filter = $filter / 10;
  }
  if ( $type =~ m/m/ ) {

    # lower limits for monthly graphs as they are averaged ....
    $filter = $filter / 2;
  }

  my $vertical_label = "--vertical-label=MB/sec";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # for LPM
  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first

  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "pgs.mmm", \@rrd_files, $cgi );

  # print STDERR "8627 lpm_find_files is returning @rrd_files\n";

  # print STDERR "graphing PAGING   : $rrd: $host:$server:$lpar_slash:$type_sam:$type:$start_time:$end_time,\$detail $detail,\$header $header \$no_legend $no_legend\n";

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $cmd = "";

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";
  $cmd .= " --base=1024";

  my $i = -1;
  my $j;

  foreach $rrd (@rrd_files) {    # LPM cycle
    chomp($rrd);
    $i++;
    $j = $i - 1;
    $rrd =~ s/:/\\:/g;

    if ($hyperv) {
      $cmd .= " DEF:pagein${i}=\"$rrd\":PagesInputPersec:AVERAGE";
      $cmd .= " DEF:pageout${i}=\"$rrd\":PagesOutputPersec:AVERAGE";
    }
    else {
      $cmd .= " DEF:pagein${i}=\"$rrd\":page_in:AVERAGE";
      $cmd .= " DEF:pageout${i}=\"$rrd\":page_out:AVERAGE";
    }
    if ( $i == 0 ) {
      $cmd .= " CDEF:pageinr${i}=pagein${i}";
      $cmd .= " CDEF:pageoutr${i}=pageout${i}";
      next;
    }
    $cmd .= " CDEF:pageinr${i}=pageinr${j},UN,pagein${i},pageinr${j},IF";
    $cmd .= " CDEF:pageoutr${i}=pageoutr${j},UN,pageout${i},pageoutr${j},IF";
  }
  $cmd .= " CDEF:pagein=pageinr${i}";
  $cmd .= " CDEF:pageout=pageoutr${i}";

  $cmd .= " CDEF:pagein_b_nf=pagein,4096,*";                                # 4 kiB pages
  $cmd .= " CDEF:pageout_b_nf=pageout,4096,*";
  $cmd .= " CDEF:pagein_b=pagein_b_nf,$filter,GT,UNKN,pagein_b_nf,IF";
  $cmd .= " CDEF:pageout_b=pageout_b_nf,$filter,GT,UNKN,pageout_b_nf,IF";
  if ($hyperv) {
    $cmd .= " CDEF:pagein_mb=pagein_b,1048576,/,300,/";                     # 5 mins perf data
    $cmd .= " CDEF:pagein_mb_neg=pagein_mb,-1,*";
    $cmd .= " CDEF:pageout_mb=pageout_b,1048576,/,300,/";
  }
  else {
    $cmd .= " CDEF:pagein_mb=pagein_b,1048576,/";
    $cmd .= " CDEF:pagein_mb_neg=pagein_mb,-1,*";
    $cmd .= " CDEF:pageout_mb=pageout_b,1048576,/";
  }
  $cmd .= " COMMENT:\"[MB/sec]     Avrg      Max\\n\"";
  $cmd .= " LINE1:pageout_mb#0080FF:\" Page out    \"";
  $cmd .= " GPRINT:pageout_mb:AVERAGE:\" %6.3lf\"";
  $cmd .= " GPRINT:pageout_mb:MAX:%6.3lf";
  $cmd .= " $t2";
  $cmd .= " LINE1:pagein_mb_neg#FF4040:\" Page in     \"";
  $cmd .= " GPRINT:pagein_mb:AVERAGE:\" %6.3lf\"";
  $cmd .= " GPRINT:pagein_mb:MAX:%6.3lf";

  #  if ( $graph_un ) {
  #    $cmd .= " CDEF:unavailable=pagein_mb,UN,INF,0,IF";
  #    $cmd .= " AREA:unavailable$color_un";
  #    $cmd .= " CDEF:unavailable_out=pageout_mb,UN,INF,0,IF,-1,*";
  #    $cmd .= " AREA:unavailable_out$color_un";
  #  }
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  #      " VRULE:0#000000"

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_paging : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_multihmc_tot    # CPU
{
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time_human = "";
  my $end_time_human   = "";
  my $server_vmw_name  = "";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time       = $start_unix;
      $end_time         = $end_unix;
      $xgrid            = "";
      $start_time_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      $end_time_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    }
  }

  # print STDERR "10675 \$item $item \$host $host \$type $type \$server $server \$lpar $lpar \n";
  my $tmp_file = "$basedir/tmp/multi-hmc-$host-$type-total.cmd";
  if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-$host-d-total.cmd"; }        # Reporter TimeRange mode
  my $tmp_file_web = "/var/tmp/multi-hmc-$host-$type-web-total.cmd";
  if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-$host-d-web-total.cmd"; }    # Reporter TimeRange mode

  if ( $item eq "clustser" ) {
    $tmp_file = "$basedir/tmp/multi-hmc-$server-$host-$type-total.cmd";
    if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-$server-$host-d-total.cmd"; }        # Reporter TimeRange mode
    $tmp_file_web = "/var/tmp/multi-hmc-$server-$host-$type-web-total.cmd";
    if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-$server-$host-d-web-total.cmd"; }    # Reporter TimeRange mode
    ( my $rrd, $server_vmw_name ) = find_human_cluster_name();
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  # replace graph size and total value
  open( FH, "< $tmp_file" ) || error( "multihmc detail: Can't open $tmp_file : $!" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @lines = <FH>;
  close(FH);
  my $cmd = "";
  foreach my $line (@lines) {
    $line =~ s/graph .* --title/$graph_cmd \"$name_out\" --title/;
    $line =~ s/ --start .* --end .* --imgformat PNG/ --start $start_time --end $end_time --imgformat PNG /;
    $line =~ s/ --width=[0-9]+/ --width=$width  $font_def /;
    $line =~ s/ --height=[0-9]+/ --height=$height $font_tit $disable_rrdtool_tag $no_legend /;

    # change canvas color
    $line =~ s/#$pic_col_orig/#$pic_col/g;

    if ( $detail == 9 ) {

      # --title "Servers aggregated : last day" --start
      my $s_start = index( $line, "--title \"" ) + 9;
      my $s_stop  = index( $line, " --start" ) - 1;
      $html_heading = substr( $line, $s_start, $s_stop - $s_start );
      $line =~ s/$html_heading//;
      if ( $start_time_human ne "" ) {
        $html_heading =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
      }
    }
    else {

      if ( $start_time_human ne "" && $width < 700 ) {    # means hist reports or zoom
                                                          #$line =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          #$line =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          #$line =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          #$line =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          # new zoom is a small picture
        $line =~ s/--title.*: last day/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last month/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last week/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last year/--title \" $start_time_human - $end_time_human/;
      }
      elsif ( $start_time_human ne "" ) {
        $line =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
      }
    }
    $line =~ s/ --x-grid=.* COMMENT:\"Utilization/ $xgrid COMMENT:\"Utilization/;
    if ( $detail == 2 ) {
      $line =~ s/ --vertical-label=.* --units/ --units/;
      $line =~ s/last //;
    }
    $cmd = $line;
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "multihmc detail: Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($$ret);
  return 0;
}

sub graph_multihmc    # CPU
{
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time_human = "";
  my $end_time_human   = "";
  my $server_vmw_name  = "";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time       = $start_unix;
      $end_time         = $end_unix;
      $xgrid            = "";
      $start_time_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      $end_time_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    }
  }

  # print STDERR "10675 \$item $item \$host $host \$type $type \$server $server \$lpar $lpar \n";
  my $tmp_file = "$basedir/tmp/multi-hmc-$host-$type.cmd";
  if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-$host-d.cmd"; }        # Reporter TimeRange mode
  my $tmp_file_web = "/var/tmp/multi-hmc-$host-$type-web.cmd";
  if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-$host-d-web.cmd"; }    # Reporter TimeRange mode

  if ( $item eq "clustser" ) {
    $tmp_file = "$basedir/tmp/multi-hmc-$server-$host-$type.cmd";
    if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-$server-$host-d.cmd"; }        # Reporter TimeRange mode
    $tmp_file_web = "/var/tmp/multi-hmc-$server-$host-$type-web.cmd";
    if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-$server-$host-d-web.cmd"; }    # Reporter TimeRange mode
    ( my $rrd, $server_vmw_name ) = find_human_cluster_name();
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  # replace graph size and total value
  open( FH, "< $tmp_file" ) || error( "multihmc detail: Can't open $tmp_file : $!" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @lines = <FH>;
  close(FH);
  my $cmd = "";
  foreach my $line (@lines) {
    $line =~ s/graph .* --title/$graph_cmd \"$name_out\" --title/;
    $line =~ s/ --start .* --end .* --imgformat PNG/ --start $start_time --end $end_time --imgformat PNG /;
    $line =~ s/ --width=[0-9]+/ --width=$width  $font_def /;
    $line =~ s/ --height=[0-9]+/ --height=$height $font_tit $disable_rrdtool_tag $no_legend /;

    # change canvas color
    $line =~ s/#$pic_col_orig/#$pic_col/g;

    if ( $detail == 9 ) {

      # --title "Servers aggregated : last day" --start
      my $s_start = index( $line, "--title \"" ) + 9;
      my $s_stop  = index( $line, " --start" ) - 1;
      $html_heading = substr( $line, $s_start, $s_stop - $s_start );
      $line =~ s/$html_heading//;
      if ( $start_time_human ne "" ) {
        $html_heading =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
      }
    }
    else {

      if ( $start_time_human ne "" && $width < 700 ) {    # means hist reports or zoom
                                                          #$line =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          #$line =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          #$line =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          #$line =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                          # new zoom is a small picture
        $line =~ s/--title.*: last day/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last month/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last week/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last year/--title \" $start_time_human - $end_time_human/;
      }
      elsif ( $start_time_human ne "" ) {
        $line =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
      }
    }
    $line =~ s/ --x-grid=.* COMMENT:\"Utilization/ $xgrid COMMENT:\"Utilization/;
    if ( $detail == 2 ) {
      $line =~ s/ --vertical-label=.* --units/ --units/;
      $line =~ s/last //;
    }
    $cmd = $line;
  }

  # print STDERR "12797 \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "multihmc detail: Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($$ret);
  return 0;
}

# omit the DEF:... lines for vm_uuid, which is not approved by ACL
sub vmware_aggreg_test_acl {
  my $line_ref = shift;
  my $item     = shift;

  my $atom_separator = " DEF:utiltot_mhz";
  $atom_separator = " DEF:CPU_ready_msx" if $item eq "clustlpardy";

  my @arr_line     = split( $atom_separator, @$line_ref[0] );    #it is always only one line
                                                                 # first item is the beginning of rrdtool cmd structure
                                                                 # last item contains both last graph line and end of rrdtool cmd structure, this must be kept aside
  my $last_rrd_cmd = " COMMENT:";
  if ( index( $arr_line[-1], $last_rrd_cmd ) eq -1 ) {
    $last_rrd_cmd = " HRULE:";
  }
  ( $arr_line[-1], my $cmd_end ) = split( "$last_rrd_cmd", $arr_line[-1] );
  my $counter = 0;
  my @new_arr = ();
  foreach (@arr_line) {
    my $atom = $_;

    # print STDERR "12676 \$atom $atom\n";
    $counter++;
    next if $counter eq 1;

    # get VM uuid from (DEF:utiltot_mhz)44="/home/lpar2rrd/lpar2rrd/data/vmware_VMs/501c657d-7f5e-9ebb-3ae7-9be18e2ac9fa.rrm":CPU_usage:AVERAGE CDEF:utiltot_ghz...
    ( my $uuid, undef ) = split /\.rrm/, $atom;
    $uuid =~ s/.*_VMs\///;

    # print STDERR "12680 \$uuid ,$uuid,\n";
    next if check_vm_uuid_acl($uuid);
    push @new_arr, "$atom_separator$atom";
  }
  unshift @new_arr, $arr_line[0];
  $new_arr[-1] = $new_arr[-1] . "$last_rrd_cmd$cmd_end";

  # if the line with 'AREA:" is omitted, change 1st STACK: to it
  if ( index( $new_arr[1], "AREA:" ) eq -1 ) {
    $new_arr[1] =~ s/STACK:/AREA:/;
  }
  $$line_ref[0] = join '', @new_arr;

  # print STDERR "12687 \@new_arr @new_arr\n";
}

sub check_vm_uuid_acl {
  my $uuid = shift;

  # print STDERR "12697 ,$uuid\n";
  # return 1 if $uuid eq '501c487b-66db-574a-1578-8bb38694a41f'; # vm-jindra :)
  return 0;
}

sub graph_multihmclpar {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time_human = "";
  my $end_time_human   = "";
  my $server_vmw_name  = "";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "";
      }
      $start_time_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      $end_time_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    }
  }

  # print STDERR "8096 detail-graph-cgi.pl \$host $host \$server $server \$lpar $lpar \$detail $detail \$type $type\n";
  my $tmp_file = "$basedir/tmp/multi-hmc-lpar-$host-$type.cmd";
  if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-lpar-$host-d.cmd"; }        # Reporter TimeRange mode
  my $tmp_file_web = "/var/tmp/multi-hmc-lpar-$host-$type-web.cmd";
  if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-lpar-$host-d-web.cmd"; }    # Reporter TimeRange mode

  if ( $item eq "clustlpar" ) {
    $tmp_file = "$basedir/tmp/multi-hmc-lpar-$server-$host-$type.cmd";
    if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-lpar-$server-$host-d.cmd"; }        # Reporter TimeRange mode
    $tmp_file_web = "/var/tmp/multi-hmc-lpar-$server-$host-$type-web.cmd";
    if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-lpar-$server-$host-d-web.cmd"; }    # Reporter TimeRange mode
    ( undef, $server_vmw_name ) = find_human_cluster_name();
  }

  if ( $item eq "clustlpardy" ) {
    $tmp_file = "$basedir/tmp/multi-hmc-lpar-rdy-$server-$host-$type.cmd";
    if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-lpar-rdy-$server-$host-d.cmd"; }        # Reporter TimeRange mode
    $tmp_file_web = "/var/tmp/multi-hmc-lpar-rdy-$server-$host-$type-web.cmd";
    if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-lpar-rdy-$server-$host-d-web.cmd"; }    # Reporter TimeRange mode
    ( undef, $server_vmw_name ) = find_human_cluster_name();
  }

  if ( $item eq "rplpar" ) {
    $tmp_file = "$basedir/tmp/multi-hmc-lpar-$server-$lpar-$type.cmd";
    if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/multi-hmc-lpar-$server-$lpar-d.cmd"; }            # Reporter TimeRange mode
    $tmp_file_web = "/var/tmp/multi-hmc-lpar-$server-$lpar-$type-web.cmd";
    if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/multi-hmc-lpar-$server-$lpar-d-web.cmd"; }        # Reporter TimeRange mode
    ( undef, $server_vmw_name ) = find_human_cluster_name();
    $server_vmw_name .= ": " . find_human_rpool_name($lpar);
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  # replace graph size
  # print STDERR "8870 detail-graph-cgi.pl \$tmp_file $tmp_file \$graph_cmd $graph_cmd \$name_out $name_out\n";
  open( FH, "< $tmp_file" ) || error( "multihmclpar detail: Can't open $tmp_file : $! " . __FILE__ . ":" . __LINE__ ) && return 0;
  my @lines = <FH>;
  close(FH);
  if ( index( $lines[0], "DEF:" ) eq -1 ) {
    error("no VMs in $tmp_file\n");
    return;
  }
  if ( $vmware && ( $item eq "clustlpar" or $item eq "rplpar" or $item eq "multihmclpar" or $item eq "clustlpardy" ) ) {
    vmware_aggreg_test_acl( \@lines, $item );
  }

  # print STDERR "12774 \\@lines \@lines\n";

  my $cmd = "";
  foreach my $line (@lines) {
    $line =~ s/graph .* --title/$graph_cmd \"$name_out\" --title/;
    $line =~ s/ --start .* --end .* --imgformat PNG/ --start $start_time --end $end_time --imgformat PNG /;
    $line =~ s/ --width=[0-9]+/ --width=$width  $font_def /;
    $line =~ s/ --height=[0-9]+/ --height=$height $font_tit $disable_rrdtool_tag $no_legend /;

    # change canvas color
    $line =~ s/#$pic_col_orig/#$pic_col/g;
    if ( $detail == 10 ) {
      $line =~ s/ --width=[0-9]+ / --width=$width  $font_def_reporter /;
      $line =~ s/ --height=[0-9]+ / --height=$height $font_tit_reporter /;
      $line =~ s/ --color=BACK#[A-Za-z0-9]+ / --color=BACK#FFF /;
      $line =~ s/ --color=SHADEA#[A-Za-z0-9]+ / --color=SHADEA#FFF /;
      $line =~ s/ --color=SHADEB#[A-Za-z0-9]+ / --color=SHADEB#FFF /;
      $line =~ s/ --color=CANVAS#[A-Za-z0-9]+ / --color=CANVAS#FFF /;
    }

    #  print STDERR "8456 \$item $item \$xgrid ,$xgrid, \$start_time_human ,$start_time_human,\n";
    if ( $detail == 9 ) {

      # --title "Servers aggregated : last day" --start
      my $s_start = index( $line, "--title \"" ) + 9;
      my $s_stop  = index( $line, " --start" ) - 1;
      $html_heading = substr( $line, $s_start, $s_stop - $s_start );
      $line =~ s/$html_heading//;
      if ( $start_time_human ne "" ) {
        $html_heading =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
        $html_heading =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
      }

      #print STDERR "8891 \$html_heading $html_heading\n \$line $line";
    }
    else {
      if ( $start_time_human ne "" && $width < 700 && $detail != 10 ) {    # means hist reports or zoom
                                                                           #$line =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                                           #$line =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                                           #$line =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                                           #$line =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
                                                                           # new zoom is a small picture
        $line =~ s/--title.*: last day/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last month/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last week/--title \" $start_time_human - $end_time_human/;
        $line =~ s/--title.*: last year/--title \" $start_time_human - $end_time_human/;
      }
      elsif ( $start_time_human ne "" ) {
        $line =~ s/: last day/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last month/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last week/ $server_vmw_name: $start_time_human - $end_time_human/;
        $line =~ s/: last year/ $server_vmw_name: $start_time_human - $end_time_human/;
      }
    }
    $line =~ s/ --x-grid=.* COMMENT:\"Utilization/ $xgrid COMMENT:\"Utilization/;
    $line =~ s/ --x-grid=.* COMMENT:\"VM READY/ $xgrid COMMENT:\"VM READY/;
    if ( $detail == 2 ) {
      $line =~ s/ --vertical-label=.* --units/ --units/;
      $line =~ s/last //;
    }
    $cmd = $line;
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "multihmclpar detail: Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $picture = do {
    local $/ = undef;
    open my $fh, "<", $name_out || error( "Cannot open  $name_out: $!" . __FILE__ . ":" . __LINE__ ) && return 0;
    <$fh>;
  };
  $png_end_heading = ret_graph_param($$ret);
  return 0;
}

sub graph_custom_trend {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $name_source = shift;

  #print STDERR "graph custom params $host,$server,$lpar,$type,$name_out,$type_sam,$detail,$start_unix,$end_unix,$name_source,\n";
  my $hist_rep = 0;

  my $start_time_human = "";
  my $end_time_human   = "";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time = "now-1$type";
  my $end_time   = "now+1$type";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $hist_rep         = 1;
      $start_time       = $start_unix;
      $end_time         = $end_unix;
      $xgrid            = "";
      $start_time_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      $end_time_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    }
  }

  my $tmp_file = "$basedir/tmp/$name_source-$lpar-cpu_trend-$type.cmd";
  if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/$name_source-$lpar-cpu_trend-d.cmd"; }    # Reporter TimeRange mode
  my $tmp_file_web = "/var/tmp/$name_source-$lpar-$type-web.cmd";
  if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/$name_source-$lpar-d-web.cmd"; }          # Reporter TimeRange mode

  # replace graph size and other params
  open( FH, "< $tmp_file" ) || error( "custom detail: Can't open $tmp_file : $!" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @lines = <FH>;
  close(FH);
  my $cmd = "";

  my $no_legend_too = "";

  #if ( $rrd_legend eq "table" ) {
  #  $no_legend_too = "--no-legend ";
  #}

  foreach my $line (@lines) {
    $line =~ s/graph .* --title/$graph_cmd \"$name_out\" --title/;
    $line =~ s/ --start .* --end .* --imgformat PNG/ --start $start_time --end $end_time --imgformat PNG /;

    # change canvas color
    $line =~ s/#$pic_col_orig/#$pic_col/g;
    if ( $detail == 1 ) {
      $line =~ s/ --width=[0-9]+/ --width=$width  $font_def_popup  /;
      $line =~ s/ --height=[0-9]+/ --height=$height $font_tit_popup /;
    }
    if ( $detail == 0 ) {
      $line =~ s/ --width=[0-9]+/ --width=$width  $font_def $no_legend_too/;
      $line =~ s/ --height=[0-9]+/ --height=$height $font_tit /;
    }
    if ( $detail == 10 ) {
      $line =~ s/ --width=[0-9]+ / --width=$width  $font_def_reporter /;
      $line =~ s/ --height=[0-9]+ / --height=$height $font_tit_reporter /;
      $line =~ s/ --color=BACK#[A-Za-z0-9]+ / --color=BACK#FFF /;
      $line =~ s/ --color=SHADEA#[A-Za-z0-9]+ / --color=SHADEA#FFF /;
      $line =~ s/ --color=SHADEB#[A-Za-z0-9]+ / --color=SHADEB#FFF /;
      $line =~ s/ --color=CANVAS#[A-Za-z0-9]+ / --color=CANVAS#FFF /;
    }
    $cmd = $line;
  }

  # prepare Updated
  my $updated = substr( $cmd, index( $cmd, "Updated" ), index( $cmd, "HRULE" ) - index( $cmd, "Updated" ) - 2 );
  $updated =~ s/\\//g;
  $updated =~ s/COMMENT://g;
  $updated =~ s/\"//g;
  $updated =~ s/ l//g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "custom detail: Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $$ret, $updated );
  return 0;
}

sub graph_custom {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $name_source = shift;

  #print STDERR "9035 graph custom params $host,$server,$lpar,$type,$name_out,$type_sam,$detail,$start_unix,$end_unix,$name_source,\n";

  #  $item = "customosmem" if $item eq "custom_linux_mem";

  my $hist_rep = 0;

  my $start_time_human = "";
  my $end_time_human   = "";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $hist_rep   = 1;             # hist reports or zoom
      $type       = 'm';
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "";
      }
      $start_time_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      $end_time_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    }
  }

  my $tmp_file = "$basedir/tmp/$name_source-$lpar-$type.cmd";

  #print STDERR "line-12383: $host,$server,$lpar,$type,$name_out,$type_sam,$detail,$start_unix,$end_unix,$name_source, $tmp_file\n";
  if ( $type eq "a" ) { $tmp_file = "$basedir/tmp/$name_source-$lpar-d.cmd"; }        # Reporter TimeRange mode
  my $tmp_file_web = "/var/tmp/$name_source-$lpar-$type-web.cmd";
  if ( $type eq "a" ) { $tmp_file_web = "/var/tmp/$name_source-$lpar-d-web.cmd"; }    # Reporter TimeRange mode

  # replace graph size and other params
  open( FH, "< $tmp_file" ) || error( "custom detail: Can't open $tmp_file : $!" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @lines = <FH>;
  close(FH);
  my $cmd = "";

  my $no_legend_too = "";
  if ( $rrd_legend eq "table" ) {
    $no_legend_too = "--no-legend ";
  }
  foreach my $line (@lines) {
    $line =~ s/graph .* --title/$graph_cmd \"$name_out\" --title/;
    $line =~ s/ --start .* --end .* --imgformat PNG/ --start $start_time --end $end_time --imgformat PNG /;

    # change canvas color
    $line =~ s/#$pic_col_orig/#$pic_col/g;

    # print STDERR "8630 detail-graph-cgi.pl \$hist_rep $hist_rep \$detail $detail \$width $width\n";
    if ( $hist_rep == 1 ) {    # hist reports or zoom
      if ( $detail == 1 ) {
        $line =~ s/ --width=[0-9]+/ --width=$width  $font_def_popup  /;
        $line =~ s/ --height=[0-9]+/ --height=$height $font_tit_popup /;
      }
      if ( $detail == 0 || $detail == 9 ) {
        $line =~ s/ --width=[0-9]+/ --width=$width  $font_def_hist $no_legend_too/;
        $line =~ s/ --height=[0-9]+/ --height=$height $font_tit_hist /;
      }
      if ( $detail != 10 ) {
        $line =~ s/ --width=[0-9]+/ --width=$width $font_def_hist/;
        $line =~ s/ --height=[0-9]+/ --height=$height $font_tit_hist/;
        $line =~ s/ --x-grid=.*:%[a-z,A-Z] / /;
      }
      if ( $detail == 10 ) {
        $line =~ s/ --width=[0-9]+/ --width=$width  $font_def_reporter  /;
        $line =~ s/ --height=[0-9]+/ --height=$height $font_tit_reporter /;
        $line =~ s/ --color=BACK#[A-Za-z0-9]+ / --color=BACK#FFF /;
        $line =~ s/ --color=SHADEA#[A-Za-z0-9]+ / --color=SHADEA#FFF /;
        $line =~ s/ --color=SHADEB#[A-Za-z0-9]+ / --color=SHADEB#FFF /;
        $line =~ s/ --color=CANVAS#[A-Za-z0-9]+ / --color=CANVAS#FFF /;
        $line =~ s/ --x-grid=.*:%[a-z,A-Z] / $xgrid /;
      }
      if ( $width < 700 && $detail != 10 ) {    # cus zoom can be only a small picture
        if ( $detail == 9 ) {

          # --title "Servers aggregated : last day" --start
          my $s_start = index( $line, "--title \"" ) + 9;
          my $s_stop  = index( $line, " --start" ) - 1;
          $html_heading = substr( $line, $s_start, $s_stop - $s_start );
          $line =~ s/$html_heading//;
        }
        else {
          $line =~ s/--title.*: last day/--title \" $start_time_human - $end_time_human/;
          $line =~ s/--title.*: last month/--title \" $start_time_human - $end_time_human/;
          $line =~ s/--title.*: last week/--title \" $start_time_human - $end_time_human/;
          $line =~ s/--title.*: last year/--title \" $start_time_human - $end_time_human/;
        }
      }
      else {
        if ( $detail == 9 ) {

          # --title "Servers aggregated : last day" --start
          my $s_start = index( $line, "--title \"" ) + 9;
          my $s_stop  = index( $line, " --start" ) - 1;
          $html_heading = substr( $line, $s_start, $s_stop - $s_start );
          $line =~ s/$html_heading//;

          $html_heading =~ s/: last day/ : $start_time_human - $end_time_human/;
          $html_heading =~ s/: last month/ : $start_time_human - $end_time_human/;
          $html_heading =~ s/: last week/ : $start_time_human - $end_time_human/;
          $html_heading =~ s/: last year/ : $start_time_human - $end_time_human/;
        }
        else {
          $line =~ s/: last day/ : $start_time_human - $end_time_human/;
          $line =~ s/: last month/ : $start_time_human - $end_time_human/;
          $line =~ s/: last week/ : $start_time_human - $end_time_human/;
          $line =~ s/: last year/ : $start_time_human - $end_time_human/;
        }
      }
    }
    else {
      if ( $detail == 9 ) {

        # --title "Servers aggregated : last day" --start
        my $s_start = index( $line, "--title \"" ) + 9;
        my $s_stop  = index( $line, " --start" ) - 1;
        $html_heading = substr( $line, $s_start, $s_stop - $s_start );
        $line =~ s/$html_heading//;
      }
      if ( $detail == 1 ) {
        $line =~ s/ --width=[0-9]+/ --width=$width  $font_def  /;
        $line =~ s/ --height=[0-9]+/ --height=$height $font_tit /;
        $line =~ s/ --x-grid=.*:%[a-z,A-Z] / $xgrid /;
      }
      if ( $detail == 2 ) {
        $line =~ s/ --width=[0-9]+/ --width=$width $font_def  /;
        $line =~ s/ --height=[0-9]+/ --height=$height $font_tit $no_legend $disable_rrdtool_tag /;
        $line =~ s/: last /: /;
        $line =~ s/ Custom group[^:]*://;
        $line =~ s/ 4 weeks/ month/;
        $line =~ s/ --x-grid=.*:%[a-z,A-Z] / $xgrid /;
        $line =~ s/ --vertical-label=\"CPU cores\"/ /;
        $line =~ s/ --vertical-label=\"GB\"/ /;
        $line =~ s/ --vertical-label=\".* - Write\"/ /;
        $line =~ s/ --vertical-label=\".+?\"/ /;
      }
      if ( $detail == 0 || $detail == 9 ) {
        $line =~ s/ --width=[0-9]+/ --width=$width  $font_def $no_legend_too/;
        $line =~ s/ --height=[0-9]+/ --height=$height $font_tit /;
      }
    }
    $cmd = $line;
  }

  # prepare Updated
  my $updated = substr( $cmd, index( $cmd, "Updated" ), index( $cmd, "HRULE" ) - index( $cmd, "Updated" ) - 2 );
  $updated =~ s/\\//g;
  $updated =~ s/COMMENT://g;
  $updated =~ s/\"//g;
  $updated =~ s/ l//g;

  # for customvmmemconsumed of VMS change some strings
  if ( $item =~ m/customvmmemconsumed$/ ) {
    $cmd =~ s/_active/_granted/g;
    $cmd =~ s/Active /Granted /g;
    $cmd =~ s/multihmclpar_mem/multihmclpar_memgrant/g;
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "custom detail: Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $$ret, $updated );
  return 0;
}

# send to file string generated for RRD
sub alfa {
  my $cmd = shift;
  print STDERR "result command is in /tmp/ssss.out\n";
  my $sss = "/tmp/ssss.out";
  open( FF, ">$sss" );
  print FF "$cmd\n";
  close(FF);
}

sub xgrid_set {
  my $type   = shift;
  my $detail = shift;
  my $xgrid  = "--x-grid=";

  if ( $type =~ m/d/ ) {
    if ( $detail == 0 || $detail == 9 ) {
      $xgrid .= "MINUTE:60:HOUR:2:HOUR:4:0:%H";
    }
    if ( $detail == 1 || $detail == 10 ) {
      $xgrid .= "MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    if ( $detail == 2 ) {

      # dashboard
      #$xgrid .= "MINUTE:60:HOUR:1:HOUR:1:0:%H";
      if ( $super_detail == 3 ) {
        $xgrid .= "HOUR:1:DAY:1:HOUR:2:0:%H";
      }
      else {
        $xgrid .= "HOUR:6:DAY:1:HOUR:6:0:%H";
      }
    }
  }
  if ( $type =~ m/w/ ) {
    if ( $detail == 0 || $detail == 9 || $detail == 10 ) {
      $xgrid .= "HOUR:8:DAY:1:DAY:1:0:%a";
    }
    if ( $detail == 1 ) {
      $xgrid .= "HOUR:12:HOUR:6:HOUR:12:0:%a-%H";
    }
    if ( $detail == 2 ) {

      # dashboard
      $xgrid .= "DAY:1:DAY:7:DAY:1:0:%d";
    }
  }
  if ( $type =~ m/m/ ) {
    if ( $detail == 0 || $detail == 9 ) {
      $xgrid .= "DAY:1:DAY:2:DAY:2:0:%d";
    }
    if ( $detail == 1 || $detail == 10 ) {
      $xgrid .= "HOUR:12:DAY:1:DAY:1:0:%d";
    }
    if ( $detail == 2 ) {

      # dashboard
      $xgrid .= "DAY:7:MONTH:1:DAY:7:0:%d";
    }
  }
  if ( $type =~ m/y/ ) {
    if ( $detail == 0 || $detail == 9 ) {
      $xgrid .= "MONTH:1:MONTH:1:MONTH:1:0:%b";
    }
    if ( $detail == 1 || $detail == 10 ) {
      $xgrid .= "MONTH:1:MONTH:1:MONTH:1:0:%b";
    }
    if ( $detail == 2 ) {

      # dashboard
      $xgrid .= "MONTH:4:MONTH:12:MONTH:4:0:%b";
    }
  }
  if ( $type eq "a" ) {    # let them auto xgrid by rrdtool
    $xgrid = "--alt-y-grid";
  }

  return $xgrid;
}

sub text_set {
  my $type = shift;
  my $text = "day";

  $text = "day";
  if ( $type =~ m/w/ ) {
    $text = "week";
  }
  if ( $type =~ m/m/ ) {
    $text = "month";
  }
  if ( $type =~ m/y/ ) {
    $text = "year";
  }
  return $text;
}

sub graph_custom_xport {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $name_source = shift;
  my $hist_rep    = 0;

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $hist_rep = 1;
    }
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $tmp_file     = "$basedir/tmp/$name_source-$lpar-$type-xpo.cmd";
  my $tmp_file_web = "/var/tmp/$name_source-$lpar-$type-web.cmd";

  # replace graph size and total value
  open( FH, "< $tmp_file" ) || error( "custom detail: XPORT: Can't open $tmp_file : $!" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @lines = <FH>;
  close(FH);
  my $cmd = "";
  foreach my $line (@lines) {
    if ( $hist_rep == 1 ) {
      $line =~ s/ --start .* --end .* --step / --start $start_unix --end $end_unix --step /;
    }
    $cmd = $line;
  }

  my @ret_arr = "";
  my $rest    = "";
  eval {
    RRDp::cmd qq($cmd);

    #    @ret_arr = RRDp::read;
    $rest = RRDp::read;
  };
  if ($@) {
    error( "custom detail: Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # converting from XML to CSV
  my $out     = 0;
  my $out_txt = "";
  @ret_arr = $$rest;
  foreach my $line (@ret_arr) {
    if ( $out == 0 ) {
      if ( $line =~ m/xml version=/ ) {
        $out_txt .= $line;
        $out = 1;
      }
    }
    else {
      if ( $line !~ m/^OK u:/ ) {
        $out_txt .= $line;
      }
    }
  }
  print "Content-Disposition: attachment;filename=\"CustomGroup\_$lpar.csv\"\n\n";
  xport_print( $out_txt, 1 );

  return 0;
}

sub xport_print {
  my $xml_org = shift;
  my $multi   = shift;
  my $xml     = "";
  my $sep     = $ENV{'CSV_SEPARATOR'} ||= ";";

  if ( $multi == 1 ) {

    #print OUT "--xport-- $xml_org\n";
    eval { $xml = XMLin($xml_org); };
    if ($@) {

      #error("XML parsing error: $@");
      #error("Try to parse XML manually.");
      xml2csv_manually($xml_org);
      return 0;
    }
  }
  else {
    #print OUT "--xport++ $$xml_org\n";
    eval { $xml = XMLin($$xml_org); };
    if ($@) {

      #error("XML parsing error: $@");
      #error("Try to parse XML manually.");
      xml2csv_manually($$xml_org);
      return 0;
    }
  }
  if ( ref $xml->{meta}{legend}{entry} eq "ARRAY" ) {
    foreach my $item ( @{ $xml->{meta}{legend}{entry} } ) {    # in case semicolon in lpar name
      $item = "\"" . $item . "\"";
    }
  }
  else {
    $xml->{meta}{legend}{entry} = "\"" . $xml->{meta}{legend}{entry} . "\"";
  }

  print join( "$sep", 'Timestamp DD.MM.YYYY HH:MM', @{ $xml->{meta}{legend}{entry} } ), "\n";
  foreach my $row ( @{ $xml->{data}{row} } ) {
    my $time = strftime "%d.%m.%y %H:%M:%S", localtime( $row->{t} );
    my $line = join( "$sep", $time, @{ $row->{v} } );
    $line =~ s/NaNQ/0/g;
    $line =~ s/NaN/0/g;
    $line =~ s/nan/0/g;
    print "$line\n";
  }
  return 0;
}

sub xml2csv_manually {
  my $xml = shift;
  my $sep = $ENV{'CSV_SEPARATOR'} ||= ";";

  my @header;
  my $section = "";
  my %data_out;

  #
  # parse data
  #
  foreach ( split( /\n/, $xml ) ) {
    chomp $_;

    $_ =~ s/^\s+//g;
    $_ =~ s/\s+$//g;

    #print "$_\n";

    if ( $_ eq "<legend>" )  { $section = "legend"; next; }
    if ( $_ eq "</legend>" ) { $section = "";       next; }
    if ( $_ eq "<data>" )    { $section = "data";   next; }
    if ( $_ eq "</data>" )   { $section = "";       next; }

    if ( $section eq "legend" && $_ =~ m/^<entry>/ ) {
      $_ =~ s/^<entry>//;
      $_ =~ s/<\/entry>$//;
      $_ =~ s/^\s+//g;
      $_ =~ s/\s+$//g;

      push( @header, $_ );
    }
    if ( $section eq "data" && $_ =~ m/^<row><t>/ ) {
      my ( $timestamp, $values ) = split( "</t><v>", $_ );
      if ( defined $timestamp && defined $values ) {
        $timestamp =~ s/^<row><t>//g;
        $values    =~ s/<\/v><\/row>//g;

        if ( isdigit($timestamp) ) {

          #print "$timestamp : $values\n";
          my @data = split( /<\/v><v>/, $values );
          if ( scalar(@header) == scalar(@data) ) {
            my $val_idx = 0;
            foreach my $value (@data) {
              if ( isdigit($value) && defined $header[$val_idx] && $header[$val_idx] ne '' ) {
                $data_out{$timestamp}{ $header[$val_idx] } = $value;
              }

              $val_idx++;
            }
          }
          else {
            #print "$timestamp : $values\n";
            # wrong format of line from xport, just skip this line...
            next;
          }
        }
      }
    }
  }

  #
  # print CSV
  #
  print join( "$sep", 'Timestamp DD.MM.YYYY HH:MM', @header ) . "\n";

  foreach my $timestamp ( sort { $a <=> $b } keys %data_out ) {

    #print "$timestamp\n";
    my $time     = strftime "%d.%m.%y %H:%M:%S", localtime($timestamp);
    my $line_out = "$time";

    foreach my $item (@header) {
      if ( exists $data_out{$timestamp}{$item} ) {
        $line_out .= $sep . $data_out{$timestamp}{$item};
      }
      else {
        $line_out .= $sep;
      }
    }

    print "$line_out\n";
  }

  return 0;
}

sub graph_hea {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $file       = shift;    #as $item
  my $start_unix = shift;
  my $end_unix   = shift;

  # `echo "graph hea $host,$server,$lpar,$type,$detail" >> /tmp/dgc-123`;
  my $t  = "COMMENT: ";
  my $t2 = "COMMENT:\\n";

  chomp($file);
  ( undef, my $adapter_id, my $port ) = split( /-/, $file );
  $port =~ s/\.db//;

  #print "-- $file $port\n";
  my $rrd = "$wrkdir/$server/$host/$file";

  my $first        = 0;
  my $act_time     = time();
  my $port_group   = 0;
  my $phys_port_id = 0;

  if ( $rrd =~ "HSCL" || $rrd =~ "VIOSE0" ) { error( "hea: contain HSCL or VIOSE0 " . __FILE__ . ":" . __LINE__ ) && return 0; }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $header = "HEA $port : last $text";
  if ( $detail == 2 ) {
    $header = "HEA $port : $text";
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "HEA $port : $start_human - $end_human";
    }
  }

  #`echo "$xgrid,$type,$detail" >> /tmp/e125`;

  # It must be here
  #  draw_graph_hea ("day","d","MINUTE:60:HOUR:2:HOUR:4:0:%H",$managedname,$rrd,$adapter_id,$port);
  # draw_graph_hea ("week","w","HOUR:8:DAY:1:DAY:1:86400:%a",$managedname,$rrd,$adapter_id,$port);
  # draw_graph_hea ("month","m","DAY:1:DAY:2:DAY:2:0:%d",$managedname,$rrd,$adapter_id,$port);
  # draw_graph_hea ("year","y","MONTH:1:MONTH:1:MONTH:1:0:%b",$managedname,$rrd,$adapter_id,$port);
  # draw_graph_hea_summ ("month","m","DAY:1:DAY:2:DAY:2:0:%d",$managedname,$rrd,$adapter_id,$port);
  # draw_graph_hea_summ ("year","y","MONTH:1:MONTH:1:MONTH:1:0:%b",$managedname,$rrd,$adapter_id,$port);

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\: $l ";
  }

  my $vertical_label = "--vertical-label=Bytes/sec";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  #  print "creating graph : $host:$server:$type:$adapter_id:$port\n" if $DEBUG ;

  # filter everything above 11Gbites
  my $filter = 1100000000;

  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  $rrd =~ s/:/\\:/g;
  RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "--step=$STEP_HEA"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--alt-autoscale-max"
      "$xgrid"
      "--base=1024"
      "--alt-y-grid"
      "DEF:recv_np=$rrd:recv_octets:AVERAGE"
      "DEF:trans_np=$rrd:trans_octets:AVERAGE"
      "CDEF:recv=recv_np,$filter,GT,UNKN,recv_np,IF"
      "CDEF:trans=trans_np,$filter,GT,UNKN,trans_np,IF"
      "CDEF:recvkb=recv,1024,/"
      "CDEF:transkb=trans,1024,/"
      "CDEF:trans-neg=0,trans,-"
      "COMMENT:   Average  in kB\\n"
      "AREA:recv#00FF00: Received   "
      "GPRINT:recvkb:AVERAGE: %8.1lf"
      "$t2"
      "AREA:trans-neg#FFFF00: Transmited "
      "GPRINT:transkb:AVERAGE: %8.1lf"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
    );
  my $answ = RRDp::read;
  if ( $$answ =~ "ERROR" ) {
    error( "$host:$server Graph rrdtool error : $$answ " . __FILE__ . ":" . __LINE__ );
  }
  $png_end_heading = ret_graph_param($answ);
  return 0;
}

sub graph_trend_pool {
  my $host     = shift;
  my $server   = shift;
  my $lpar     = shift;
  my $type     = shift;
  my $name_out = shift;
  my $type_sam = shift;
  my $upper    = shift;
  my $detail   = shift;
  my $t        = "COMMENT: ";
  my $t2       = "COMMENT:\\n";
  my $step_new = $step;
  my $last     = "COMMENT: ";
  my $xgrid    = "--x-grid=MONTH:1:MONTH:1:MONTH:1:0:%b";

  if ( $upper eq '' || $upper == 0 ) {
    $upper = 0.1;
  }

  my $rrd     = "$wrkdir/$server/$host/$lpar.rr$type_sam";
  my $rrd_lpm = "$wrkdir/$server/*/$lpar.rr$type_sam";

  if ( $item eq "trendpool-max" ) {
    $rrd     = "$wrkdir/$server/$host/$lpar.xr$type_sam";
    $rrd_lpm = "$wrkdir/$server/*/$lpar.xr$type_sam";
  }

  if ($hitachi) {
    $rrd = "$wrkdir/$server/$host/SYS-CPU.hrm";
  }

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacemnt for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "CPU pool :$last_txt year";

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my $vertical_label = "--vertical-label=\"CPU cores\"";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  elsif ($hitachi) {
    $vertical_label = "--vertical-label=\"CPU usage %\"";
  }

  # Trend for yearly chart 1y back  + 1y forward
  #print "creating graph : $host:$server:$lpar:$type_sam:$type:trend\n" if $DEBUG ;

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  $rrd =~ s/:/\\:/g;
  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  if ( $detail == 10 ) {
    $header = "$server : CPU pool :$last_txt year";
  }

  my $cmd .= "$graph_cmd \"$name_out\"";
  $cmd    .= " --title \"$header - trend\"";
  $cmd    .= " --start now-1$type";
  $cmd    .= " --end now+1$type";
  $cmd    .= " --imgformat PNG";
  $cmd    .= " --slope-mode";
  $cmd    .= " $no_minor";
  $cmd    .= " --width=$width_trend";
  $cmd    .= " --height=$height";
  $cmd    .= " --step=$step";
  $cmd    .= " --lower-limit=0.00";
  $cmd    .= " --color=BACK#$pic_col";
  $cmd    .= " --color=SHADEA#$pic_col";
  $cmd    .= " --color=SHADEB#$pic_col";
  $cmd    .= " --color=CANVAS#$pic_col";
  $cmd    .= " --alt-autoscale-max";
  $cmd    .= " --upper-limit=0.1";
  $cmd    .= " $vertical_label";
  $cmd    .= " --units-exponent=1.00";
  $cmd    .= " --alt-y-grid";
  $cmd    .= " $no_legend";
  $cmd    .= " $disable_rrdtool_tag";
  $cmd    .= " $font_def";
  $cmd    .= " $font_tit";
  $cmd    .= " $xgrid";

  if ($hitachi) {
    $cmd .= " --upper-limit=100";
    $cmd .= " DEF:usedp=\"$rrd\":cpu_usedp:AVERAGE";
    $cmd .= " DEF:usedp_1m=\"$rrd\":cpu_usedp:AVERAGE:start=-1m";
    $cmd .= " DEF:usedp_3m=\"$rrd\":cpu_usedp:AVERAGE:start=-3m";
    $cmd .= " DEF:usedp_1y=\"$rrd\":cpu_usedp:AVERAGE:start=-1y";
    $cmd .= " VDEF:Dd=usedp_1m,LSLSLOPE";
    $cmd .= " VDEF:Hd=usedp_1m,LSLINT";
    $cmd .= " CDEF:cpuusagetrend-1m=usedp_1m,POP,Dd,COUNT,*,Hd,+";
    $cmd .= " VDEF:Dm=usedp_3m,LSLSLOPE";
    $cmd .= " VDEF:Hm=usedp_3m,LSLINT";
    $cmd .= " CDEF:cpuusagetrend-3m=usedp_3m,POP,Dm,COUNT,*,Hm,+";
    $cmd .= " VDEF:Dy=usedp_1y,LSLSLOPE";
    $cmd .= " VDEF:Hy=usedp_1y,LSLINT";
    $cmd .= " CDEF:cpuusagetrend-1y=usedp_1y,POP,Dy,COUNT,*,Hy,+";

    $cmd .= " COMMENT:\"   Average          \\n\"";
    $cmd .= " LINE1:usedp#FF0000:\" CPU usage\"";
    $cmd .= " GPRINT:usedp:AVERAGE:\"    %2.2lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:cpuusagetrend-1m#0080FF:\" CPU usage    - last 1 month trend\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:cpuusagetrend-3m#80FFFF:\" CPU usage    - last 3 months trend\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:cpuusagetrend-1y#FF8080:\" CPU usage    - last year trend\"";
    $cmd .= " $last";
    $cmd .= " $t2";
  }
  else {
    $rrd_lpm =~ s/:/\\:/g;

    # to use data from all HMCs (not real LPM, LPM is between servers what this does not do
    my ( $result_cmd, $CPU_tot_d, $CPU_util_d, $CPU_conf_d, $CPU_bor_d, $CPU_tot_m, $CPU_util_m, $CPU_conf_m, $CPU_bor_m, $CPU_tot_y, $CPU_util_y, $CPU_conf_y, $CPU_bor_y, $CPU_tot, $CPU_util, $CPU_conf, $CPU_bor ) = LPM_easy_trend( "$rrd_lpm", "total_pool_cycles", "utilized_pool_cyc", "conf_proc_units", "bor_proc_units" );

    if ( $item eq "trendpool-max" ) {
      my $result_to_parse = $result_cmd;
      $result_to_parse =~ s/^\s+//g;
      $result_to_parse =~ s/\s+$//g;
      $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

      my @result_cmd_lines = split( "\n", $result_to_parse );
      $result_cmd = "";

      foreach my $cmd_line (@result_cmd_lines) {
        chomp $cmd_line;

        #print STDERR "$cmd_line\n";
        $cmd_line =~ s/^\s+//g;
        $cmd_line =~ s/\s+$//g;

        my $line_max = $cmd_line;

        if ( $cmd_line =~ "^DEF:" ) {
          $line_max =~ s/:AVERAGE$/:MAX/;
          $line_max =~ s/:AVERAGE:start=/:MAX:start=/;
        }
        $result_cmd .= " $line_max";
      }
    }

    $cmd .= $result_cmd;
    $cmd .= " CDEF:totcycd=$CPU_tot_d";
    $cmd .= " CDEF:totcycm=$CPU_tot_m";
    $cmd .= " CDEF:totcycy=$CPU_tot_y";
    $cmd .= " CDEF:totcyc=$CPU_tot";

    $cmd .= " CDEF:uticycd=$CPU_util_d";
    $cmd .= " CDEF:uticycm=$CPU_util_m";
    $cmd .= " CDEF:uticycy=$CPU_util_y";
    $cmd .= " CDEF:uticyc=$CPU_util";

    $cmd .= " CDEF:cpud=$CPU_conf_d";
    $cmd .= " CDEF:cpum=$CPU_conf_m";
    $cmd .= " CDEF:cpuy=$CPU_conf_y";
    $cmd .= " CDEF:cpu=$CPU_conf";

    $cmd .= " CDEF:cpubord=$CPU_bor_d";
    $cmd .= " CDEF:cpuborm=$CPU_bor_m";
    $cmd .= " CDEF:cpubory=$CPU_bor_y";
    $cmd .= " CDEF:cpubor=$CPU_bor";

    $cmd .= " CDEF:totcpud=cpud,cpubord,+";
    $cmd .= " CDEF:totcpum=cpum,cpuborm,+";
    $cmd .= " CDEF:totcpuy=cpuy,cpubory,+";
    $cmd .= " CDEF:totcpu=cpu,cpubor,+";
    $cmd .= " CDEF:cpuutild=uticycd,totcycd,GT,UNKN,uticycd,totcycd,/,IF";
    $cmd .= " CDEF:cpuutilm=uticycm,totcycm,GT,UNKN,uticycm,totcycm,/,IF";
    $cmd .= " CDEF:cpuutily=uticycy,totcycy,GT,UNKN,uticycy,totcycy,/,IF";
    $cmd .= " CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF";
    $cmd .= " CDEF:cpuutiltotd=cpuutild,totcpud,*";
    $cmd .= " CDEF:cpuutiltotm=cpuutilm,totcpum,*";
    $cmd .= " CDEF:cpuutiltoty=cpuutily,totcpuy,*";
    $cmd .= " CDEF:cpuutiltot=cpuutil,totcpu,*";
    $cmd .= " CDEF:utilisa=cpuutil,100,*";
    $cmd .= " VDEF:Dd=cpuutiltotd,LSLSLOPE";
    $cmd .= " VDEF:Hd=cpuutiltotd,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendd=cpuutiltotd,POP,Dd,COUNT,*,Hd,+";
    $cmd .= " VDEF:Dm=cpuutiltotm,LSLSLOPE";
    $cmd .= " VDEF:Hm=cpuutiltotm,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendm=cpuutiltotm,POP,Dm,COUNT,*,Hm,+";
    $cmd .= " VDEF:Dy=cpuutiltoty,LSLSLOPE";
    $cmd .= " VDEF:Hy=cpuutiltoty,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendy=cpuutiltoty,POP,Dy,COUNT,*,Hy,+";

    if ( $item eq "trendpool-max" ) {
      $cmd .= " COMMENT:\"   Average   \\n\"";
      $cmd .= " AREA:cpu$pastel_green:\" Configured CPU cores    \"";
      $cmd .= " GPRINT:cpu:AVERAGE:\"      %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " STACK:cpubor$pastel_yellow:\" Not assigned CPU cores  \"";
      $cmd .= " GPRINT:cpubor:AVERAGE:\"      %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Avrg of max peaks in CPU cores\"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\"%2.2lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendd#0080FF:\" Maximum peaks in CPU cores - last 1 month trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendm#80FFFF:\" Maximum peaks in CPU cores - last 3 months trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendy#FF8080:\" Maximum peaks in CPU cores - last year trend\"";
      $cmd .= " $last";
      $cmd .= " $t2";
    }
    else {
      $cmd .= " COMMENT:\"   Average   \\n\"";
      $cmd .= " AREA:cpu$pastel_green:\" Configured CPU cores    \"";
      $cmd .= " GPRINT:cpu:AVERAGE:\"  %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " STACK:cpubor$pastel_yellow:\" Not assigned CPU cores  \"";
      $cmd .= " GPRINT:cpubor:AVERAGE:\"  %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization in CPU cores\"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\"  %2.2lf\"";
      $cmd .= " COMMENT:\"(\"";
      $cmd .= " GPRINT:utilisa:AVERAGE:\" %2.1lf\"";
      $cmd .= " COMMENT:\"\%)\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendd#0080FF:\" Utilization in CPU cores - last 1 month trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendm#80FFFF:\" Utilization in CPU cores - last 3 months trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendy#FF8080:\" Utilization in CPU cores - last year trend\"";
      $cmd .= " $last";
      $cmd .= " $t2";
    }
  }
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;    # a trick, there was a problem with aggregated and "COMMENT: "

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_trend_shpool {
  my $host     = shift;
  my $server   = shift;
  my $lpar     = shift;
  my $type     = shift;
  my $name_out = shift;
  my $type_sam = shift;
  my $upper    = shift;
  my $detail   = shift;
  my $t        = "COMMENT: ";
  my $t2       = "COMMENT:\\n";
  my $step_new = $step;
  my $last     = "COMMENT: ";
  my $xgrid    = "--x-grid=MONTH:1:MONTH:1:MONTH:1:0:%b";

  if ( $upper eq '' || $upper == 0 ) {
    $upper = 0.1;
  }

  my $rrd     = "$wrkdir/$server/$host/$lpar.rr$type_sam";
  my $rrd_lpm = "$wrkdir/$server/*/$lpar.rr$type_sam";

  if ( $item eq "trendshpool-max" ) {
    $rrd     = "$wrkdir/$server/$host/$lpar.xr$type_sam";
    $rrd_lpm = "$wrkdir/$server/*/$lpar.xr$type_sam";
  }
  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacemnt for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  # add CPU pool alias into png header (if exists and it is not a default CPU pool)
  my $pool_id = $lpar;
  $pool_id =~ s/SharedPool//g;

  my $lpar_pool_alias = $lpar_slash_nmon;
  if ( -f "$wrkdir/$server/$host/cpu-pools-mapping.txt" ) {
    open( FR, "< $wrkdir/$server/$host/cpu-pools-mapping.txt" );
    foreach my $linep (<FR>) {
      chomp($linep);
      ( my $id, my $pool_name ) = split( /,/, $linep );
      if ( $id == $pool_id ) {
        $lpar_pool_alias = "$pool_name";
        last;
      }
    }
    close(FR);
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "POOL: $lpar_pool_alias :$last_txt year";

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my $vertical_label = "--vertical-label=\"CPU cores\"";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # Trend for yearly chart 1y back  + 1y forward
  #print "creating graph : $host:$server:$lpar:$type_sam:$type:trend\n" if $DEBUG ;

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  $rrd =~ s/:/\\:/g;
  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  if ( $detail == 10 ) {
    $header = "$server : POOL: $lpar_pool_alias :$last_txt year";
  }

  my $cmd .= "$graph_cmd \"$name_out\"";
  $cmd    .= " --title \"$header - trend\"";
  $cmd    .= " --start now-1$type";
  $cmd    .= " --end now+1$type";
  $cmd    .= " --imgformat PNG";
  $cmd    .= " --slope-mode";
  $cmd    .= " $no_minor";
  $cmd    .= " --width=$width_trend";
  $cmd    .= " --height=$height";
  $cmd    .= " --step=$step";
  $cmd    .= " --lower-limit=0.00";
  $cmd    .= " --color=BACK#$pic_col";
  $cmd    .= " --color=SHADEA#$pic_col";
  $cmd    .= " --color=SHADEB#$pic_col";
  $cmd    .= " --color=CANVAS#$pic_col";
  $cmd    .= " --alt-autoscale-max";
  $cmd    .= " --upper-limit=0.1";
  $cmd    .= " $vertical_label";
  $cmd    .= " --units-exponent=1.00";
  $cmd    .= " --alt-y-grid";
  $cmd    .= " $no_legend";
  $cmd    .= " $disable_rrdtool_tag";
  $cmd    .= " $font_def";
  $cmd    .= " $font_tit";
  $cmd    .= " $xgrid";

  $rrd_lpm =~ s/:/\\:/g;

  if ( $lpar !~ m/^SharedPool0$/ ) {

    # to use data from all HMCs (not real LPM, LPM is between servers what this does not do
    my ( $result_cmd, $CPU_max_d, $CPU_res_d, $CPU_totcyc_d, $CPU_uticyc_d, $CPU_max_m, $CPU_res_m, $CPU_totcyc_m, $CPU_uticyc_m, $CPU_max_y, $CPU_res_y, $CPU_totcyc_y, $CPU_uticyc_y, $CPU_max, $CPU_res, $CPU_totcyc, $CPU_uticyc ) = LPM_easy_trend( "$rrd_lpm", "max_pool_units", "res_pool_units", "total_pool_cycles", "utilized_pool_cyc" );

    if ( $item eq "trendshpool-max" ) {
      my $result_to_parse = $result_cmd;
      $result_to_parse =~ s/^\s+//g;
      $result_to_parse =~ s/\s+$//g;
      $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

      my @result_cmd_lines = split( "\n", $result_to_parse );
      $result_cmd = "";

      foreach my $cmd_line (@result_cmd_lines) {
        chomp $cmd_line;

        #print STDERR "$cmd_line\n";
        $cmd_line =~ s/^\s+//g;
        $cmd_line =~ s/\s+$//g;

        my $line_max = $cmd_line;

        if ( $cmd_line =~ "^DEF:" ) {
          $line_max =~ s/:AVERAGE$/:MAX/;
          $line_max =~ s/:AVERAGE:start=/:MAX:start=/;
        }
        $result_cmd .= " $line_max";
      }
    }

    $cmd .= $result_cmd;
    $cmd .= " CDEF:maxd=$CPU_max_d";
    $cmd .= " CDEF:maxm=$CPU_max_m";
    $cmd .= " CDEF:maxy=$CPU_max_y";
    $cmd .= " CDEF:max=$CPU_max";

    $cmd .= " CDEF:resd=$CPU_res_d";
    $cmd .= " CDEF:resm=$CPU_res_m";
    $cmd .= " CDEF:resy=$CPU_res_y";
    $cmd .= " CDEF:res=$CPU_res";

    $cmd .= " CDEF:totcycd=$CPU_totcyc_d";
    $cmd .= " CDEF:totcycm=$CPU_totcyc_m";
    $cmd .= " CDEF:totcycy=$CPU_totcyc_y";
    $cmd .= " CDEF:totcyc=$CPU_totcyc";

    $cmd .= " CDEF:uticycd=$CPU_uticyc_d";
    $cmd .= " CDEF:uticycm=$CPU_uticyc_m";
    $cmd .= " CDEF:uticycy=$CPU_uticyc_y";
    $cmd .= " CDEF:uticyc=$CPU_uticyc";

    $cmd .= " CDEF:max1=max,res,-";
    $cmd .= " CDEF:cpuutild=uticycd,totcycd,/";
    $cmd .= " CDEF:cpuutilm=uticycm,totcycm,/";
    $cmd .= " CDEF:cpuutily=uticycy,totcycy,/";
    $cmd .= " CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF";
    $cmd .= " CDEF:cpuutiltotd=cpuutild,maxd,*";
    $cmd .= " CDEF:cpuutiltotm=cpuutilm,maxm,*";
    $cmd .= " CDEF:cpuutiltoty=cpuutily,maxy,*";
    $cmd .= " CDEF:cpuutiltot=cpuutil,max,*";
    $cmd .= " CDEF:utilisa=cpuutil,100,*";
    $cmd .= " VDEF:Dd=cpuutiltotd,LSLSLOPE";
    $cmd .= " VDEF:Hd=cpuutiltotd,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendd=cpuutiltotd,POP,Dd,COUNT,*,Hd,+";
    $cmd .= " VDEF:Dm=cpuutiltotm,LSLSLOPE";
    $cmd .= " VDEF:Hm=cpuutiltotm,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendm=cpuutiltotm,POP,Dm,COUNT,*,Hm,+";
    $cmd .= " VDEF:Dy=cpuutiltoty,LSLSLOPE";
    $cmd .= " VDEF:Hy=cpuutiltoty,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendy=cpuutiltoty,POP,Dy,COUNT,*,Hy,+";

    if ( $item eq "trendshpool-max" ) {
      $cmd .= " COMMENT:\"   Average   \\n\"";
      $cmd .= " AREA:res#00FF00:\" Reserved CPU cores      \"";
      $cmd .= " GPRINT:res:AVERAGE:\"      %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " STACK:max1#FFFF00:\" Max CPU cores           \"";
      $cmd .= " GPRINT:max1:AVERAGE:\"      %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Avrg of max peaks in CPU cores\"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\"%2.2lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendd#0080FF:\" Maximum peaks in CPU cores - last 1 month trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendm#80FFFF:\" Maximum peaks in CPU cores - last 3 months trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendy#FF8080:\" Maximum peaks in CPU cores - last year trend\"";
      $cmd .= " $last";
      $cmd .= " $t2";
    }
    else {
      $cmd .= " COMMENT:\"   Average   \\n\"";
      $cmd .= " AREA:res#00FF00:\" Reserved CPU cores      \"";
      $cmd .= " GPRINT:res:AVERAGE:\"  %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " STACK:max1#FFFF00:\" Max CPU cores           \"";
      $cmd .= " GPRINT:max1:AVERAGE:\"  %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization in CPU cores\"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\"  %2.2lf\"";
      $cmd .= " COMMENT:\"(\"";
      $cmd .= " GPRINT:utilisa:AVERAGE:\" %2.1lf\"";
      $cmd .= " COMMENT:\"\%)\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendd#0080FF:\" Utilization in CPU cores - last 1 month trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendm#80FFFF:\" Utilization in CPU cores - last 3 months trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendy#FF8080:\" Utilization in CPU cores - last year trend\"";
      $cmd .= " $last";
      $cmd .= " $t2";
    }
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";
  }
  else {
    # to use data from all HMCs (not real LPM, LPM is between servers what this does not do
    my ( $result_cmd, $CPU_max_d, $CPU_totcyc_d, $CPU_uticyc_d, $CPU_max_m, $CPU_totcyc_m, $CPU_uticyc_m, $CPU_max_y, $CPU_totcyc_y, $CPU_uticyc_y, $CPU_max, $CPU_totcyc, $CPU_uticyc ) = LPM_easy_trend( "$rrd_lpm", "max_pool_units", "total_pool_cycles", "utilized_pool_cyc" );

    if ( $item eq "trendshpool-max" ) {
      my $result_to_parse = $result_cmd;
      $result_to_parse =~ s/^\s+//g;
      $result_to_parse =~ s/\s+$//g;
      $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

      my @result_cmd_lines = split( "\n", $result_to_parse );
      $result_cmd = "";

      foreach my $cmd_line (@result_cmd_lines) {
        chomp $cmd_line;

        #print STDERR "$cmd_line\n";
        $cmd_line =~ s/^\s+//g;
        $cmd_line =~ s/\s+$//g;

        my $line_max = $cmd_line;

        if ( $cmd_line =~ "^DEF:" ) {
          $line_max =~ s/:AVERAGE$/:MAX/;
          $line_max =~ s/:AVERAGE:start=/:MAX:start=/;
        }
        $result_cmd .= " $line_max";
      }
    }

    $cmd .= $result_cmd;
    $cmd .= " CDEF:maxd=$CPU_max_d";
    $cmd .= " CDEF:maxm=$CPU_max_m";
    $cmd .= " CDEF:maxy=$CPU_max_y";
    $cmd .= " CDEF:max=$CPU_max";

    $cmd .= " CDEF:totcycd=$CPU_totcyc_d";
    $cmd .= " CDEF:totcycm=$CPU_totcyc_m";
    $cmd .= " CDEF:totcycy=$CPU_totcyc_y";
    $cmd .= " CDEF:totcyc=$CPU_totcyc";

    $cmd .= " CDEF:uticycd=$CPU_uticyc_d";
    $cmd .= " CDEF:uticycm=$CPU_uticyc_m";
    $cmd .= " CDEF:uticycy=$CPU_uticyc_y";
    $cmd .= " CDEF:uticyc=$CPU_uticyc";

    $cmd .= " CDEF:cpuutild=uticycd,totcycd,/";
    $cmd .= " CDEF:cpuutilm=uticycm,totcycm,/";
    $cmd .= " CDEF:cpuutily=uticycy,totcycy,/";
    $cmd .= " CDEF:cpuutil=uticyc,totcyc,GT,UNKN,uticyc,totcyc,/,IF";
    $cmd .= " CDEF:cpuutiltotd=cpuutild,maxd,*";
    $cmd .= " CDEF:cpuutiltotm=cpuutilm,maxm,*";
    $cmd .= " CDEF:cpuutiltoty=cpuutily,maxy,*";
    $cmd .= " CDEF:cpuutiltot=cpuutil,max,*";
    $cmd .= " CDEF:utilisa=cpuutil,100,*";
    $cmd .= " VDEF:Dd=cpuutiltotd,LSLSLOPE";
    $cmd .= " VDEF:Hd=cpuutiltotd,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendd=cpuutiltotd,POP,Dd,COUNT,*,Hd,+";
    $cmd .= " VDEF:Dm=cpuutiltotm,LSLSLOPE";
    $cmd .= " VDEF:Hm=cpuutiltotm,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendm=cpuutiltotm,POP,Dm,COUNT,*,Hm,+";
    $cmd .= " VDEF:Dy=cpuutiltoty,LSLSLOPE";
    $cmd .= " VDEF:Hy=cpuutiltoty,LSLINT";
    $cmd .= " CDEF:cpuutiltottrendy=cpuutiltoty,POP,Dy,COUNT,*,Hy,+";

    if ( $item eq "trendshpool-max" ) {
      $cmd .= " COMMENT:\"   Average   \\n\"";
      $cmd .= " AREA:max#00FF00:\" Max CPU cores           \"";
      $cmd .= " GPRINT:max:AVERAGE:\"      %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Avrg of max peaks in CPU cores\"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\"%2.2lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendd#0080FF:\" Maximum peaks in CPU cores - last 1 month trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendm#80FFFF:\" Maximum peaks in CPU cores - last 3 months trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendy#FF8080:\" Maximum peaks in CPU cores - last year trend\"";
      $cmd .= " $t2";
    }
    else {
      $cmd .= " COMMENT:\"   Average   \\n\"";
      $cmd .= " AREA:max#00FF00:\" Max CPU cores           \"";
      $cmd .= " GPRINT:max:AVERAGE:\"  %2.1lf\"";
      $cmd .= " $t2";
      $cmd .= " LINE1:cpuutiltot#FF0000:\" Utilization in CPU cores\"";
      $cmd .= " GPRINT:cpuutiltot:AVERAGE:\"  %2.2lf\"";
      $cmd .= " COMMENT:\"(\"";
      $cmd .= " GPRINT:utilisa:AVERAGE:\" %2.1lf\"";
      $cmd .= " COMMENT:\"\%)\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendd#0080FF:\" Utilization in CPU cores - last 1 month trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendm#80FFFF:\" Utilization in CPU cores - last 3 months trend\"";
      $cmd .= " $t2";
      $cmd .= " LINE2:cpuutiltottrendy#FF8080:\" Utilization in CPU cores - last year trend\"";
      $cmd .= " $t2";
    }
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";
  }

  $cmd =~ s/COMMENT: //g;    # a trick, there was a problem with aggregated and "COMMENT: "

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_poolagg {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT:\" \" ";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT: ";
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $req_time    = 0;
  my $line_items  = 0;                  # how many items in the legend per a line (default 2, when detail then 3)

  if ( $detail == 1 ) {
    $line_items = 2;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_poolagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $header = "LPARs in POOL aggregated :$last_txt$text";

  if ( $detail == 1 ) {
    $header = "LPARs in POOL aggregated: $server :$last_txt$text";
  }

  # find shpool alias
  my $lpar_pool_alias = $lpar;
  $lpar_pool_alias =~ s/SharedPool/CPU pool /g;

  # add CPU pool alias into png header (if exists and it is not a default CPU pool)
  my $pool_id = $lpar;
  $pool_id =~ s/SharedPool//g;

  if ( -f "$wrkdir/$server/$host/cpu-pools-mapping.txt" ) {
    open( FR, "< $wrkdir/$server/$host/cpu-pools-mapping.txt" );
    foreach my $linep (<FR>) {
      chomp($linep);
      ( my $id, my $pool_name ) = split( /,/, $linep );
      if ( $id == $pool_id ) {
        $lpar_pool_alias = "$pool_name";
        last;
      }
    }
    close(FR);
  }

  if ( $detail == 2 ) {

    # $header = "$server agg:$last_txt$text";
    $header = "$lpar_pool_alias agg:$last_txt$text";
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "";    # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "LPARs in POOL aggregated: $server : $start_human - $end_human";
      if ( $detail == 10 ) {
        $header = "LPARs aggregated: $server $lpar_pool_alias : $start_human - $end_human";
      }
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my $i   = 0;
  my $cmd = "";
  my $j   = 0;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  #  my $start_time = "now-1$type";
  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=\"CPU cores\"";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  # my $cmd_out = "graph \"no_picture\"";

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 1 ) {
    $cmd .= " COMMENT:\"Utilization in CPU cores\\:    average  maximum                               average  maximum                               average  maximum\\l\"";
  }
  else {
    $cmd .= " COMMENT:\"Utilization in CPU cores\\:    average  maximum\\l\"";
  }

  # select pool and its lpars
  $pool_id = $lpar;
  $pool_id =~ s/SharedPool//g;
  if ( isdigit($pool_id) == 0 ) {
    error( "CPU pools id is not a digit: $pool_id ($lpar) " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # read CPU pool cfg from : data/p710/sdmc/cpu.cfg
  # lpar_name=demo,lpar_id=7,curr_shared_proc_pool_id=1,......
  open( POOLIN, "< $wrkdir/$server/$host/cpu.cfg" ) || error( "Cannot open for reading $wrkdir/$server/$host/cpu.cfg: $!" . __FILE__ . ":" . __LINE__ ) && return 0;

  #`echo " 01 $wrkdir/$server/$host/cpu.cfg" >> /tmp/x333`;
  my $file_index = 0;
  my @files      = "";
  while ( my $line = <POOLIN> ) {

    # find our lpar list
    chomp($line);
    ( my $lpar_name, my $lpar_id, my $pool_id_act ) = split( /,/, $line );
    $lpar_name   =~ s/^lpar_name=//;
    $lpar_name   =~ s/\//&&1/g;
    $pool_id_act =~ s/^curr_shared_proc_pool_id=//;
    if ( isdigit($pool_id_act) == 1 && $pool_id == $pool_id_act && -f "$wrkdir/$server/$host/$lpar_name.rr$type_sam" ) {

      #`echo " 03 - $lpar_name.rr$type_sam : $pool_id == $pool_id_act " >> /tmp/x333`;
      # avoid old lpars which do not exist in the period
      my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$lpar_name.rr$type_sam") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
      $files[$file_index] = "$lpar_name.rr$type_sam";
      $file_index++;

      #`echo " 04 - $lpar_name.rr$type_sam : $pool_id == $pool_id_act " >> /tmp/x333`;
    }
  }
  close POOLIN;

  # there can be 0 found lpars, no problem at all ... not all pools have necessary lpars

  my $gtype      = "AREA";
  my $color_indx = 0;
  my $line_indx  = 0;        # place enter every 3rd line
  foreach my $file (@files) {
    chomp($file);
    if ( $file eq '' ) {
      next;                  # must be here for some reason when there is not any lpar found
    }

    $lpar = $file;
    $lpar =~ s/.rrh//;
    $lpar =~ s/.rrm//;
    $lpar =~ s/.rrd//;
    my $lpar_space_proc = $lpar;
    my $lpar_space      = $lpar;

    # add spaces to lpar name to have 25 chars total (for formating graph legend)
    $lpar_space =~ s/\&\&1/\//g;
    for ( my $k = length($lpar_space); $k < 25; $k++ ) {
      $lpar_space .= " ";
    }

    # Exclude pools and memory
    if ( $lpar =~ m/^pool$/ || $lpar =~ m/^mem$/ || $lpar =~ /^SharedPool[0-9]$/ || $lpar =~ m/^SharedPool[1-9][0-9]$/ || $lpar =~ m/^mem-pool$/ || $lpar =~ m/^cod$/ ) {
      next;
    }

    #ACL check, do not include !isGranted vms in lpars aggregated (in shared pools)
    if ( $xormon && $power ) {
      my $lpar_uid = PowerDataWrapper::get_item_uid( { type => "VM", label => $lpar } );
      my $aclitem  = { hw_type => 'POWER', item_id => $lpar_uid, match => 'granted' };
      if ( !$acl->isGranted($aclitem) ) {
        next;
      }
    }

    #print "$found $lpar $color[$found]\n";
    #print "$wrkdir/$server/$host/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3);

    $lpar_space      =~ s/:/\\:/g;    # anti ':'
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;     # anti '%
    my $wrkdir_server_host_file = "$wrkdir/$server/$host/$file";
    $wrkdir_server_host_file =~ s/:/\\:/g;
    my $wrkdir_server_host_file_legend = $wrkdir_server_host_file;
    $wrkdir_server_host_file_legend =~ s/%/%%/g;

    my $wrkdir_server_host_file_lpm = "$wrkdir/$server/*/$file";
    $wrkdir_server_host_file_lpm =~ s/:/\\:/g;

    # to use data from all HMCs (not real LPM, LPM is between servers what this does not do
    my ( $result_cmd, $CPU_cap, $CPU_uncap, $CPU_ent, $CPU_cur ) = LPM_easy( "AVERAGE", "$wrkdir_server_host_file_lpm", $i, $req_time, "capped_cycles", "uncapped_cycles", "entitled_cycles", "curr_proc_units" );

    $cmd .= $result_cmd;
    $cmd .= " CDEF:cap_peak${i}=$CPU_cap";
    $cmd .= " CDEF:uncap${i}=$CPU_uncap";
    $cmd .= " CDEF:ent${i}=$CPU_ent";
    $cmd .= " CDEF:cur${i}=$CPU_cur";

    # bulid RRDTool cmd
    # $cmd .= " DEF:cap_peak${i}=\"$wrkdir_server_host_file\":capped_cycles:AVERAGE";
    # $cmd .= " DEF:uncap${i}=\"$wrkdir_server_host_file\":uncapped_cycles:AVERAGE";
    # $cmd .= " DEF:ent${i}=\"$wrkdir_server_host_file\":entitled_cycles:AVERAGE";
    # $cmd .= " DEF:cur${i}=\"$wrkdir_server_host_file\":curr_proc_units:AVERAGE";

    # filtering peaks caused by LPM or changing entitled, if cap CPU util is > entitled --> UNKN
    # usualy cap counter is affected only
    # sometimes might happen that even in normal load capped util is little higher than entitled! Therefore using 1.2
    $cmd .= " CDEF:cap${i}=cap_peak${i},ent${i},/,1.2,GT,UNKN,cap_peak${i},IF";

    $cmd .= " CDEF:tot${i}=cap${i},uncap${i},+";
    $cmd .= " CDEF:util${i}=tot${i},ent${i},/";
    $cmd .= " CDEF:utiltotu${i}=util${i},cur${i},*";
    $cmd .= " CDEF:utiltot${i}=utiltotu${i},UN,0,utiltotu${i},IF";

    $cmd .= " $gtype:utiltot${i}$color[$color_indx]:\"$lpar_space\"";

    $cmd .= " PRINT:utiltot${i}:AVERAGE:\"%5.2lf $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_indx] $delimiter $wrkdir_server_host_file_legend\"";
    $cmd .= " PRINT:utiltot${i}:MAX:\" %5.2lf $delimiter \"";

    $color_indx = ( $color_indx + 1 ) % ( $color_max + 1 );

    $cmd .= " GPRINT:utiltot${i}:AVERAGE:\"%5.2lf \"";
    $cmd .= " GPRINT:utiltot${i}:MAX:\" %5.2lf \"";

    #$cmd .= " GPRINT:utiltot${i}:MAX:\" %5.2lf \\l\"";
    # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)
    $gtype = "STACK";
    $i++;
    if ( $line_indx == $line_items ) {

      # put carriage return after each second lpar in the legend
      $cmd .= " COMMENT:\"\\l\"";
      $line_indx = 0;
    }
    else {
      $line_indx++;
    }
  }

  $cmd .= " COMMENT:\"\\l\"";

  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;    # a trick, there was a problem with aggregated and "COMMENT: "

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph pool agg rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_hmccount {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t          = "COMMENT: ";
  my $t2         = "COMMENT:\\n";
  my $step_new   = $step;
  my $last       = "COMMENT: ";
  my $head       = "COMMENT:                            Average   \\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains
    }
  }

  if ( ( $type !~ m/m/ ) && ( $type !~ m/y/ ) ) {
    error( "Graph rrdtool error : graph_hmccount: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_hmccount: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }

  my $rrx_name = "$wrkdir/$host\.rrx";

  # test if exists database for lpars and servers for hmc
  if ( !-f $rrx_name ) {
    return 0;    # some workaround, it should not go here
  }

  $t = "COMMENT:\\s";
  my $start_rrd = -( 86400 * 365 );
  my $season    = "year";

  if ( $type =~ m/m/ ) {
    RRDp::cmd qq(last "$rrx_name");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t         = "COMMENT:Updated once a day\\: $l ";
    $start_rrd = -( 86400 * 31 );
    $season    = "month";
  }
  my $vertical_label = "--vertical-label=\"Quantity\"";
  my $epoch          = "last $season";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
    $epoch          = $season;
  }

  $rrx_name =~ s/:/\\:/g;
  $html_heading = "fake heading";
  my $header = "$host totals : $epoch";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  #$cmd .= 'RRDp::cmd qq($graph_cmd "$name_out"

  # `echo "graph hmccount $host,$server,$lpar,$type,$detail,$width,$height,$font_def,$font_tit," >> /tmp/hmccount`;
  RRDp::cmd qq($graph_cmd "$name_out"
        "--title" "$header"
        "--start" "$start_rrd"
        "--end" "now"
        "--imgformat" "PNG"
        "$disable_rrdtool_tag"
        "--slope-mode"
        "--width=$width"
        "--height=$height"
        "$font_def"
        "$font_tit"
        "$no_legend"
        "--lower-limit=0"
        "--color=BACK#$pic_col"
        "--color=SHADEA#$pic_col"
        "--color=SHADEB#$pic_col"
        "--color=CANVAS#$pic_col"
        "--alt-autoscale-max"
        "$vertical_label"
        "--units-exponent=1.00"
        "--alt-y-grid"
        "$xgrid"
    "DEF:roundtrip=$rrx_name:servers:MAX"
    "DEF:roundtrip1=$rrx_name:lpars:MAX"
    "DEF:rts=$rrx_name:servers:LAST"
    "DEF:rtl=$rrx_name:lpars:LAST"
    "DEF:rtsa=$rrx_name:servers:AVERAGE"
    "DEF:rtla=$rrx_name:lpars:AVERAGE"
    "COMMENT:          "
    "COMMENT:average  "
    "COMMENT:maximum  "
    "COMMENT:last  \\s"
    "COMMENT:\\s"
    "LINE1:roundtrip#FF0000:servers"
    "GPRINT:rtsa:AVERAGE:%8.0lf"
    "GPRINT:roundtrip:MAX:%9.0lf"
    "GPRINT:rts:LAST:%6.0lf\\s"
    "COMMENT:\\s"
    "LINE1:roundtrip1#0000FF:lpars  "
    "GPRINT:rtla:AVERAGE:%8.0lf"
    "GPRINT:roundtrip1:MAX:%9.0lf"
    "GPRINT:rtl:LAST:%6.0lf\\s"
    "COMMENT:\\s"
    "COMMENT:\\s"
    "$t"
  );
  my $answer = RRDp::read;
  if ( $$answer =~ "ERROR" ) {
    error( "$host:$server Graph rrdtool hmccount error : $$answer " . __FILE__ . ":" . __LINE__ );
  }

  return 0;
}

sub graph_memalloc {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;

  my $t = "COMMENT: ";
  if ( $item eq "clustmem" ) {
    $t = "COMMENT:\" \"";
  }
  my $t2               = "COMMENT:\\n";
  my $step_new         = $step;
  my $last             = "COMMENT: ";
  my $head             = "COMMENT:                            Average   \\n";
  my $dsmem_ident      = "";                                                    # ds name for hist rep
  my $rpool_name_ident = "";                                                    # rp name for hist rep

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph Memory Alloc: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }

  my $rrd      = "$wrkdir/$server/$host/mem.rr$type_sam";
  my $file_pth = "$wrkdir/$server/*/mem.rr$type_sam";
  my ( $result_cmd, $curr_avail_mem, $sys_firmware_mem, $conf_sys_mem ) = LPM_easy( "AVERAGE", $file_pth, "0", "0", "curr_avail_mem", "sys_firmware_mem", "conf_sys_mem" );

  # test if exists database for lpars and servers for hmc

  my $server_vmw_name;
  if ($vmware) {
    $rrd = "$wrkdir/$server/$host/pool.rrm";

    if ( ( $item eq "clustmem" ) || ( $item eq "clustpow" ) ) {
      ( $rrd, $server_vmw_name ) = find_human_cluster_name();
      if ( !-f "$rrd" ) {
        error( "graph_:memalloc no such cluster $wrkdir/$server/$host/cluster.rrc " . __FILE__ . ":" . __LINE__ );
        return;
      }
      if ( $server_vmw_name ne "" && $detail ne 2 ) {
        $text = "$text : $server_vmw_name";
      }
    }
    elsif ( $item eq "rpmem" ) {

      # $rrd= "$wrkdir/$server/$host/Resources.rrc";
      $rrd = "$wrkdir/$server/$host/$lpar.rrc";
      ( undef, $server_vmw_name ) = find_human_cluster_name();
      $rpool_name_ident = $server_vmw_name . ": " . find_human_rpool_name($lpar);
    }
    elsif ( $item eq "dsmem" ) {
      $rrd         = "$wrkdir/$server/$host/$lpar.rrs";
      $dsmem_ident = find_human_ds_name( $server, $host, $lpar );
    }
    elsif ( $item eq "esxipow" ) {
      $rrd = "$wrkdir/$server/$host/pool.rrm";
    }

    if ( !-f $rrd ) {
      error( "$rrd does not exists (vmware \$item $item) " . __FILE__ . ":" . __LINE__ );
      return 0;    # some workaround, it should not go here
    }
  }
  elsif ($hyperv) {
    if ( $item =~ /lfd_cat_/ ) {
      my $lfd_disk = $item;
      $lfd_disk =~ s/lfd_cat_//;
      $lfd_disk =~ s/\%3A/:/;      # can come when zoom
                                   # $rrd = "$wrkdir/$server/$host/Local_Fixed_Disk_$lfd_disk.rrm";
      $rrd = "$wrkdir/$server/$host/Local_Fixed_Disk_$lpar.rrm";

      # print STDERR "10587 \$rrd $rrd\n";
    }
    elsif ( $item =~ /csv_cat_/ ) {
      my $lfd_disk = $item;

      # print STDERR "12651 \$item $item\n";
      #$lfd_disk =~ s/csv_cat_CSV//;
      $lfd_disk =~ s/csv_cat_//;
      $lfd_disk =~ s/\%3A/:/;      # can come when zoom
                                   #$rrd = "$wrkdir/$server/$host/Cluster_Storage_Volume$lfd_disk.rrm";
                                   #$rrd = "$wrkdir/$server/$host/Cluster_Storage_$lfd_disk.rrm";
      $rrd = "$wrkdir/$server/$host/Cluster_Storage_$lpar.rrm";
    }
    elsif ( $item =~ /^s2dvol_capacity$/ ) {
      $rrd = "$wrkdir/$server/$host/volumes/vol_$lpar.rrm";
    }
    else {
      $rrd = "$wrkdir/$server/$host/pool.rrm";
    }
    if ( !-f $rrd ) {
      error( "$rrd does not exists (hyperv \$server $server \$host $host \$item $item \$lpar $lpar) " . __FILE__ . ":" . __LINE__ );
      return 0;                    # some workaround, it should not go here
    }
  }
  elsif ($hitachi) {
    $rrd = "$wrkdir/$server/$host/SYS-MEM.hrm";
    if ( !-f $rrd ) {
      error( "$rrd does not exists (hitachi) " . __FILE__ . ":" . __LINE__ );
      return 0;                    # some workaround, it should not go here
    }
  }
  else {                           # POWER server
    if ( !-f $rrd ) {
      error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
      return 0;                    # some workaround, it should not go here
    }

  }

  # do not update charts if there is not new data in RRD DB
  #    if ( -f "$rrd" ) {
  #      $rrd_time = (stat("$rrd"))[9];
  #      if ( ($act_time - $rrd_time) > $DELETED_LPARS_TIME ) { #10 days
  #         #error ("----$rrd");
  #        return 0;
  #      }
  #   }

  my $header         = "Memory usage: last $text";
  my $vertical_label = "--vertical-label=Memory in GBytes";
  my $clu_name       = "CLU";
  if ( $item eq "clustmem" || $item eq "rpmem" ) {
    $vertical_label = "--vertical-label=Memory in Bytes";
  }
  if ( $item =~ "lfd_cat" || $item =~ "csv_cat" ) {
    $vertical_label = "--vertical-label=Space in Bytes";
    $header         = "Space usage:$lpar last $text";
    $dsmem_ident    = "$lpar";
  }
  if ( $item eq "s2dvol_capacity" ) {
    $clu_name = $host;
    $clu_name =~ s/cluster_//g;
    $vertical_label = "--vertical-label=Space in Bytes";
    $header         = "$clu_name : Volume : $lpar : last $text";
  }
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";          # nope string
    $header         = "Memory usage: $text";
    if ( $item =~ "lfd_cat" || $item =~ "csv_cat" ) {
      $header = "Space usage:$lpar $text";
    }
  }
  if ( $item eq "clustpow" ) {
    $header         = "Power usage: last $text";
    $vertical_label = "--vertical-label=Power in Watts";
    if ( $detail == 2 ) {
      $vertical_label = "--interlaced";         # nope string
      $header         = "Power usage: $text";
    }
  }
  if ( $item eq "esxipow" ) {
    $header         = "Power usage: last $text";
    $vertical_label = "--vertical-label=Power in Watts";
    if ( $detail == 2 ) {
      $vertical_label = "--interlaced";         # nope string
      $header         = "Power usage: $text";
    }
  }
  if ( $item eq "dsmem" || $item =~ "hdisk_Disk" ) {
    $header         = "Space usage: last $text";
    $vertical_label = "--vertical-label=Space in Bytes";
    if ( $detail == 2 ) {
      $vertical_label = "--interlaced";                # nope string
                                                       #$header         = "Space usage: $text";
      $header         = "Space:$dsmem_ident: $text";
    }
  }
  if ($hyperv) {
    $header = "Memory usage: $host: last $text";
    $header = "Space usage: $host: last $text" if $item eq "lfd_cat_";
    if ( $detail == 2 ) {
      $header = "Memory: $text";
      $header = "Space: $text" if $item eq "lfd_cat_";
    }
  }
  if ($hitachi) {
    $vertical_label = "--vertical-label=Memory usage %";
    if ( $detail == 2 ) {
      $vertical_label = "--interlaced";         # nope string
      $header         = "Space usage: $text";
    }
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT: ";    # just a trick to place there something otherwise rrdtool complains
        if ( $item eq "clustmem" ) {
          $xgrid = "COMMENT:\" \"";
        }
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);

      # $header = "Memory usage $text: $start_human - $end_human";
      $header = "Memory usage: $start_human - $end_human";
      $header = "Memory usage:$host: $start_human - $end_human"             if $hyperv && $item eq "memalloc";
      $header = "Space usage:$dsmem_ident $start_human - $end_human"        if ( $item eq "dsmem" || $item =~ "hdisk_Disk" || $item =~ /lfd_cat_/ || $item =~ /csv_cat_/ );
      $header = "Space usage:$rpool_name_ident $start_human - $end_human"   if ( $item eq "rpmem" );
      $header = "Power usage $text: $start_human - $end_human"              if ( $item eq "clustpow" || $item eq "esxipow" );
      $header = "Memory usage: $server_vmw_name: $start_human - $end_human" if ( $item eq "clustmem" );
      if ( $detail == 10 ) {
        $header = "$server : Memory usage: $start_human - $end_human";
        $header = "Space usage:$dsmem_ident $start_human - $end_human"      if ( $item eq "dsmem" || $item =~ "hdisk_Disk" || $item =~ /lfd_cat_/ || $item =~ /csv_cat_/ );
        $header = "Space usage:$rpool_name_ident $start_human - $end_human" if ( $item eq "rpmem" );
        $header = "Power usage $text: $start_human - $end_human"            if ( $item eq "clustpow" || $item eq "esxipow" );
      }
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  # print "creating graph : $host:$server:$lpar:$type_sam:$type\n" if $DEBUG ;
  #print "Graph mem  : $lpar\n";
  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\: $l ";
    if ( $item eq "clustmem" ) {
      $t = "COMMENT:Updated\\:\" $l \"";
    }
  }

  #if ( $type =~ "y" ) {
  #    $step_new=86400;
  #}

  $rrd =~ s/:/\\:/g;

  #      "DEF:free=$rrd:curr_avail_mem:AVERAGE:start=1440030000:end=1440100000:start=1440110000:end=1440120000"
  #      "DEF:fw=$rrd:sys_firmware_mem:AVERAGE:start=1440030000:end=1440100000:start=1440110000:end=1440120000"
  #      "DEF:tot=$rrd:conf_sys_mem:AVERAGE:start=1440030000:end=1440100000:start=1440110000:end=1440120000"

  if ($hyperv) {
    if ( $item =~ /lfd_cat_/ || $item =~ /csv_cat_/ ) {
      RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--base=1024"
      "$xgrid"
      "DEF:freeb=$rrd:FreeSpace:AVERAGE"
      "DEF:totb=$rrd:Size:AVERAGE"
      "CDEF:grantb=totb,freeb,-"
      "CDEF:tott=totb,1024,/,1024,/,1024,/,1024,/"
      "CDEF:grantt=grantb,1024,/,1024,/,1024,/,1024,/"
      "COMMENT:   TB                 Avg       Max\\n"
      "AREA:totb#00FF00: Total          "
      "GPRINT:tott:AVERAGE: %6.2lf"
      "GPRINT:tott:MAX: %6.2lf"
      "$t2"
      "AREA:grantb#0080FF: Used           "
      "GPRINT:grantt:AVERAGE: %6.2lf"
      "GPRINT:grantt:MAX: %6.2lf"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
    );
    }
    elsif ( $item =~ /^s2dvol_capacity$/ ) {
      RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--base=1024"
      "$xgrid"
      "DEF:freeb=$rrd:Size_Available:AVERAGE"
      "DEF:totb=$rrd:Size_Total:AVERAGE"
      "CDEF:grantb=totb,freeb,-"
      "CDEF:tott=totb,1024,/,1024,/,1024,/,1024,/"
      "CDEF:grantt=grantb,1024,/,1024,/,1024,/,1024,/"
      "COMMENT:   TB                 Avg       Max\\n"
      "AREA:totb#00FF00: Total          "
      "GPRINT:tott:AVERAGE: %6.2lf"
      "GPRINT:tott:MAX: %6.2lf"
      "$t2"
      "AREA:grantb#0080FF: Used           "
      "GPRINT:grantt:AVERAGE: %6.2lf"
      "GPRINT:grantt:MAX: %6.2lf"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
    );
    }
    else {
      RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--base=1024"
      "$xgrid"
      "DEF:free=$rrd:AvailableMBytes:AVERAGE"
      "DEF:tot=$rrd:TotalPhysMemory:AVERAGE"
      "DEF:cachebytes=$rrd:CacheBytes:AVERAGE"
      "CDEF:freeg=free,1024,/"
      "CDEF:totg=tot,1024,/,1024,/,1024,/"
      "CDEF:cacheg=cachebytes,1024,/,1024,/,1024,/"
      "CDEF:used_comp=totg,freeg,-"
      "CDEF:used=used_comp,0,LE,0,used_comp,IF"
      "CDEF:freegc=freeg,cacheg,-"
      "COMMENT:   [GiB]              Avrg     Max\\n"
      "AREA:used#FF4040: Used memory  "
      "GPRINT:used:AVERAGE:    %6.2lf"
      "GPRINT:used:MAX: %6.2lf"
      "$t2"
      "STACK:cacheg#0080FF: Cache        "
      "GPRINT:cacheg:AVERAGE:    %6.2lf"
      "GPRINT:cacheg:MAX: %6.2lf"
      "$t2"
      "STACK:freegc#00FF00: Free memory    "
      "GPRINT:freegc:AVERAGE:  %6.2lf"
      "GPRINT:freegc:MAX: %6.2lf"
      "$t2"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
    );
    }
  }
  elsif ($hitachi) {
    RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--upper-limit=100"
      "--base=1024"
      "$xgrid"
      "DEF:usedp=$rrd:mem_usedp:AVERAGE"
      "COMMENT:[%]   \\n"
      "LINE1:usedp#FF0000: Usage"
      "GPRINT:usedp:AVERAGE: %4.2lf"
      "$t2"
      "$t"
    );
  }
  elsif ( !$vmware ) {
    my $cmd;
    $cmd .= "$graph_cmd \"$name_out\"
      \"--title\" \"$header\"
      \"--start\" \"$start_time\"
      \"--end\" \"$end_time\"
      \"--imgformat\" \"PNG\"
      \"$disable_rrdtool_tag\"
      \"--slope-mode\"
      \"--width=$width\"
      \"--height=$height\"
      \"$font_def\"
      \"$font_tit\"
      \"$no_legend\"
      \"--step=$step_new\"
      \"--lower-limit=0\"
      \"--color=BACK#$pic_col\"
      \"--color=SHADEA#$pic_col\"
      \"--color=SHADEB#$pic_col\"
      \"--color=CANVAS#$pic_col\"
      \"$vertical_label\"
      \"--upper-limit=1\"
      \"--alt-autoscale-max\"
      \"--base=1024\"
      \"$xgrid\"";
    $cmd .= $result_cmd;
    $cmd .= "
      \"CDEF:free=$curr_avail_mem\"
      \"CDEF:fw=$sys_firmware_mem\"
      \"CDEF:tot=$conf_sys_mem\"
      \"CDEF:freeg=free,1024,/\"
      \"CDEF:fwg=fw,1024,/\"
      \"CDEF:totg=tot,1024,/\"
      \"CDEF:used=totg,freeg,-\"
      \"CDEF:used1=used,fwg,-\"
      \"COMMENT:   Average   \\n\"
      \"AREA:fwg$pastel_blue: Firmware memory\"
      \"GPRINT:fwg:AVERAGE: %4.2lf GB\"
      \"$t2\"
      \"STACK:used1$pastel_red: Used memory    \"
      \"GPRINT:used1:AVERAGE: %4.2lf GB\"
      \"$t2\"
      \"STACK:freeg$pastel_green: Free memory    \"
      \"GPRINT:freeg:AVERAGE: %4.2lf GB\"
      \"$t2\"
      \"$t\"
      \"HRULE:0#000000\"
      \"VRULE:0#000000\"
    ";
    RRDp::cmd qq($cmd);
  }
  elsif ( $item eq "rpmem" ) {
    RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--base=1024"
      "$xgrid"
      "DEF:granted=$rrd:Memory_granted_KB:AVERAGE"
      "DEF:active=$rrd:Memory_active_KB:AVERAGE"
      "DEF:consumed=$rrd:Memory_consumed_KB:AVERAGE"
      "DEF:balloon=$rrd:Memory_baloon_KB:AVERAGE"
      "DEF:swap=$rrd:Memory_swap_KB:AVERAGE"
      "DEF:reservation=$rrd:Memory_reservation:AVERAGE"
      "DEF:limit=$rrd:Memory_limit:AVERAGE"
      "CDEF:grantb=granted,1024,*"
      "CDEF:activeb=active,1024,*"
      "CDEF:consumb=consumed,1024,*"
      "CDEF:balloonb=balloon,1024,*"
      "CDEF:swapb=swap,1024,*"
      "CDEF:reservationb=reservation,1024,*,1024,*"
      "CDEF:limitb=limit,1024,*,1024,*"
      "CDEF:grantg=granted,1024,/,1024,/"
      "CDEF:activeg=active,1024,/,1024,/"
      "CDEF:consumg=consumed,1024,/,1024,/"
      "CDEF:balloong=balloon,1024,/,1024,/"
      "CDEF:swapg=swap,1024,/,1024,/"
      "CDEF:reservationg=reservation,1024,/"
      "CDEF:limitg=limit,1024,/"
      "COMMENT:   GB                 Avg       Max\\n"
      "AREA:reservationb#00FF00: Reservation    "
      "GPRINT:reservationg:AVERAGE: %6.1lf"
      "GPRINT:reservationg:MAX: %6.1lf"
      "$t2"
      "LINE:grantb#0080FF: Granted        "
      "GPRINT:grantg:AVERAGE: %6.1lf"
      "GPRINT:grantg:MAX: %6.1lf"
      "$t2"
      "LINE:consumb#00FFFF: Consumed       "
      "GPRINT:consumg:AVERAGE: %6.1lf"
      "GPRINT:consumg:MAX: %6.1lf"
      "$t2"
      "LINE:activeb#FF0000: Active         "
      "GPRINT:activeg:AVERAGE: %6.1lf"
      "GPRINT:activeg:MAX: %6.1lf"
      "$t2"
      "LINE:balloonb#FFFF00: Balloon        "
      "GPRINT:balloong:AVERAGE: %6.1lf"
      "GPRINT:balloong:MAX: %6.1lf"
      "$t2"
      "LINE:swapb#FFA000: Swap out       "
      "GPRINT:swapg:AVERAGE: %6.1lf"
      "GPRINT:swapg:MAX: %6.1lf"
      "$t2"
      "LINE:limitb#000000: Limit          "
      "GPRINT:limitg:AVERAGE: %6.1lf"
      "GPRINT:limitg:MAX: %6.1lf (0 means Unlimited)"
      "$t2"
      "$t"
      "HRULE:0#000000"
    "VRULE:0#000000"
  );
  }
  elsif ( $item eq "dsmem" ) {
    RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
    "--start" "$start_time"
    "--end" "$end_time"
    "--imgformat" "PNG"
    "$disable_rrdtool_tag"
    "--slope-mode"
    "--width=$width"
    "--height=$height"
    "$font_def"
    "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--base=1024"
      "$xgrid"
      "DEF:total=$rrd:Disk_capacity:AVERAGE"
      "DEF:granted=$rrd:Disk_used:AVERAGE"
      "DEF:active=$rrd:Disk_provisioned:AVERAGE"
      "CDEF:grantb=granted,1024,*"
      "CDEF:activeb=active,1024,*"
      "CDEF:totb=total,1024,*"
      "CDEF:grantt=granted,1024,/,1024,/,1024,/"
      "CDEF:activet=active,1024,/,1024,/,1024,/"
      "CDEF:tott=total,1024,/,1024,/,1024,/"
      "COMMENT:   TB                 Avg       Max\\n"
      "AREA:totb#00FF00: Total          "
      "GPRINT:tott:AVERAGE: %6.2lf"
      "GPRINT:tott:MAX: %6.2lf"
      "$t2"
      "AREA:grantb#0080FF: Used           "
      "GPRINT:grantt:AVERAGE: %6.2lf"
      "GPRINT:grantt:MAX: %6.2lf"
      "$t2"
      "LINE:activeb#FF0000: Provisioned    "
      "GPRINT:activet:AVERAGE: %6.2lf"
      "GPRINT:activet:MAX: %6.2lf"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
    );
  }
  elsif ( $item eq "clustmem" ) {

=begin comment # do not use it anymore, sometimes it stucks RRD tool without return, do not know why
    # for Total MEM create sum of all ESXi CPU pool GB (Memory_Host_Size) in this cluster
    my $cmd_x            = "";
    my $hosts_in_cluster = $rrd;
    $hosts_in_cluster =~ s/cluster.rrc/hosts_in_cluster/;
    open( FF, "<$hosts_in_cluster" ) || error( "can't open $hosts_in_cluster: $! :" . __FILE__ . ":" . __LINE__ ) && return;
    my @hosts = (<FF>);
    close(FF);

    # print STDERR "10206 \@hosts @hosts\n"; # e.g. 10.22.11.8XORUX10.22.11.10
    my $i       = 0;
    my $rpn_sum = "";
    foreach my $one_host (@hosts) {
      chomp $one_host;
      ( my $host, my $cluster ) = split( "XORUX", $one_host );

      # print STDERR "10212 testing $wrkdir/$host/$cluster/pool.rrm\n";
      if ( -f "$wrkdir/$host/$cluster/pool.rrm" ) {
        $cluster =~ s/:/\\:/;    # if there is port
        #        $cmd_x .= " DEF:hosts_memx${i}=\"$wrkdir/$host/$cluster/pool.rrm\":Memory_Host_Size:AVERAGE";
        $cmd_x .= " DEF:hosts_mem${i}=\"$wrkdir/$host/$cluster/pool.rrm\":Memory_Host_Size:AVERAGE";
        #        $cmd_x .= " CDEF:hosts_mem${i}=hosts_memx${i},UN,0,hosts_memx${i},IF";

        if ( $i == 0 ) {
          $rpn_sum = "hosts_mem0";
        }
        else {
          $rpn_sum .= ",hosts_mem${i},+";
        }
        $i++;
      } ## end if ( -f "$wrkdir/$host/$cluster/pool.rrm")
    } ## end foreach my $one_host (@hosts)
    $i > 0 || error( "Cluster has no ESXi servers in $hosts_in_cluster: $! :" . __FILE__ . ":" . __LINE__ ) && return;

    # $cmd_x .= " CDEF:hosts_mem=$rpn_sum,1,+,1,-";
    $cmd_x .= " CDEF:hosts_mem=$rpn_sum,1073741824,+";
    # $cmd_x .= " CDEF:hosts_mem=$rpn_sum";

    # $cmd_x .= " CDEF:hosts_memg=hosts_mem,1073741824,/"; # it is 1024,/,1024,/,1024,/";
    $cmd_x .= " CDEF:hosts_memg=hosts_mem,1073741824,/,1,-"; # it is 1024,/,1024,/,1024,/";
=end comment
=cut

    # print STDERR "13480 \$type $type \$cmd_x $cmd_x\n";
    my $cmd = "$graph_cmd \"$name_out\"";
    $cmd .= " --title \"$header\"";
    $cmd .= " --start $start_time";
    $cmd .= " --end $end_time";
    $cmd .= " --imgformat PNG";
    $cmd .= " $disable_rrdtool_tag";
    $cmd .= " --slope-mode";
    $cmd .= " --width=$width";
    $cmd .= " --height=$height";
    $cmd .= " $font_def";
    $cmd .= " $font_tit";
    $cmd .= " $no_legend";
    $cmd .= " --step=$step_new";
    $cmd .= " --lower-limit=0";
    $cmd .= " --color=BACK#$pic_col";
    $cmd .= " --color=SHADEA#$pic_col";
    $cmd .= " --color=SHADEB#$pic_col";
    $cmd .= " --color=CANVAS#$pic_col";
    $cmd .= " \"$vertical_label\"";
    $cmd .= " --upper-limit=1";
    $cmd .= " --alt-autoscale-max";
    $cmd .= " --base=1024";
    $cmd .= " $xgrid";

    #$cmd .= " $cmd_x";
    $cmd .= " DEF:total=$rrd:Memory_total_MB:AVERAGE";
    $cmd .= " DEF:granted=$rrd:Memory_granted_KB:AVERAGE";
    $cmd .= " DEF:active=$rrd:Memory_active_KB:AVERAGE";
    $cmd .= " DEF:consumed=$rrd:Memory_consumed_KB:AVERAGE";
    $cmd .= " DEF:balloon=$rrd:Memory_baloon_KB:AVERAGE";
    $cmd .= " DEF:swap=$rrd:Memory_swap_KB:AVERAGE";
    $cmd .= " CDEF:grantg=granted,1024,/,1024,/";
    $cmd .= " CDEF:activeg=active,1024,/,1024,/";
    $cmd .= " CDEF:totg=total,1024,/";
    $cmd .= " CDEF:consumg=consumed,1024,/,1024,/";
    $cmd .= " CDEF:balloong=balloon,1024,/,1024,/";
    $cmd .= " CDEF:swapg=swap,1024,/,1024,/";
    $cmd .= " CDEF:grantb=granted,1024,*";
    $cmd .= " CDEF:activeb=active,1024,*";
    $cmd .= " CDEF:totb=total,1024,*,1024,*";
    $cmd .= " CDEF:consumb=consumed,1024,*";
    $cmd .= " CDEF:balloonb=balloon,1024,*";
    $cmd .= " CDEF:swapb=swap,1024,*";
    $cmd .= " COMMENT:\"   GB                   Avg       Max\\n\"";

    #$cmd .= " LINE:hosts_mem#000000:\" Total          \"";
    #$cmd .= " GPRINT:hosts_memg:AVERAGE:\" %6.0lf\"";
    #$cmd .= " GPRINT:hosts_memg:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " AREA:totb$pastel_green:\" Total effective\"";
    $cmd .= " GPRINT:totg:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:totg:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE:grantb#0080FF:\" Granted        \"";
    $cmd .= " GPRINT:grantg:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:grantg:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE:consumb#00FFFF:\" Consumed       \"";
    $cmd .= " GPRINT:consumg:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:consumg:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE:activeb#FF0000:\" Active         \"";
    $cmd .= " GPRINT:activeg:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:activeg:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE:balloonb#FFFF00:\" Balloon        \"";
    $cmd .= " GPRINT:balloong:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:balloong:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE:swapb#FFA000:\" Swap out       \"";
    $cmd .= " GPRINT:swapg:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:swapg:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";
    $cmd .= " VRULE:0#000000";

    #    ); #00FFFF AEA79F 77216F
    # print STDERR "10305 $cmd\n";
    RRDp::cmd qq($cmd);

  }
  elsif ( $item eq "clustpow" ) {
    RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--base=1024"
      "$xgrid"
      "DEF:totg=$rrd:Power_cup_Watt:AVERAGE"
      "DEF:activeg=$rrd:Power_usage_Watt:AVERAGE"
      "CDEF:totgk=totg,1000,/"
      "CDEF:activegk=activeg,1000,/"
      "COMMENT:   Average   \\n"
      "AREA:totg#00FF00: Power Cup      "
      "GPRINT:totgk:AVERAGE: %4.1lf kWatt"
      "$t2"
      "LINE:activeg#FF0000: Power Actual   "
      "GPRINT:activegk:AVERAGE: %4.1lf kWatt"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
    );    #  "CDEF:activeg=active,1024,/,1024,/"
          #  "CDEF:totg=total,1024,/,1024,/,1024,/"
  }
  elsif ( $item eq "esxipow" ) {
    RRDp::cmd qq($graph_cmd "$name_out"
      "--title" "$header"
      "--start" "$start_time"
      "--end" "$end_time"
      "--imgformat" "PNG"
      "$disable_rrdtool_tag"
      "--slope-mode"
      "--width=$width"
      "--height=$height"
      "$font_def"
      "$font_tit"
      "$no_legend"
      "--step=$step_new"
      "--lower-limit=0"
      "--color=BACK#$pic_col"
      "--color=SHADEA#$pic_col"
      "--color=SHADEB#$pic_col"
      "--color=CANVAS#$pic_col"
      "$vertical_label"
      "--upper-limit=1"
      "--alt-autoscale-max"
      "--base=1024"
      "$xgrid"
      "DEF:activegk=$rrd:Power_usage_Watt:AVERAGE"
      "COMMENT:   Average   \\n"
      "LINE:activegk#FF0000: Power Actual   "
      "GPRINT:activegk:AVERAGE: %4.1lf Watt"
      "$t2"
      "$t"
      "HRULE:0#000000"
      "VRULE:0#000000"
    );    #  "CDEF:activeg=active,1024,/,1024,/"
          #  "CDEF:totg=total,1024,/,1024,/,1024,/"
  }

  else {    #server ESXI mem vmware
    my $file_pth_vmware = "$wrkdir/$server/*/pool.rrm";
    my ( $result_cmd, $Memory_Host_Size, $Memory_baloon, $Memory_granted, $Memory_active ) = LPM_easy( "AVERAGE", $file_pth_vmware, "0", "0", "Memory_Host_Size", "Memory_baloon", "Memory_granted", "Memory_active" );

    # print STDERR "19340 \$Memory_Host_Size $Memory_Host_Size \$Memory_baloon $Memory_baloon \$Memory_granted $Memory_granted \$Memory_active $Memory_active\n";
    # my $form_dec = "%6.1lf";
    my $form_dec = "%6.0lf";

    my $cmd;
    $cmd .= "$graph_cmd \"$name_out\"
      \"--title\" \"$header\"
      \"--start\" \"$start_time\"
      \"--end\" \"$end_time\"
      \"--imgformat\" \"PNG\"
      \"$disable_rrdtool_tag\"
      \"--slope-mode\"
      \"--width=$width\"
      \"--height=$height\"
      \"$font_def\"
      \"$font_tit\"
      \"$no_legend\"
      \"--step=$step_new\"
      \"--lower-limit=0\"
      \"--color=BACK#$pic_col\"
      \"--color=SHADEA#$pic_col\"
      \"--color=SHADEB#$pic_col\"
      \"--color=CANVAS#$pic_col\"
      \"$vertical_label\"
      \"--upper-limit=1\"
      \"--alt-autoscale-max\"
      \"--base=1024\"
      \"$xgrid\"";
    $cmd .= $result_cmd;
    $cmd .= "
        \"CDEF:total=$Memory_Host_Size\"
        \"CDEF:baloon=$Memory_baloon\"
        \"CDEF:granted=$Memory_granted\"
        \"CDEF:active=$Memory_active\"
        \"CDEF:grantg=granted,1024,/,1024,/\"
        \"CDEF:activeg=active,1024,/,1024,/\"
        \"CDEF:baloong=baloon,1024,/,1024,/\"
        \"CDEF:totg=total,1024,/,1024,/,1024,/\"
        \"COMMENT:    GB                 Avrg     Max\\n\"
        \"AREA:totg$pastel_green: Total          \"
        \"GPRINT:totg:AVERAGE: $form_dec\"
        \"GPRINT:totg:MAX: $form_dec\"
        \"$t2\"
        \"AREA:grantg$pastel_blue: Granted        \"
        \"GPRINT:grantg:AVERAGE: $form_dec\"
        \"GPRINT:grantg:MAX: $form_dec\"
        \"$t2\"
        \"LINE:activeg#FF0000: Active         \"
        \"GPRINT:activeg:AVERAGE: $form_dec\"
        \"GPRINT:activeg:MAX: $form_dec\"
        \"$t2\"
        \"LINE:baloong#FFFF00: Baloon         \"
        \"GPRINT:baloong:AVERAGE: $form_dec\"
        \"GPRINT:baloong:MAX: $form_dec\"
        \"$t2\"
        \"$t\"
        \"HRULE:0#000000\"
        \"VRULE:0#000000\"
      ";
    RRDp::cmd qq($cmd);
  }

=begin comment
    RRDp::cmd qq($graph_cmd "$name_out"
        "--title" "$header"
        "--start" "$start_time"
        "--end" "$end_time"
        "--imgformat" "PNG"
        "$disable_rrdtool_tag"
        "--slope-mode"
        "--width=$width"
        "--height=$height"
        "$font_def"
        "$font_tit"
        "$no_legend"
        "--step=$step_new"
        "--lower-limit=0"
        "--color=BACK#$pic_col"
        "--color=SHADEA#$pic_col"
        "--color=SHADEB#$pic_col"
        "--color=CANVAS#$pic_col"
        "$vertical_label"
        "--upper-limit=1"
        "--alt-autoscale-max"
        "--base=1024"
        "$xgrid"
        "$result_cmd"
        "DEF:total=$rrd:$Memory_Host_Size:AVERAGE"
        "DEF:baloon=$rrd:$Memory_baloon:AVERAGE"
        "DEF:granted=$rrd:$Memory_granted:AVERAGE"
        "DEF:active=$rrd:$Memory_active:AVERAGE"
        "CDEF:grantg=granted,1024,/,1024,/"
        "CDEF:activeg=active,1024,/,1024,/"
        "CDEF:baloong=baloon,1024,/,1024,/"
        "CDEF:totg=total,1024,/,1024,/,1024,/"
        "COMMENT:    GB                 Avrg     Max\\n"
        "AREA:totg$pastel_green: Total          "
        "GPRINT:totg:AVERAGE: $form_dec"
        "GPRINT:totg:MAX: $form_dec"
        "$t2"
        "AREA:grantg$pastel_blue: Granted        "
        "GPRINT:grantg:AVERAGE: $form_dec"
        "GPRINT:grantg:MAX: $form_dec"
        "$t2"
        "LINE:activeg#FF0000: Active         "
        "GPRINT:activeg:AVERAGE: $form_dec"
        "GPRINT:activeg:MAX: $form_dec"
        "$t2"
        "LINE:baloong#FFFF00: Baloon         "
        "GPRINT:baloong:AVERAGE: $form_dec"
        "GPRINT:baloong:MAX: $form_dec"
        "$t2"
        "$t"
        "HRULE:0#000000"
        "VRULE:0#000000"
      );
  }
=end comment
=cut

  my $answ = RRDp::read;
  if ( $$answ =~ "ERROR" ) {
    error( "$host:$server Graph rrdtool error Memory Alloc : $$answ " . __FILE__ . ":" . __LINE__ );
  }
  $png_end_heading = ret_graph_param($answ);
  return 0;
}

sub graph_trendmemalloc {
  my $host     = shift;
  my $server   = shift;
  my $lpar     = shift;
  my $type     = shift;
  my $name_out = shift;
  my $type_sam = shift;
  my $detail   = shift;
  my $t        = "COMMENT: ";
  my $t2       = "COMMENT:\\n";
  my $step_new = $step;
  my $last     = "COMMENT: ";
  my $head     = "COMMENT:                            Average   \\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph Memory Alloc: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }

  my $rrd     = "$wrkdir/$server/$host/mem.rr$type_sam";
  my $rrd_lpm = "$wrkdir/$server/*/mem.rr$type_sam";

  if ($hitachi) {
    $rrd = "$wrkdir/$server/$host/SYS-MEM.hrm";
  }

  # test if exists database for lpars and servers for hmc
  if ( !-f $rrd ) {
    return 0;    # some workaround, it should not go here
  }
  my $header = "Memory usage: last $text";

  #print "creating graph : $host:$server:$lpar:$type_sam:$type\n" if $DEBUG ;

  $step_new = 86400;

  #  if ( $type =~ "y" ) {
  # Trend for yearly chart 1y back  + 1y forward
  #    print "creating graph : $host:$server:$lpar:$type_sam:$type:trend\n" if $DEBUG ;
  #  }

  my $vertical_label = "--vertical-label=\"Memory in GBytes\"";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  elsif ($hitachi) {
    $vertical_label = "--vertical-label=\"Memory usage %\"";
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  if ( $detail == 10 ) {
    $header = "$server : Memory usage: last $text";
  }

  $rrd =~ s/:/\\:/g;
  my $cmd = "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header - trend\"";
  $cmd .= " --start now-1$type";
  $cmd .= " --end now+1$type";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width_trend";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ($hitachi) {
    $cmd .= " --upper-limit=100";
    $cmd .= " DEF:usedp=\"$rrd\":mem_usedp:AVERAGE";
    $cmd .= " DEF:usedp_1m=\"$rrd\":mem_usedp:AVERAGE:start=-1m";
    $cmd .= " DEF:usedp_3m=\"$rrd\":mem_usedp:AVERAGE:start=-3m";
    $cmd .= " DEF:usedp_1y=\"$rrd\":mem_usedp:AVERAGE:start=-1y";
    $cmd .= " VDEF:Dd=usedp_1m,LSLSLOPE";
    $cmd .= " VDEF:Hd=usedp_1m,LSLINT";
    $cmd .= " CDEF:cpuusagetrend-1m=usedp_1m,POP,Dd,COUNT,*,Hd,+";
    $cmd .= " VDEF:Dm=usedp_3m,LSLSLOPE";
    $cmd .= " VDEF:Hm=usedp_3m,LSLINT";
    $cmd .= " CDEF:cpuusagetrend-3m=usedp_3m,POP,Dm,COUNT,*,Hm,+";
    $cmd .= " VDEF:Dy=usedp_1y,LSLSLOPE";
    $cmd .= " VDEF:Hy=usedp_1y,LSLINT";
    $cmd .= " CDEF:cpuusagetrend-1y=usedp_1y,POP,Dy,COUNT,*,Hy,+";

    $cmd .= " COMMENT:\"   Average     \\n\"";
    $cmd .= " LINE1:usedp#FF0000:\" Memory usage\"";
    $cmd .= " GPRINT:usedp:AVERAGE:\"    %2.2lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:cpuusagetrend-1m#0080FF:\" Memory usage    - last 1 month trend\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:cpuusagetrend-3m#80FFFF:\" Memory usage    - last 3 months trend\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:cpuusagetrend-1y#FF8080:\" Memory usage    - last year trend\"";
    $cmd .= " $last";
    $cmd .= " $t2";
  }
  else {
    $rrd_lpm =~ s/:/\\:/g;

    # to use data from all HMCs (not real LPM, LPM is between servers what this does not do
    my ( $result_cmd, $CPU_free_d, $CPU_fw_d, $CPU_tot_d, $CPU_free_m, $CPU_fw_m, $CPU_tot_m, $CPU_free_y, $CPU_fw_y, $CPU_tot_y, $CPU_free, $CPU_fw, $CPU_tot ) = LPM_easy_trend( "$rrd_lpm", "curr_avail_mem", "sys_firmware_mem", "conf_sys_mem" );

    $cmd .= $result_cmd;
    $cmd .= " CDEF:freed=$CPU_free_d";
    $cmd .= " CDEF:freem=$CPU_free_m";
    $cmd .= " CDEF:freey=$CPU_free_y";
    $cmd .= " CDEF:free=$CPU_free";

    $cmd .= " CDEF:fwd=$CPU_fw_d";
    $cmd .= " CDEF:fwm=$CPU_fw_m";
    $cmd .= " CDEF:fwy=$CPU_fw_y";
    $cmd .= " CDEF:fw=$CPU_fw";

    $cmd .= " CDEF:totd=$CPU_tot_d";
    $cmd .= " CDEF:totm=$CPU_tot_m";
    $cmd .= " CDEF:toty=$CPU_tot_y";
    $cmd .= " CDEF:tot=$CPU_tot";

    $cmd .= " CDEF:freegd=freed,1024,/";
    $cmd .= " CDEF:freegm=freem,1024,/";
    $cmd .= " CDEF:freegy=freey,1024,/";
    $cmd .= " CDEF:freeg=free,1024,/";
    $cmd .= " CDEF:fwgd=fwd,1024,/";
    $cmd .= " CDEF:fwgm=fwm,1024,/";
    $cmd .= " CDEF:fwgy=fwy,1024,/";
    $cmd .= " CDEF:fwg=fw,1024,/";
    $cmd .= " CDEF:totgd=totd,1024,/";
    $cmd .= " CDEF:totgm=totm,1024,/";
    $cmd .= " CDEF:totgy=toty,1024,/";
    $cmd .= " CDEF:totg=tot,1024,/";
    $cmd .= " CDEF:usedd=totgd,freegd,-";
    $cmd .= " CDEF:usedm=totgm,freegm,-";
    $cmd .= " CDEF:usedy=totgy,freegy,-";
    $cmd .= " CDEF:used=totg,freeg,-";
    $cmd .= " CDEF:used1d=usedd,fwgd,-";
    $cmd .= " CDEF:used1m=usedm,fwgm,-";
    $cmd .= " CDEF:used1y=usedy,fwgy,-";
    $cmd .= " CDEF:used1=used,fwg,-";
    $cmd .= " CDEF:usedtotd=used1d,fwgd,+";
    $cmd .= " CDEF:usedtotm=used1m,fwgm,+";
    $cmd .= " CDEF:usedtoty=used1y,fwgy,+";
    $cmd .= " CDEF:usedtot=used1,fwg,+";
    $cmd .= " VDEF:Dd=usedtotd,LSLSLOPE";
    $cmd .= " VDEF:Hd=usedtotd,LSLINT";
    $cmd .= " CDEF:usedtottrendd=usedtotd,POP,Dd,COUNT,*,Hd,+";
    $cmd .= " VDEF:Dm=usedtotm,LSLSLOPE";
    $cmd .= " VDEF:Hm=usedtotm,LSLINT";
    $cmd .= " CDEF:usedtottrendm=usedtotm,POP,Dm,COUNT,*,Hm,+";
    $cmd .= " VDEF:Dy=usedtoty,LSLSLOPE";
    $cmd .= " VDEF:Hy=usedtoty,LSLINT";
    $cmd .= " CDEF:usedtottrendy=usedtoty,POP,Dy,COUNT,*,Hy,+";
    $cmd .= " COMMENT:\"   Average   \\n\"";
    $cmd .= " AREA:fwg#0080FF:\" Firmware memory\"";
    $cmd .= " GPRINT:fwg:AVERAGE:\" %4.2lf GB\"";
    $cmd .= " $t2";
    $cmd .= " STACK:used1#FF8080:\" Used memory    \"";
    $cmd .= " GPRINT:used1:AVERAGE:\" %4.2lf GB\"";
    $cmd .= " $t2";
    $cmd .= " STACK:freeg#00FF00:\" Free memory    \"";
    $cmd .= " GPRINT:freeg:AVERAGE:\" %4.2lf GB\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:usedtottrendd#0000FF:\" Used memory total - last 1 month trend\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:usedtottrendm#80FFFF:\" Used memory total - last 3 months trend\"";
    $cmd .= " $t2";
    $cmd .= " LINE2:usedtottrendy#FF8080:\" Used memory total - last year trend\"";
    $cmd .= " $t";
  }

  $cmd .= " HRULE:0#000000";

  $cmd =~ s/COMMENT: //g;    # a trick, there was a problem with aggregated and "COMMENT: "

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;

}

sub legend_item_format {
  my $atom    = shift;
  my $leg_len = shift;

  # add spaces to lpar name to have $leg_len chars total (for formating graph legend)
  for ( my $k = length($atom); $k < $leg_len; $k++ ) {
    $atom .= " ";
  }

  # max $leg_len chars
  $atom = substr( $atom, 0, $leg_len - 1 );
  return $atom;
}

sub graph_memaggreg {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $powlin_job  = shift;    # pid number

  #$server =~ s/--unknown$//;
  my $lpar_orig = $lpar;                                                 # for wpar use
  my $t         = "COMMENT: ";
  my $t2        = "COMMENT:\\n";
  my $step_new  = $step;
  my $last      = "COMMENT: ";
  my $head      = "COMMENT:                            Average   \\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph Memory Aggreg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();

  my $Datastore_DS_name = "";

  my $header         = "Memory aggregated : last $text";
  my $vertical_label = "--vertical-label=Memory in GBytes";
  if ( $item eq "wpar_cpu" ) {
    $header         = "CPU aggregated : last $text";
    $vertical_label = "--vertical-label=cores";
  }
  if ( $item eq "threads" ) {
    $header         = "Threads aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=Threads";
  }
  if ( $item eq "faults" ) {
    $header         = "Faults aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=Faults";
  }
  if ( $item eq "pages" ) {
    $header         = "Pages aggregated : $lpar :  last $text";
    $vertical_label = "--vertical-label=Pages";
  }
  if ( $item eq "job_cpu" ) {
    $header         = "CPU aggregated % : $lpar : last $text";
    $vertical_label = "--vertical-label=CPU %";
  }
  if ( $item eq "powlin_job" ) {
    my $pid = $powlin_job;
    $pid =~ s/\.cfg$//;

    # $header         = "server $server: JOB $pid: last $text";
    $header         = "$lpar : CPU JOB $pid: last $text";
    $vertical_label = "--vertical-label=CPU cores";
  }
  if ( $item eq "powlin_mem" ) {
    my $pid = $powlin_job;
    $pid =~ s/\.cfg$//;

    # $header         = "server $server: JOB $pid: last $text";
    $header         = "$lpar : MEM JOB $pid: last $text";
    $vertical_label = "--vertical-label=Memory MB";
  }
  if ( $item eq "waj" ) {
    $header         = "CPU aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=CPU cores";
  }
  if ( $item eq "jobs" ) {
    $header         = "JOB CPU aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=CPU cores";
  }
  if ( $item eq "jobs_mem" ) {
    $header         = "JOB Memory aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=Memory GB";
  }
  if ( $item eq "disk_io" ) {
    $header         = "IO aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=Disk IO";
  }
  if ( $item eq "disks" ) {
    $header         = "DISK IO aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=Disk IO/sec";
  }
  if ( $item eq "disk_busy" ) {
    $header         = "DISK Busy : $lpar : last $text";
    $vertical_label = "--vertical-label=Disk Busy %";
  }
  if ( $item eq "size" ) {
    $header         = "Memory aggregated : $lpar : last $text";
    $vertical_label = "--vertical-label=GBytes";
  }
  if ( $item eq "dstrag_used" ) {
    $header         = "Datastores USED : last $text";
    $vertical_label = "--vertical-label=USED Space [TB]";
  }
  if ( $item eq "dstrag_iopsr" ) {
    $header            = "Datastores IOPS read : last $text";
    $vertical_label    = "--vertical-label=IOPS read";
    $Datastore_DS_name = "Datastore_ReadAvg";
  }
  if ( $item eq "dstrag_iopsw" ) {
    $header            = "Datastores IOPS write : last $text";
    $vertical_label    = "--vertical-label=IOPS write";
    $Datastore_DS_name = "Datastore_WriteAvg";
  }
  if ( $item eq "dstrag_datar" ) {
    $header            = "Datastores DATA read : last $text";
    $vertical_label    = "--vertical-label=READ MB/sec";
    $Datastore_DS_name = "Datastore_read";
  }
  if ( $item eq "dstrag_dataw" ) {
    $header            = "Datastores DATA write : last $text";
    $vertical_label    = "--vertical-label=WRITE MB/sec";
    $Datastore_DS_name = "Datastore_write";
  }
  if ( $detail == 2 ) {
    my $lpart = ": $lpar ";
    $lpart          = "" if $server eq "as400";
    $vertical_label = "--interlaced";              # nope string
    $header         = "Memory aggregated:$text";
    $header         = "Threads agg$lpart:$text"      if ( $item eq "threads" );
    $header         = "Faults agg$lpart:$text"       if ( $item eq "faults" );
    $header         = "Pages agg$lpart:$text"        if ( $item eq "pages" );
    $header         = "CPU agg %$lpart:$text"        if ( $item eq "job_cpu" );
    $header         = "JOB$lpart:$text"              if ( $item eq "jobs" );
    $header         = "JOB CPU:$text"                if ( $item eq "jobs" && $server eq "Linux" );
    $header         = "CPU agg$lpart:$text"          if ( $item eq "waj" );
    $header         = "JOB MEM:$text"                if ( $item eq "jobs_mem" && $server eq "Linux" );
    $header         = "MEM agg$lpart:$text"          if ( $item eq "size" );
    $header         = "IO agg$lpart:$text"           if ( $item eq "disk_io" );
    $header         = "DISK IO agg$lpart:$text"      if ( $item eq "disks" );
    $header         = "DISK Busy$lpart:$text"        if ( $item eq "disk_busy" );
    $header         = "Datastores IOPS read :$text"  if ( $item eq "dstrag_iopsr" );
    $header         = "Datastores IOPS write :$text" if ( $item eq "dstrag_iopsw" );
    $header         = "Datastores DATA read :$text"  if ( $item eq "dstrag_datar" );
    $header         = "Datastores DATA write :$text" if ( $item eq "dstrag_dataw" );
    $header         = "Datastores USED :$text"       if ( $item eq "dstrag_used" );
    $header         = "CPU job: $text"               if ( $item eq "powlin_job" );
    $header         = "Memory job: $text"            if ( $item eq "powlin_mem" );
  }
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "";    # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "Memory aggregated: $start_human - $end_human";
      $header = "Threads aggregated: $start_human - $end_human"    if ( $item eq "threads" );
      $header = "Faults aggregated: $start_human - $end_human"     if ( $item eq "faults" );
      $header = "Pages aggregated: $start_human - $end_human"      if ( $item eq "pages" );
      $header = "CPU aggregated %: $start_human - $end_human"      if ( $item eq "job_cpu" );
      $header = "CPU aggregated: $start_human - $end_human"        if ( $item eq "waj" || $item eq "jobs" );
      $header = "MEM aggregated: $start_human - $end_human"        if ( $item eq "jobs_mem" );
      $header = "IO aggregated: $start_human - $end_human"         if ( $item eq "disk_io" );
      $header = "DISK IO aggregated: $start_human - $end_human"    if ( $item eq "disks" );
      $header = "DISK Busy : $start_human - $end_human"            if ( $item eq "disk_busy" );
      $header = "Datastores USED: $start_human - $end_human"       if ( $item eq "dstrag_used" );
      $header = "Datastores IOPS read: $start_human - $end_human"  if ( $item eq "dstrag_iopsr" );
      $header = "Datastores IOPS write: $start_human - $end_human" if ( $item eq "dstrag_iopsw" );
      $header = "Datastores DATA read: $start_human - $end_human"  if ( $item eq "dstrag_datar" );
      $header = "Datastores DATA write: $start_human - $end_human" if ( $item eq "dstrag_dataw" );

      if ( $detail == 10 ) {

        #$header = "$server : Memory aggregated: $start_human - $end_human";
        if ( $server eq "Solaris--unknown" && ( $item eq "jobs" || $item eq "jobs_mem" ) ) {
          $header = "$server : $lpar : $header";
        }
        else {
          $header = "$server : $header";
        }
      }
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  my @files        = ();
  my $cmd_def_jobs = "";     # holds RRDTOOL DEF directives for cputopx.mmc
  my $count_files_cputot;    # holds number of these files

  if ( $item eq "dstrag_used" ) {
    @files = <$wrkdir/vmware_*/datastore_datacenter*/*.rrs>;
  }
  elsif ( $item =~ "dstrag_" ) {
    @files = <$wrkdir/vmware_*/datastore_datacenter*/*.rrt>;
  }
  elsif ( $item eq "jobs" || $item eq "powlin_job" || $item eq "jobs_mem" || $item eq "powlin_mem" ) {
    opendir( DIR, "$wrkdir/$server/$host/$lpar_orig/JOB" ) or error( "directory does not exists : $wrkdir/$server/$host/$lpar_orig/JOB " . __FILE__ . ":" . __LINE__ ) && return 0;
    @files = grep( /\.cfg$/, readdir(DIR) );
    rewinddir(DIR);
    my @files_cpu = grep( /\.mmc$/, readdir(DIR) );
    closedir(DIR);
    $count_files_cputot = scalar @files_cpu;    # for later use
    if ( $item eq "powlin_job" || $item eq "powlin_mem" ) {
      @files = ();
      $files[0] = $powlin_job;
    }

    # print STDERR "10639 detail-graph-cgi.pl $files[0]\n";
    # prepare RRDTOOL DEF directives
    # $cmd_def_jobs
    my $i         = 0;
    my $path_file = "$wrkdir/$server/$host/$lpar_orig";
    $path_file =~ s/:/\\:/g;
    foreach my $file (@files_cpu) {

      # print STDERR "10648 detail-graph-cgi.pl $file\n";
      $cmd_def_jobs .= " DEF:pid${i}=\"$path_file/JOB/$file\":pid:AVERAGE";
      $cmd_def_jobs .= " DEF:td${i}=\"$path_file/JOB/$file\":time_diff:AVERAGE";
      $cmd_def_jobs .= " DEF:rss${i}=\"$path_file/JOB/$file\":rss:AVERAGE";
      $i++;
    }

    # print STDERR "$cmd_def_jobs\n";
  }

  elsif ( $vmware || $hyperv ) {

    # prepare list of active registered VMs on server
    # this is not OK, it should be same as lparagg for CPU pool
    # now it takes only currently active VMS, not taking VMs active before !!
    my $registered_VM_file = "$wrkdir/$server/$host/VM_hosting.vmh";

    # print STDERR "------- \$registered_VM_file $registered_VM_file\n";
    open( my $fh, "$registered_VM_file" ) or error( "can't open $registered_VM_file, server has not had any VMs: $!" . __FILE__ . ":" . __LINE__ ) && return;
    while ( my $row = <$fh> ) {
      ( my $vm, undef ) = split( ":", $row );
      $vm .= ".rrm";
      my $pos = rindex( $row, ':' );
      next if $pos < 0;                                  # some trash
                                                         # push @files, "$vm"; # these are all active and non active
      if ( substr( $row, $pos + 1, 5 ) eq "start" ) {    # keep item
        push @files, "$vm";
      }
    }
    close $fh;

    # print STDERR "-------  \@files @files\n";
  }

  #  elsif ( $item eq "dstrag_used" ) {
  #    @files = <$wrkdir/vmware_*/datastore_datacenter*/*.rrs>;
  #  }
  #  elsif ( $item =~ "dstrag_" ) {
  #    @files = <$wrkdir/vmware_*/datastore_datacenter*/*.rrt>;
  #  }
  elsif ( $item eq "wpar_mem" || $item eq "wpar_cpu" ) {
    opendir( DIR, "$wrkdir/$server/$host/$lpar_orig" ) or error( "directory does not exists : $wrkdir/$server/$host/$lpar_orig " . __FILE__ . ":" . __LINE__ ) && return 0;
    my @files_dir = readdir(DIR);
    closedir(DIR);
    my $file_name = "mem";
    $file_name = "cpu" if $item eq "wpar_cpu";
    foreach my $file (@files_dir) {
      next if $file =~ /^\.$/;
      if ( !-d "$wrkdir/$server/$host/$lpar_orig/$file" || !-f "$wrkdir/$server/$host/$lpar_orig/$file/cpu.mmm" ) {
        next;
      }

      #print STDERR "10428 detail-graph-cgi.pl found wpar dir $file\n";
      push @files, "$file/$file_name.mmm";
    }
  }

  else {
    if ( $item eq "size" || $item eq "res" || $item eq "threads" || $item eq "faults" || $item eq "pages" || $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" || $item eq "disks" || $item eq "disk_busy" ) {    # AS400
      my $Parmx = "Parm1";
      $Parmx = "Parm3" if $item eq "threads";
      $Parmx = "Parm2" if $item eq "faults";
      $Parmx = "Parm2" if $item eq "pages";

      if ( $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" ) {

        # print STDERR "8885 detail-graph-cgi.pl size $wrkdir/$server/$host/$lpar\n";
        opendir( DIR, "$wrkdir/$server/$host/$lpar$AS400/JOB" ) || error( " directory does not exists : $wrkdir/$server/$host/$lpar$AS400/JOB " . __FILE__ . ":" . __LINE__ ) && return 0;

        #opendir(DIR, "$wrkdir/$server/$host/$lpar/JOB") || error(" directory does not exists : $wrkdir/$server/$host/$lpar/job ".__FILE__.":".__LINE__) && return 0;

        my @files_unsorted = grep( /.*\.mmc$/, readdir(DIR) );
        @files = sort { lc $a cmp lc $b } @files_unsorted;

        # print STDERR "9028 detail-graph-cgi.pl \@files @files\n";
      }
      elsif ( $item eq "disks" || $item eq "disk_busy" ) {
        opendir( DIR, "$wrkdir/$server/$host/$lpar$AS400/DSK" ) || error( " directory does not exists : $wrkdir/$server/$host/$lpar$AS400/DSK " . __FILE__ . ":" . __LINE__ ) && return 0;

        my @files_unsorted = grep( /.*\.mmc$/, readdir(DIR) );
        @files = sort { lc $a cmp lc $b } @files_unsorted;

        # print STDERR "9885 detail-graph-cgi.pl \@files @files\n";
      }
      else {
        # print STDERR "8885 detail-graph-cgi.pl size $wrkdir/$server/$host/$lpar\n";
        opendir( DIR, "$wrkdir/$server/$host/$lpar$AS400" ) || error( " directory does not exists : $wrkdir/$server/$host/$lpar$AS400 " . __FILE__ . ":" . __LINE__ ) && return 0;
        my @files_unsorted = grep( /S0400[0-9][0-9].*$Parmx\.mmm$/, readdir(DIR) );    # take only S0400[0-9][0-9], leave out older files with direct names
                                                                                       #my @files_unsorted = grep(/S0400.*$Parmx\.mmm$/,readdir(DIR));
        @files = sort { lc $a cmp lc $b } @files_unsorted;

        # print STDERR "8889 detail-graph-cgi.pl \@files @files\n";
      }
    }
    else {
      opendir( DIR, "$wrkdir/$server/$host" ) || error( " directory does not exists : $wrkdir/$server/$host " . __FILE__ . ":" . __LINE__ ) && return 0;
      if ( $type_sam =~ "m" ) {
        my @files_unsorted = grep( /\.r[m|s]m$/, readdir(DIR) );

        # @files = sort { lc $a cmp lc $b } @files_unsorted;
        @files = @files_unsorted;
      }
      rewinddir(DIR);
      if ( $type_sam =~ "h" ) {
        my @files_unsorted = grep( /\.r[m|s]h$/, readdir(DIR) );

        #@files = sort { lc $a cmp lc $b } @files_unsorted;
        @files = @files_unsorted;
      }
      rewinddir(DIR);
      if ( $type_sam =~ "d" ) {
        my @files_unsorted = grep( /\.r[m|s]d$/, readdir(DIR) );

        #@files = sort { lc $a cmp lc $b } @files_unsorted;
        @files    = @files_unsorted;
        $req_time = $act_time_u - 31536000;
      }
    }
    closedir(DIR);
  }

  my $file               = "";
  my $i                  = 0;
  my $cmd                = "";
  my $j                  = 0;
  my $cfg_text           = "";
  my $subsystem_name     = "";
  my $unix_cmd           = "";
  my $type_subtype       = "";
  my $status_aj          = "";
  my $function_name_type = "";
  my $proctime_total     = "";
  my $asp_num            = "";
  my $as400_job_user     = "";

  $status_aj = "";

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  if ( scalar @files > 1000 ) {
    $no_legend = "--no-legend";
  }

  # $step_new = 300;
  # print STDERR "10138 detail-graph-cgi.pl \$step_new $step_new \$item $item\n";

  $cmd .= "$graph_cmd \\\"$name_out\\\"";
  $cmd .= " --title \\\"$header\\\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";

  #  $cmd .= " --upper-limit=0.1";
  $cmd .= " \\\"$vertical_label\\\"";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( ($vmware) && ( !( $item =~ "dstrag_" ) ) && ( !( $item eq "jobs" ) ) && ( !( $item eq "jobs_mem" ) ) ) {
    $cmd .= " COMMENT:\\\"Current granted memory in GB\\:      average\\l\\\"";
  }
  else {
    if ( $item eq "wpar_cpu" ) {
      $cmd .= " COMMENT:\\\"Current CPU load in cores\\:         average     max\\l\\\"";
    }
    elsif ( $item eq "threads" ) {
      $cmd .= " COMMENT:\\\"Current number of threads\\:         average          max\\l\\\"";
    }
    elsif ( $item eq "res" ) {
      $cmd .= " COMMENT:\\\"Current allocated memory in GB\\:    average          max\\l\\\"";
    }
    elsif ( $item eq "size" ) {
      $cmd .= " COMMENT:\\\"Current allocated memory in GB\\:    average          max          type\\l\\\"";
    }
    elsif ( $item eq "faults" ) {
      $cmd .= " COMMENT:\\\"Faults \\:                   DB      AVG    MAX   non DB  AVG    MAX\\l\\\"";
    }
    elsif ( $item eq "pages" ) {
      $cmd .= " COMMENT:\\\"Pages \\:                    DB      AVG    MAX   non DB  AVG    MAX\\l\\\"";
    }
    elsif ( $item eq "job_cpu" ) {
      $cmd .= " COMMENT:\\\"Jobname      User       Jobno     Type   AvgRun     Avg      MAX   Function      Status\\l\\\"";
    }
    elsif ( $item eq "jobs" || $item eq "powlin_job" || $item eq "jobs_mem" || $item eq "powlin_mem" ) {
      $cmd .= " COMMENT:\\\"Job PID          User               AvgRun     Avg       MAX    Command\\l\\\"";
    }
    elsif ( $item eq "waj" ) {
      $cmd .= " COMMENT:\\\"Jobname      User       Jobno     Type   AvgRun     Avg      MAX   Function      Status\\l\\\"";
    }
    elsif ( $item eq "disk_io" ) {
      $cmd .= " COMMENT:\\\"Jobname      User       Jobno     Type   AvgRun      Avg       MAX   Function      Status\\l\\\"";
    }
    elsif ( $item eq "disks" || $item eq "disk_busy" ) {
      $cmd .= " COMMENT:\\\"  Disk-serial                ASP       AvgRun       Avg       MAX\\l\\\"";
    }
    elsif ( $item eq "dstrag_used" ) {
      $cmd .= " COMMENT:\\\"  VMware alias    Datastore                             [GB]  AVG       MAX\\l\\\"";
    }
    elsif ( $item eq "dstrag_iopsr" ) {
      $cmd .= " COMMENT:\\\"  VMware alias    Datastore                             READ  AVG       MAX\\l\\\"";
    }
    elsif ( $item eq "dstrag_iopsw" ) {
      $cmd .= " COMMENT:\\\"  VMware alias    Datastore                            WRITE  AVG       MAX\\l\\\"";
    }
    elsif ( $item eq "dstrag_datar" ) {
      $cmd .= " COMMENT:\\\"  VMware alias    Datastore                           MB/sec  AVG       MAX\\l\\\"";
    }
    elsif ( $item eq "dstrag_dataw" ) {
      $cmd .= " COMMENT:\\\"  VMware alias    Datastore                           MB/sec  AVG       MAX\\l\\\"";
    }
    else {
      $cmd .= " COMMENT:\\\"Current allocated memory in GB\\:    average\\l\\\"";
    }
  }
  my $gtype = "AREA";

  my $wrkdir_managedname_host_mem;
  if ( ( ($vmware) && ( !( $item =~ "dstrag_" ) ) ) || $hyperv ) {
    $wrkdir_managedname_host_mem = "$wrkdir/$server/$host/pool.rrm";
  }
  else {
    $wrkdir_managedname_host_mem = "$wrkdir/$server/$host/mem.rr$type_sam";
  }
  $wrkdir_managedname_host_mem =~ s/:/\\:/g;

  if ( $item eq "jobs" || $item eq "powlin_job" || $item eq "jobs_mem" || $item eq "powlin_mem" ) {
    $cmd .= $cmd_def_jobs;

    # print STDERR "10870 \$cmd $cmd\n";
  }
  elsif ( ($vmware) && ( !( $item =~ "dstrag_" ) ) ) {
    $cmd .= " DEF:max=\\\"$wrkdir_managedname_host_mem\\\":Memory_Host_Size:AVERAGE";
    $cmd .= " CDEF:maxg=max,1024,/,1024,/,1024,/";
    $gtype = "AREA";
  }
  elsif ($hyperv) {
    $cmd .= " DEF:max=\\\"$wrkdir_managedname_host_mem\\\":TotalPhysMemory:AVERAGE";
    $cmd .= " CDEF:maxg=max,1024,/,1024,/,1024,/";
    $gtype = "AREA";
  }
  else {
    if ( $item ne "size" && $item ne "res" && $item ne "threads" && $item ne "faults" && $item ne "pages" && $item ne "job_cpu" && $item ne "waj" && $item ne "disk_io" && $item ne "disks" && $item ne "disk_busy" && $item !~ "dstrag_" && $item !~ "wpar_" && $item ne "jobs" && $item ne "powlin_job" && $item ne "jobs_mem" && $item ne "powlin_mem" ) {    # not for AS400 & not for Datastores TOP & not for wpar_
      $cmd .= " DEF:max=\\\"$wrkdir_managedname_host_mem\\\":conf_sys_mem:AVERAGE";
      $cmd .= " CDEF:maxg=max,1024,/";

      $cmd .= " DEF:fw=\\\"$wrkdir_managedname_host_mem\\\":sys_firmware_mem:AVERAGE";
      $cmd .= " CDEF:fwg=fw,1024,/";

      $cmd .= " $gtype:fwg#0080FF:\\\"Firmware                 \\\"";
      $cmd .= " GPRINT:fwg:AVERAGE:\\\"     %6.2lf \\l\\\"";
      $cmd .= " PRINT:fwg:AVERAGE:\"%6.2lf $delimiter $item $delimiter Firmware $delimiter #0080FF\"";
      $cmd .= " COMMENT:\\n";
      $gtype = "STACK";
    }
  }
  my $found_at_least_one = 0;
  my $found              = -1;
  $found = 0 if $item =~ /wpar_/;    # first color is left out for total line
  my $lpar_as400 = $lpar;

  my $form_dec    = "%6.2lf";
  my $last_update = 0;
  my $l           = 0;               # used for jobs

  my $vms_dir = "vmware_VMs";
  $vms_dir = "hyperv_VMs" if $hyperv;

  my $datastore_uuid = "";

  foreach $file (@files) {
    $found++;
    chomp($file);
    $found_at_least_one = 1;
    if ( $item eq "size" || $item eq "threads" ) {
      $found = substr( $file, 4, 3 ) - 1;    # S040004Parm1.mmm see 004 as color number
    }

    #if ($item eq "faults" || $item eq "pages") {
    #  $found = (substr ($file,4,3) - 1) * 2;
    #}
    # print STDERR "10611 detail-graph-cgi.pl \$file $file \$found $found\n";

    my $rrd_upd_time;

    # avoid old lpars which do not exist in the period
    if ( $item eq "size" || $item eq "res" || $item eq "threads" || $item eq "faults" || $item eq "pages" || $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" || $item eq "disks" || $item eq "disk_busy" ) {    # AS400
                                                                                                                                                                                                                           # print STDERR "9030 detail-graph-cgi.pl $wrkdir/$server/$host/$lpar$AS400/$file\n";
      if ( $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" || $item eq "disks" || $item eq "disk_busy" ) {
        my $dir_name = "JOB";
        $dir_name     = "DSK" if $item eq "disks" || $item eq "disk_busy";
        $rrd_upd_time = ( stat("$wrkdir/$server/$host/$lpar_as400$AS400/$dir_name/$file") )[9];

        #$rrd_upd_time = (stat("$wrkdir/$server/$host/$lpar_as400/$dir_name/$file"))[9];
        next if ( $rrd_upd_time < $req_time );

        # test if -nan
        # "DEF:cur=$wrkdir/$server/$host/$lpar_as400/$dir_name/$file:par3:AVERAGE"
        my $cmdix = 'RRDp::cmd qq(graph "$name_out"
            "--title" "$header"
            "--start" "$start_time"
            "--end" "$end_time"
            "DEF:cur=$wrkdir/$server/$host/$lpar_as400$AS400/$dir_name/$file:par3:AVERAGE"
            "CDEF:curg=cur,1,/"
            "PRINT:curg:AVERAGE: ""$form_dec"
          )';
        eval $cmdix;
        if ($@) {
          error( "Graph error in eval cmd : !$@! " . __FILE__ . ":" . __LINE__ );
        }
        else {
          my $answ = RRDp::read;
          if ( $$answ =~ "ERROR" ) {
            error( "$host:$server Graph rrdtool error : $$answ " . __FILE__ . ":" . __LINE__ );
            next;
          }
          chomp($$answ);

          # print STDERR "10101 detail-graph-cgi.pl \$answ ,$answ, ,$$answ,\n";
          next if $$answ =~ /[Nn]a[Nn]/;

          # prepare text values
          my $file_cfg = "$wrkdir/$server/$host/$lpar_as400$AS400/$dir_name/$file";

          #my $file_cfg = "$wrkdir/$server/$host/$lpar_as400/$dir_name/$file";
          $file_cfg =~ s/mmc$/cfg/;
          $cfg_text = "";
          if ( -f "$file_cfg" ) {
            open( FILE, "$file_cfg" ) or error( "cant open $file_cfg" . __FILE__ . ":" . __LINE__ ) && next;
            $cfg_text = <FILE>;
            close(FILE);
            if ( $item eq "disks" || $item eq "disk_busy" ) {
              $asp_num = $cfg_text;
              chomp $asp_num;
              $asp_num = "0" . $asp_num if $asp_num < 100;
              $asp_num = "0" . $asp_num if $asp_num < 10;

              # fake pool name
              if ( $asp_num < 33 && $asp_num != 1 ) {
                $asp_num = "ASP" . $asp_num;
              }
              elsif ( $asp_num == 1 ) {
                $asp_num = "*SYSTEM";
              }
              elsif ( $asp_num > 32 ) {

                # take ASP name from ASP config file
                my $asp_cfg = "$wrkdir/$server/$host/$lpar_as400$AS400/ASP/ASP" . $asp_num . "Parm.cfg";

                # print STDERR "10313 \$asp_cfg $asp_cfg\n";
                if ( -f "$asp_cfg" ) {
                  open( FILE, "$asp_cfg" ) or error( "cant open $file_cfg" . __FILE__ . ":" . __LINE__ ) && next;
                  my $cfg_text = <FILE>;
                  close(FILE);
                  ( my $subsystem_name, undef ) = split( /,/, $cfg_text );

                  # print STDERR "\$cfg_text $cfg_text \$subsystem_name $subsystem_name\n";
                  $subsystem_name =~ s/Res name: //;
                  $asp_num = $subsystem_name;
                }
              }
            }
            else {
              #  my $job_config_pattern = "subsystem_name|user_name|type_subtype|status_aj|function_name_type|proctime_total";
              # ( $subsystem_name, undef, $type_subtype, $status_aj, $function_name_type, $proctime_total ) = split( /\|/, $cfg_text );
              ( $subsystem_name, $as400_job_user, $type_subtype, $status_aj, $function_name_type, $proctime_total ) = split( /\|/, $cfg_text );

              # print STDERR "20252 \$as400_job_user $as400_job_user \$type_subtype $type_subtype\n";
              $proctime_total =~ s/\./\\:/g;
              $subsystem_name     = sprintf( "%-15s", $subsystem_name );
              $subsystem_name     = substr( $subsystem_name, 0, 15 );
              $type_subtype       = sprintf( "%-3s", $type_subtype );
              $type_subtype       = substr( $type_subtype, 0, 3 );
              $status_aj          = sprintf( "%-4s", $status_aj );
              $status_aj          = substr( $status_aj, 0, 4 );
              $function_name_type = sprintf( "%-14s", $function_name_type );
              $function_name_type = substr( $function_name_type, 0, 14 );

              # print STDERR "9241 $subsystem_name, $type_subtype, $status_aj, $function_name_type, $proctime_total\n";
            }
          }
        }
      }
      else {
        $rrd_upd_time = ( stat("$wrkdir/$server/$host/$lpar_as400$AS400/$file") )[9];

        #$rrd_upd_time = (stat("$wrkdir/$server/$host/$lpar_as400/$file"))[9];
        next if ( $rrd_upd_time < $req_time );
      }
    }
    elsif ( $item =~ "dstrag_" ) {

      # print STDERR "10439 detail-graph-cgi.pl \$file $file\n";
      next if -s $file < 1;
      $rrd_upd_time = ( stat("$file") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
    }
    elsif ( $item =~ "wpar_" ) {

      # print STDERR "10736 detail-graph-cgi.pl \$file $wrkdir/$server/$host/$lpar_orig/$file\n";
      $rrd_upd_time = ( stat("$wrkdir/$server/$host/$lpar_orig/$file") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
    }
    elsif ( $item eq "jobs" || $item eq "powlin_job" || $item eq "jobs_mem" || $item eq "powlin_mem" ) {
      next if !-f "$wrkdir/$server/$host/$lpar_orig/JOB/$file";
      $rrd_upd_time = ( stat("$wrkdir/$server/$host/$lpar_orig/JOB/$file") )[9];
      next if $rrd_upd_time < $req_time;
      if ( $start_time !~ /now/ ) {    # only for zoom
        next if $rrd_upd_time < $start_time;
      }

      # prepare data from cfg for legend
      open( FILE, "$wrkdir/$server/$host/$lpar_orig/JOB/$file" ) or error( "cant open $wrkdir/$server/$host/$lpar_orig/JOB/$file" . __FILE__ . ":" . __LINE__ ) && next;
      $cfg_text = <FILE>;
      close(FILE);

      # my $job_cfg = "zabbix:/usr/sbin/zabbix_agentd listener #1 [waiting for connection]:21";
      ( $type_subtype, $subsystem_name, $proctime_total ) = split( /:/, $cfg_text );

      # print STDERR "11972 \$type_subtype  $type_subtype \$subsystem_name $subsystem_name \$proctime_total $proctime_total\n";
      $unix_cmd = $subsystem_name;
      if ( $detail == 1 ) {    # detail can have longer legend
        $subsystem_name = substr $subsystem_name, 0, 90;
      }
      else {
        $subsystem_name = substr $subsystem_name, 0, 50;
      }
    }
    elsif ( $vmware || $hyperv ) {

      # for vmware then in future better test will be created, now all active registered VMs have been taken, some can be poweredoff or suspended
      $rrd_upd_time = ( stat("$wrkdir/$vms_dir/$file") )[9];

      # $found++;
      if ( !defined $rrd_upd_time || $rrd_upd_time < $req_time ) {
        next;
      }
    }
    else {
      $rrd_upd_time = ( stat("$wrkdir/$server/$host/$file") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
    }
    if ( $rrd_upd_time > $last_update ) {
      $last_update = $rrd_upd_time;
    }

    $lpar = $file;
    $lpar =~ s/.rmh$//;
    $lpar =~ s/.rmm$//;
    $lpar =~ s/.rmd$//;
    $lpar =~ s/.rsm$//;
    $lpar =~ s/.rsh$//;
    $lpar =~ s/.rsd$//;
    $lpar =~ s/.rrm$//;    # for vmware
    $lpar =~ s/.mmm$//;    # for AS400 & wpar aggreg
    $lpar =~ s/.mmc$//;    # for AS400
    $lpar =~ s/.rrs$//;    # for datastores
    $lpar =~ s/.rrt$//;    # for datastores

    my $lpar_space_proc = human_vmware_name( $lpar, "", $server );

    my $leg_len = 25;

    my $vmware_alias    = "";
    my $datastore_name  = "";
    my $datacenter_name = "";

    if ( $item eq "size" || $item eq "res" || $item eq "threads" || $item eq "faults" || $item eq "pages" ) {    # AS400
      $lpar_space_proc =~ s/S0400//;
      $lpar_space_proc =~ s/Parm..mmm//;
      $lpar_space_proc =~ s/Parm.//;

      # cfg info about pools in file e.g. data/server/hmc/lpar--AS400--/S040005Parm<3>.mmm
      # print STDERR "9562 detail-graph-cgi.pl $wrkdir/$server/$host/$lpar_as400/$file\n";
      my $file_cfg = "$wrkdir/$server/$host/$lpar_as400$AS400/$file";
      $file_cfg =~ s/mmm$/cfg/;
      $file_cfg =~ s/Parm./Parm/;
      my $cfg_text = "";
      if ( -f "$file_cfg" ) {
        open( FILE, "$file_cfg" ) or error( "cant open $file_cfg" . __FILE__ . ":" . __LINE__ ) && next;
        $cfg_text = <FILE>;
        close(FILE);
        $lpar_space_proc .= " " . $cfg_text;
      }
    }
    elsif ( $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" || $item =~ /wpar_/ ) {
      $lpar_space_proc =~ s/\.mmm$//;
    }
    elsif ( $item =~ "dstrag_" ) {

      # $lpar_space_proc = $file = '/home/lpar2rrd/lpar2rrd/data/vmware_7f812c15-81a6-4dfe-85e3-6c9e973985f7/datastore_datacenter-2/5e336b5d-d04e4379'
      # find datastore name and vCenter alias and datacenter name
      # print STDERR "10492 detail-graph-cgi.pl \$file $file \$lpar $lpar \$lpar_space_proc $lpar_space_proc\n";
      my $file_name = basename($file);
      $datastore_uuid = $file_name;
      $datastore_uuid =~ s/\.rrs//;
      $datastore_uuid =~ s/\.rrt//;
      my $datastore_path = $file;
      $datastore_path =~ s/$file_name//;

      # print STDERR "10500 detail-graph-cgi.pl \$file $file \$datastore_uuid $datastore_uuid\n";

      my @dc_name = <$datastore_path*.dcname>;

      #print STDERR "10642 detail-graph-cgi.pl \@dc_name @dc_name ,$dc_name[0],\n";
      if ( defined $dc_name[0] && $dc_name[0] ne "" ) {
        $datacenter_name = basename( $dc_name[0] );
        $datacenter_name =~ s/\.dcname//;
      }

      $datastore_name = $datastore_uuid;
      my @names = <$datastore_path*.$datastore_uuid>;
      if ( @names > 0 && $names[0] ne "" ) {
        $datastore_name = basename( $names[0] );

        # remove extension
        $datastore_name =~ s/\.[^.]+$//;
        $datastore_name =~ s/:/\\:/g;
      }

      # print STDERR "10509 detail-graph-cgi.pl \$datastore_name $datastore_name\n";

      # vmware alias name
      $vmware_alias = "no VMware alias";
      my $alias_file = $datastore_path;
      $alias_file =~ s/[^\/]*\/$//;

      # print STDERR "10515 detail-graph-cgi.pl \$alias_file $alias_file\n";
      $alias_file .= "vmware_alias_name";
      if ( -f $alias_file && open( FH, "< $alias_file" ) ) {
        my $name = <FH>;
        close FH;
        chomp $name;
        ( undef, $name ) = split( /\|/, $name );
        $vmware_alias = $name if $name ne "";
      }

      #print STDERR "10524 detail-graph-cgi.pl \$vmware_alias $vmware_alias\n";
      $lpar_space_proc = "$vmware_alias $datastore_name";
      $leg_len         = 50;
    }
    my $lpar_space = $lpar_space_proc;

    $lpar_space =~ s/\&\&1/\//g;

    $leg_len = 29 if ( $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" );

    $lpar_space = legend_item_format( $lpar_space, $leg_len );

    # Exclude pools and memory
    if ( ( ( "$lpar" eq "pool" ) && ( length($lpar) == 4 ) ) || ( ( "$lpar" eq "mem" ) && ( length($lpar) == 3 ) ) || ( $lpar =~ "SharedPool[0-9]" ) || ( $lpar =~ "SharedPool[1-9][0-9]" ) ) {
      next;
    }

    if ( $item eq "size" || $item eq "res" || $item eq "threads" || $item eq "faults" || $item eq "pages" ) {
      print STDERR "$wrkdir/$server/$host/$lpar_as400$AS400/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3 );
    }
    elsif ( $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" ) {
      print STDERR "$wrkdir/$server/$host/$lpar_as400$AS400/JOB/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3 );
    }
    elsif ( $item eq "disks" || $item eq "disk_busy" ) {
      print STDERR "10245 $wrkdir/$server/$host/$lpar_as400$AS400/DSK/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3 );
    }
    else {
      print STDERR "$wrkdir/$server/$host/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3 );
    }

    # to keep same count of characters
    $lpar_space =~ s/\\:/:/g;
    $lpar_space =~ s/\n//g;
    $lpar_space = sprintf( "%-$leg_len" . "s", $lpar_space );
    $lpar_space      =~ s/:/\\:/g;
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;    # anti '%

    my $wrkdir_managedname_host_file = "$wrkdir/$server/$host/$file";
    if ( $item =~ /^wpar_/ ) {
      $wrkdir_managedname_host_mem = "$wrkdir/$server/$host/$lpar_orig/$file";

      # print STDERR "10879 $wrkdir/$server/$host/$lpar_orig/$file\n";
    }

    $wrkdir_managedname_host_file =~ s/:/\\:/g;
    my $wrkdir_managedname_host_file_legend = $wrkdir_managedname_host_file;
    $wrkdir_managedname_host_file_legend =~ s/%/%%/g;

    if ( $item eq "size" || $item eq "res" || $item eq "threads" || $item eq "faults" || $item eq "pages" ) {
      $wrkdir_managedname_host_file = "$wrkdir/$server/$host/$lpar_as400$AS400/$file";

      #$wrkdir_managedname_host_file = "$wrkdir/$server/$host/$lpar_as400/$file";
      $wrkdir_managedname_host_file =~ s/:/\\:/g;
      $wrkdir_managedname_host_file_legend = "";    # to be not clickable
    }
    if ( $item eq "job_cpu" || $item eq "waj" || $item eq "disk_io" ) {
      $wrkdir_managedname_host_file = "$wrkdir/$server/$host/$lpar_as400$AS400/JOB/$file";

      #$wrkdir_managedname_host_file = "$wrkdir/$server/$host/$lpar_as400/JOB/$file";
      $wrkdir_managedname_host_file =~ s/:/\\:/g;
      $wrkdir_managedname_host_file_legend = "";    # to be not clickable
    }
    if ( $item eq "disks" || $item eq "disk_busy" ) {
      $wrkdir_managedname_host_file = "$wrkdir/$server/$host/$lpar_as400$AS400/DSK/$file";

      #$wrkdir_managedname_host_file = "$wrkdir/$server/$host/$lpar_as400/DSK/$file";
      $wrkdir_managedname_host_file =~ s/:/\\:/g;
      $wrkdir_managedname_host_file_legend = "";    # to be not clickable
    }
    if ( $item =~ "dstrag_" ) {
      $wrkdir_managedname_host_file = "$file";

      # print STDERR "10741 detail-graph-cgi.pl \$file $file\n";
      $wrkdir_managedname_host_file =~ s/:/\\:/g;

      # $wrkdir_managedname_host_file_legend = ""; # to be not clickable
    }
    if ( $item =~ "wpar_" ) {
      $wrkdir_managedname_host_file = "$wrkdir/$server/$host/$lpar_orig/$file";

      # print STDERR "10741 detail-graph-cgi.pl \$file $file\n";
      $wrkdir_managedname_host_file =~ s/:/\\:/g;

      # $wrkdir_managedname_host_file_legend = ""; # to be not clickable
    }

    if ( ( ($vmware) && ( !( $item =~ "dstrag_" ) ) ) || $hyperv ) {

      # new system
      $wrkdir_managedname_host_file = "$wrkdir/$vms_dir/$file";
      $wrkdir_managedname_host_file =~ s/:/\\:/g;
    }

    # bulid RRDTool cmd
    my $mem_item = "Memory_granted";    # for vmware
    $mem_item = "TotalPhysMemory" if $hyperv;
    my $gb_mem = "1024,/,1024,/";
    $gb_mem = "1024,/" if $hyperv;
    if ( $item eq "size" ) {
      $form_dec = "%6.1lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par5:AVERAGE";
      $cmd .= " DEF:type${i}=\\\"$wrkdir_managedname_host_file\\\":par3:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},1024,/,1024,/";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:type${i}:LAST:\\\"   %6.0lf  (0 - *FIXED, 1 - *SAME, 2 - *CALC)  \\l\\\"";
      my $item_spec = "memaggreg_size";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_proc\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter\"";
      $cmd .= " PRINT:type${i}:LAST:\"$form_dec $delimiter\"";
    }
    elsif ( $item eq "res" ) {
      $form_dec = "%6.1lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par6:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},1024,/,1024,/";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"     $form_dec \\l\\\"";
      my $item_spec = "memaggreg_res";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_proc\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter\"";
    }
    elsif ( $item eq "threads" ) {
      $form_dec = "%6.0lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par6:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},1,/";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"     $form_dec \\l\\\"";
      my $item_spec = "memaggreg_threads";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_proc\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter\"";
    }
    elsif ( $item eq "faults" ) {
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par4:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},1,/";
      $cmd .= " DEF:cus${i}=\\\"$wrkdir_managedname_host_file\\\":par7:AVERAGE";
      $cmd .= " COMMENT:\\\"$lpar_space\\\"";
      my $color_r  = $found;
      my $form_dec = "%5.0lf";
      $cmd .= " $gtype:cur${i}$color[$color_r]:\\\" \\\"";
      $cmd .= " GPRINT:cur${i}:AVERAGE:\\\"%5.0lf\\\"";
      $cmd .= " GPRINT:cur${i}:MAX:\\\"%5.0lf\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_r]\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter\"";
      $color_r = ( $found + 27 ) % ( $color_max + 1 );
      $cmd .= " STACK:cus${i}$color[$color_r]:\\\" \\\"";
      $cmd .= " GPRINT:cus${i}:AVERAGE:\\\"%5.0lf\\\"";
      $cmd .= " GPRINT:cus${i}:MAX:\\\"%5.0lf\\l\\\"";
      $cmd .= " PRINT:cus${i}:AVERAGE:\"$form_dec $delimiter $color[$color_r]\"";
      $cmd .= " PRINT:cus${i}:MAX:\"$form_dec $delimiter \"";
    }
    elsif ( $item eq "pages" ) {
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par5:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},1,/";
      $cmd .= " DEF:cus${i}=\\\"$wrkdir_managedname_host_file\\\":par6:AVERAGE";
      $cmd .= " COMMENT:\\\"$lpar_space\\\"";
      my $color_r  = $found;
      my $form_dec = "%5.0lf";
      $cmd .= " $gtype:cur${i}$color[$color_r]:\\\" \\\"";
      $cmd .= " GPRINT:cur${i}:AVERAGE:\\\"%5.0lf\\\"";
      $cmd .= " GPRINT:cur${i}:MAX:\\\"%5.0lf\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_r]\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter\"";
      $color_r = ( $found + 27 ) % ( $color_max + 1 );

      #$color_r = ++$found % ($color_max +1);
      $cmd .= " STACK:cus${i}$color[$color_r]:\\\" \\\"";
      $cmd .= " GPRINT:cus${i}:AVERAGE:\\\"%5.0lf\\\"";
      $cmd .= " GPRINT:cus${i}:MAX:\\\"%5.0lf\\l\\\"";
      $cmd .= " PRINT:cus${i}:AVERAGE:\"$form_dec $delimiter $color[$color_r]\"";
      $cmd .= " PRINT:cus${i}:MAX:\"$form_dec $delimiter \"";
    }
    elsif ( $item eq "job_cpu" ) {    #AS400
      $form_dec = "%6.1lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par3:AVERAGE";
      $cmd .= " CDEF:curgt${i}=cur${i},1,/";
      $cmd .= " CDEF:curg${i}=cur${i},UN,0,cur${i},IF,1,/";                        #avg across entire season - d,w

      #      my $lpar_space_short = $lpar_space;
      my $lpar_space_short = $lpar_space;                                          #e.g.  `QDBSRV01   QSYS       001465` but the user can be different e.g. SYS, 1st & 2nd atom has (10+1) chars, last 6
      $as400_job_user   = legend_item_format( $as400_job_user, 11 );
      $lpar_space_short = substr( $lpar_space_short, 0, 10 ) . $as400_job_user . substr( $lpar_space_short, 22 );

      # print STDERR "20614 \$as400_job_user $as400_job_user \$lpar_space_short $lpar_space_short\n";

      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space_short $type_subtype\\\"";
      $cmd .= " GPRINT:curgt${i}:AVERAGE:\\\" $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\" $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\" $form_dec $function_name_type $status_aj \\l\\\"";
      my $item_spec = "memaggreg_cpu";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_short\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $type_subtype $delimiter $function_name_type $delimiter $status_aj $delimiter $file\"";
      $cmd .= " PRINT:curgt${i}:AVERAGE:\"$form_dec $delimiter $delimiter\"";
    }
    elsif ( $item eq "jobs" || $item eq "powlin_job" || $item eq "jobs_mem" || $item eq "powlin_mem" ) {    # Power & Linux
      $form_dec = "%6.2lf";
      my $pid = $file;
      $pid =~ s/\.cfg$//;
      my $cmd_tmp = "";

      for ( my $k = 0; $k < $count_files_cputot; $k++ ) {
        if ( $k == 0 ) {
          if ( $item eq "jobs_mem" || $item eq "powlin_mem" ) {
            $cmd_tmp .= " CDEF:curgx${k}v${i}=pid0,$pid,EQ,rss0,UNKN,IF";
          }
          else {
            $cmd_tmp .= " CDEF:curgx${k}v${i}=pid0,$pid,EQ,td0,UNKN,IF";
          }
        }
        else {
          $l = $k - 1;
          if ( $item eq "jobs_mem" || $item eq "powlin_mem" ) {
            $cmd_tmp .= " CDEF:curgx${k}v${i}=pid${k},$pid,EQ,rss${k},curgx${l}v${i},IF";
          }
          else {
            $cmd_tmp .= " CDEF:curgx${k}v${i}=pid${k},$pid,EQ,td${k},curgx${l}v${i},IF";
          }
        }
      }
      $l++;
      $l = 0 if $l == 1;    # special case - only one file
      if ( $item eq "jobs_mem" || $item eq "powlin_mem" ) {
        $cmd_tmp .= " CDEF:curgt${l}${i}=curgx${l}v${i},1024,/,1024,/";    # to GiB
      }
      else {
        $cmd_tmp .= " CDEF:curgt${l}${i}=curgx${l}v${i},1800,/";
      }

      # filter files having -nan AVERAGE-RUN
      my $cmdix = "$graph_cmd \\\"$name_out\\\"";
      $cmdix .= " --title \\\"$header\\\"";
      $cmdix .= " --start $start_time";
      $cmdix .= " --end $end_time";
      $cmdix .= $cmd_def_jobs;
      $cmdix .= $cmd_tmp;
      $cmdix .= " PRINT:curgt${l}${i}:AVERAGE:\\\"$form_dec\\\"";

      # print STDERR "11645 detail-graph-cgi.pl \$cmdix $cmdix\n";

      eval { RRDp::cmd qq($cmdix) };
      if ($@) {
        error( "Graph error in eval cmd : !$@! " . __FILE__ . ":" . __LINE__ );
      }
      else {
        my $answ = RRDp::read;
        if ( $$answ =~ "ERROR" ) {
          error( "$host:$server Graph rrdtool error : $$answ " . __FILE__ . ":" . __LINE__ );
          next;
        }
        chomp($$answ);

        # print STDERR "11498 detail-graph-cgi.pl \$answ ,$answ, ,$$answ,\n";
        next if $$answ =~ /[Nn]a[Nn]/;
      }

      $cmd .= $cmd_tmp;

      # trick to simulate rrd file heartbeat of two steps
      $cmd .= " CDEF:curg_temp${l}${i}=curgt${l}${i},UN,0,curgt${l}${i},IF";    #avg across entire season - d,w";

      # if (prev3 >0 && prev2=0 && prev1=0 && actual_value >0) then prev3 else prev2; create act. value on place prev2 that is why the shift of two steps
      $cmd .= " CDEF:prev1a${l}${i}=PREV(curg_temp${l}${i})";
      $cmd .= " CDEF:prev2a${l}${i}=PREV(prev1a${l}${i})";
      $cmd .= " CDEF:prev3a${l}${i}=PREV(prev2a${l}${i})";
      $cmd .= " CDEF:curg_a${l}${i}=prev3a${l}${i},0,GT,prev2a${l}${i},0,EQ,prev1a${l}${i},0,EQ,curg_temp${l}${i},0,GT,+,+,+,4,EQ,prev3a${l}${i},prev2a${l}${i},IF";
      $cmd .= " SHIFT:curg_a${l}${i}:-3600";

      # if (prev2 > 0 && prev1 = 0 && actual_value > 0) then prev2 else prev1; create act. value on place prev1 that is why the shift of one step
      $cmd .= " CDEF:prev1b${l}${i}=PREV(curg_a${l}${i})";
      $cmd .= " CDEF:prev2b${l}${i}=PREV(prev1b${l}${i})";
      $cmd .= " CDEF:curg${l}${i}=prev2b${l}${i},0,GT,prev1b${l}${i},0,EQ,curg_a${l}${i},0,GT,+,+,3,EQ,prev2b${l}${i},prev1b${l}${i},IF";    # comment for orig graph
      $cmd .= " SHIFT:curg${l}${i}:-1800";                                                                                                   # comment for orig graph

      # prepare latest three values from original  - only for zoom times, not for basic day and week graphs
      # no this gives no good graphs
      #if ( isdigit($start_time) > 0 && isdigit($end_time) > 0 ) {
      #  my $step_count = ($end_time - $start_time -300 ) / 1800 - 1;
      #  $cmd .= " CDEF:curg_three${l}${i}=COUNT,$step_count,GT,curg_temp${l}${i},0,IF";
      #}

      # if you want to see original graph without heartbeat
      # $cmd .= " CDEF:curg${l}${i}=curgt${l}${i},UN,0,curgt${l}${i},IF";    #avg across entire season - d,w";

      my $lpar_space_short = $file;
      $lpar_space_short =~ s/\.cfg$//;
      $lpar_space_short = sprintf( "%-14s", $lpar_space_short );
      $type_subtype     = sprintf( "%-14s", $type_subtype );

      if ( $item eq "powlin_job" || $item eq "powlin_mem" ) {    # Power & Linux
        $gtype = "LINE";
      }

      #$cmd .= " $gtype:curg_three${l}${i}$color[$found % ($color_max +1)]";
      $type_subtype =~ s/%/%%/;
      $type_subtype =~ s/"//g;
      $cmd .= " $gtype:curg${l}${i}$color[$found % ($color_max +1)]:\\\"$lpar_space_short $type_subtype\\\"";

      #if ( isdigit($start_time) > 0 && isdigit($end_time) > 0 ) {
      #  $cmd .= " $gtype:curg_three${l}${i}$color[$found % ($color_max +1)]";
      #}
      $cmd .= " GPRINT:curgt${l}${i}:AVERAGE:\\\" $form_dec \\\"";
      $cmd .= " GPRINT:curg${l}${i}:AVERAGE:\\\" $form_dec \\\"";
      $subsystem_name =~ s/%/%%/;
      $subsystem_name =~ s/"//g;
      $cmd .= " GPRINT:curg${l}${i}:MAX:\\\" $form_dec $subsystem_name\\l\\\"";
      my $item_spec = "memaggreg_jobcpu";
      $cmd .= " PRINT:curg${l}${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_short\"";

      # $cmd .= " PRINT:curg${l}${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $type_subtype $delimiter $subsystem_name $delimiter $file\"";
      $cmd .= " PRINT:curg${l}${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $type_subtype $delimiter $file\"";
      $file =~ s/\.cfg$//;
      $unix_commands{$file} = $unix_cmd;
      $cmd .= " PRINT:curgt${l}${i}:AVERAGE:\"$form_dec $delimiter\"";
      $i++;

      # print STDERR "11559 \$cmd $cmd\n";
    }
    elsif ( $item eq "disk_io" ) {
      $form_dec = "%7.0lf";
      $form_dec = "%7.0lf" if $detail == 1;
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par7:AVERAGE";
      $cmd .= " CDEF:curgt${i}=cur${i},1,/";
      $cmd .= " CDEF:curg${i}=cur${i},UN,0,cur${i},IF,1,/";                        #avg across entire season - d,w
      my $lpar_space_short = $lpar_space;
      $as400_job_user   = legend_item_format( $as400_job_user, 11 );
      $lpar_space_short = substr( $lpar_space_short, 0, 10 ) . $as400_job_user . substr( $lpar_space_short, 22 );

      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space_short $type_subtype\\\"";
      $cmd .= " GPRINT:curgt${i}:AVERAGE:\\\" $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\" $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\" $form_dec $function_name_type $status_aj \\l\\\"";
      my $item_spec = "memaggreg_disk";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_short\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $type_subtype $delimiter $function_name_type $delimiter $status_aj $delimiter $file\"";
      $cmd .= " PRINT:curgt${i}:AVERAGE:\"$form_dec $delimiter $delimiter\"";
    }
    elsif ( $item eq "waj" ) {
      $form_dec = "%5.2lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par8:AVERAGE";
      $cmd .= " CDEF:curgt${i}=cur${i},1000,/";
      $cmd .= " CDEF:curg${i}=cur${i},UN,0,cur${i},IF,1000,/";                     #avg across entire season - d,w
      my $lpar_space_short = $lpar_space;
      $as400_job_user   = legend_item_format( $as400_job_user, 11 );
      $lpar_space_short = substr( $lpar_space_short, 0, 10 ) . $as400_job_user . substr( $lpar_space_short, 22 );

      # print STDERR "\$lpar_space $lpar_space\n";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space_short $type_subtype\\\"";
      $cmd .= " GPRINT:curgt${i}:AVERAGE:\\\" $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\" $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\" $form_dec $function_name_type $status_aj \\l\\\"";
      my $item_spec = "memaggreg_waj";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_short\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $type_subtype $delimiter $function_name_type $delimiter $status_aj $delimiter $file\"";
      $cmd .= " PRINT:curgt${i}:AVERAGE:\"$form_dec $delimiter $delimiter\"";
    }
    elsif ( $item eq "disks" || $item eq "disk_busy" ) {
      $form_dec = "%5.1lf";
      $form_dec = "%6.1lf" if $detail == 1;
      my $par_x = "par4";                                                            # for disk RQ
      $par_x = "par3" if $item eq "disk_busy";                                       # for disk busy
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":$par_x:AVERAGE";
      $cmd .= " CDEF:curgt${i}=cur${i},1,/";
      $cmd .= " CDEF:curg${i}=cur${i},UN,0,cur${i},IF,1,/";                          #avg across entire season - d,w
      my $lpar_space_short = $lpar_space;

      if ( $item eq "disk_busy" ) {
        $gtype = "LINE";
      }
      if ( $item eq "disks" ) {
        $form_dec = "%6.0lf";
        $form_dec = "%6.0lf" if $detail == 1;
      }
      $asp_num = legend_item_format( $asp_num, 10 );

      # print STDERR "\$form_dec $form_dec \$asp_num ,$asp_num,\n";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space_short $asp_num\\\"";
      $cmd .= " GPRINT:curgt${i}:AVERAGE:\\\"$form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"$form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"$form_dec \\l\\\"";
      my $item_spec = "memaggreg_rq_disks";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item_spec $delimiter $lpar_space_short $asp_num\"";

      #$cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $file\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter N $delimiter N $delimiter N $delimiter $file\"";
      $cmd .= " PRINT:curgt${i}:AVERAGE:\"$form_dec $delimiter $delimiter\"";
    }
    elsif ( $item eq "dstrag_used" ) {

      # print STDERR "10888 detail-graph-cgi.pl \$wrkdir_managedname_host_file $wrkdir_managedname_host_file\n";
      $form_dec = "%6.0lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":Disk_used:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},1024,/,1024,/";
      $cmd .= " CDEF:curgt${i}=cur${i},1024,/,1024,/,1024,/";
      $cmd .= " $gtype:curgt${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"$form_dec \\l\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $vmware_alias $delimiter $datastore_name $delimiter $color[$found % ($color_max +1)]\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $datacenter_name $delimiter $datastore_uuid\"";
    }
    elsif ( $item =~ "dstrag_iops" ) {    # iopsr & iopsw
                                          # print STDERR "10899 detail-graph-cgi.pl \$wrkdir_managedname_host_file $wrkdir_managedname_host_file\n";
      $form_dec = "%6.0lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":$Datastore_DS_name:AVERAGE";                                                                            # Datastore_ReadAvg Datastore_WriteAvg
      $cmd .= " CDEF:curg${i}=cur${i},1,/";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"$form_dec \\l\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $vmware_alias $delimiter $datastore_name $delimiter $color[$found % ($color_max +1)]\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $datacenter_name $delimiter $datastore_uuid\"";
    }
    elsif ( $item =~ "dstrag_data" ) {    # datar & dataw
                                          # print STDERR "10930 detail-graph-cgi.pl \$wrkdir_managedname_host_file $wrkdir_managedname_host_file\n";
      $form_dec = "%6.2lf";
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":$Datastore_DS_name:AVERAGE";                                                                            # Datastore_ReadAvg Datastore_WriteAvg
      $cmd .= " CDEF:curg${i}=cur${i},1000,/";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"$form_dec \\l\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $vmware_alias $delimiter $datastore_name $delimiter $color[$found % ($color_max +1)]\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $datacenter_name $delimiter $datastore_uuid\"";
    }
    elsif ( $item =~ "wpar_mem" ) {

      # print STDERR "11112 detail-graph-cgi.pl \$wrkdir_managedname_host_file $wrkdir_managedname_host_file\n";
      $form_dec = "%6.2lf";
      my $rrd = $wrkdir_managedname_host_file;
      $cmd .= " DEF:used${i}=\"$rrd\":nuse:AVERAGE";
      $cmd .= " DEF:in_use_clnt${i}=\"$rrd\":in_use_clnt:AVERAGE";
      $cmd .= " CDEF:usedg${i}=used${i},1048576,/";
      $cmd .= " CDEF:in_use_clnt_g${i}=in_use_clnt${i},1048576,/";
      $cmd .= " CDEF:curg${i}=usedg${i},in_use_clnt_g${i},-";
      $lpar_space      =~ s/\/mem/    /;
      $lpar_space_proc =~ s/\/mem/    /;
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"$form_dec \\l\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $lpar_space_proc\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter\"";
    }
    elsif ( $item =~ "wpar_cpu" ) {

      # print STDERR "11160 detail-graph-cgi.pl \$wrkdir_managedname_host_file $wrkdir_managedname_host_file\n";
      $form_dec = "%6.2lf";
      my $rrd = $wrkdir_managedname_host_file;

      $cmd .= " DEF:pc${i}=\"$rrd\":entitled:AVERAGE";
      $cmd .= " DEF:cpusy${i}=\"$rrd\":cpu_sy:AVERAGE";
      $cmd .= " DEF:cpuus${i}=\"$rrd\":cpu_us:AVERAGE";
      $cmd .= " CDEF:proc${i}=pc${i},100,/";
      $cmd .= " CDEF:cpusyc${i}=cpusy${i},proc${i},*";
      $cmd .= " CDEF:cpuusc${i}=cpuus${i},proc${i},*";
      $cmd .= " CDEF:curg${i}=cpuusc${i},cpusyc${i},+";
      $lpar_space      =~ s/\/cpu/    /;
      $lpar_space_proc =~ s/\/cpu/    /;
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"$form_dec \\l\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $lpar_space_proc\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter\"";
    }
    elsif ( $vmware || $hyperv ) {
      if ( $item eq "memaggreg" ) { $form_dec = "%6.1lf"; }
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":$mem_item:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},$gb_mem";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\l\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $lpar_space_proc\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\"";

      # print STDERR "10771 detail-graph-cgi.pl \$lpar_space_proc $lpar_space_proc \$wrkdir_managedname_host_file_legend $wrkdir_managedname_host_file_legend\n";
    }
    else {
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":curr_mem:AVERAGE";
      $cmd .= " CDEF:curg${i}=cur${i},1024,/";
      $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";
      $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     $form_dec \\\"";
      $cmd .= " GPRINT:curg${i}:MAX:\\\"$form_dec \\l\\\"";
      $cmd .= " PRINT:curg${i}:AVERAGE:\"$form_dec $delimiter $item $delimiter $lpar_space_proc\"";
      $cmd .= " PRINT:curg${i}:MAX:\"$form_dec $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\"";
    }

    # put carriage return after each second lpar in the legend
    if ( $j == 1 ) {
      $j = 0;
    }
    else {
      # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)
      $j++;
    }
    $i++;
    $gtype = "STACK";
  }

  if ( $found_at_least_one == 0 ) {

    #    return 0; # no source has been found
  }

  $cmd .= " COMMENT:\\n";
  if ( $item ne "size" && $item ne "res" && $item ne "threads" && $item ne "faults" && $item ne "pages" && $item ne "job_cpu" && $item ne "waj" && $item ne "disk_io" && $item ne "disks" && $item ne "disk_busy" && $item !~ "dstrag_" && $item !~ "wpar_" && $item ne "jobs" && $item ne "powlin_job" && $item ne "jobs_mem" && $item ne "powlin_mem" ) {
    $cmd .= " LINE2:maxg#000000:\\\"Available memory         \\\"";
    $cmd .= " GPRINT:maxg:AVERAGE:\\\"     %6.2lf \\l\\\"";
    $cmd .= " PRINT:maxg:AVERAGE:\"%6.2lf $delimiter $item $delimiter Available memory $delimiter #000000\"";
  }

  # for graph wpar_cpu utilization of the whole LPAR
  if ( $item eq "wpar_cpu" ) {

    # hmc data for lpar utilization
    # print STDERR "11257 detail-graph-cgi.pl LPAR util line for $wrkdir/$server/$host/$lpar_orig.rrm\n";
    my $rrd_lpar = "$wrkdir/$server/$host/$lpar_orig.rrm";
    if ( -f $rrd_lpar ) {
      $cmd .= " DEF:cur=\"$rrd_lpar\":curr_proc_units:AVERAGE";
      $cmd .= " DEF:ent=\"$rrd_lpar\":entitled_cycles:AVERAGE";
      $cmd .= " DEF:cap_peak=\"$rrd_lpar\":capped_cycles:AVERAGE";
      $cmd .= " DEF:uncap=\"$rrd_lpar\":uncapped_cycles:AVERAGE";

      # filtering peaks caused by LPM or changing entitled, if cap CPU util is > entitled --> UNKN
      # usualy cap counter is affected only
      # sometimes might happen that even in normal load capped util is little higher than entitled! Therefore using 1.2
      $cmd .= " CDEF:cap=cap_peak,ent,/,1.2,GT,UNKN,cap_peak,IF";

      $cmd .= " CDEF:tot=cap,uncap,+";
      $cmd .= " CDEF:util=tot,ent,/,$cpu_max_filter,GT,UNKN,tot,ent,/,IF";
      $cmd .= " CDEF:utilperct=util,100,*";
      $cmd .= " CDEF:utiltot=util,cur,*";

      $cmd .= " LINE1:utiltot#FF0000:\"Total utilization\"";
      $cmd .= " GPRINT:utiltot:AVERAGE:\"        %6.2lf\"";
      $cmd .= " GPRINT:utiltot:MAX:\" %6.2lf \\l\\\"";

      $cmd .= " PRINT:utiltot:AVERAGE:\"%6.2lf $delimiter $item $delimiter Total utilization\"";
      $cmd .= " PRINT:utiltot:AVERAGE:\"%6.2lf $delimiter #FF0000\"";
      $cmd .= " PRINT:utiltot:MAX:\"%6.2lf $delimiter\"";
    }
  }

  # for graph wpar_mem utilization of the whole LPAR
  if ( $item eq "wpar_mem" ) {

    # OS or NMON agent data for lpar mem utilization
    # either $wrkdir/$server/$host/$lpar/mem.mmm or $wrkdir/$server/$host/$lpar--NMON--/mem.mmm or nothing";
    my $rrd_lpar = "$wrkdir/$server/$host/$lpar_orig/mem.mmm";
    if ( !-f $rrd_lpar ) {
      $rrd_lpar = "$wrkdir/$server/$host/$lpar_orig--NMON--/mem.mmm";
    }
    if ( -f $rrd_lpar ) {
      $cmd .= " DEF:size=\"$rrd_lpar\":size:AVERAGE";
      $cmd .= " DEF:used=\"$rrd_lpar\":nuse:AVERAGE";
      $cmd .= " DEF:in_use_clnt=\"$rrd_lpar\":in_use_clnt:AVERAGE";

      $cmd .= " CDEF:sizeg=size,1048576,/";
      $cmd .= " CDEF:usedg=used,1048576,/";
      $cmd .= " CDEF:in_use_clnt_g=in_use_clnt,1048576,/";
      $cmd .= " CDEF:used_realg=usedg,in_use_clnt_g,-";

      #      $cmd .= " COMMENT:\"   [GB]             AVRG      MAX  \\n\"";
      $cmd .= " LINE1:used_realg#FF0000:\"Used LPAR \"";
      $cmd .= " GPRINT:used_realg:AVERAGE:\"                    %6.2lf\"";
      $cmd .= " GPRINT:used_realg:MAX:\" %6.2lf \\l\\\"";

      $cmd .= " LINE1:sizeg#000000:\"Total LPAR\"";
      $cmd .= " GPRINT:sizeg:AVERAGE:\"                    %6.2lf\"";
      $cmd .= " GPRINT:sizeg:MAX:\" %6.2lf \\l\\\"";

      $cmd .= " PRINT:used_realg:AVERAGE:\"%6.2lf $delimiter $item $delimiter Used LPAR\"";
      $cmd .= " PRINT:used_realg:AVERAGE:\"%6.2lf $delimiter #FF0000\"";
      $cmd .= " PRINT:used_realg:MAX:\"%6.2lf $delimiter\"";

      $cmd .= " PRINT:sizeg:AVERAGE:\"%6.2lf $delimiter $item $delimiter Total LPAR\"";
      $cmd .= " PRINT:sizeg:AVERAGE:\"%6.2lf $delimiter #000000\"";
      $cmd .= " PRINT:sizeg:MAX:\"%6.2lf $delimiter\"";
    }
  }

  #if ( "$type" =~ "d" ) {
  my $ltime = localtime($last_update);
  $ltime =~ s/:/\\\:/g;
  $t = "COMMENT:\\\"Updated\\\: $ltime\\\"";
  $cmd .= " $t";
  $t = "COMMENT:Updated\\\: $ltime";

  #}

  $cmd .= " HRULE:0#000000";

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  # print STDERR "12631 detail-graph-cgi.pl $cmd\n";

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph mem aggregated rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    if ( $@ =~ "Legend too long" ) {
      print STDERR "Here is the cmd with that long legend:$cmd\n\n";
    }
    return 1;
  }
  $t = "" if "$type" !~ "d";

  $picture = do {
    local $/ = undef;
    open my $fh, "<", $name_out || error( "Cannot open  $name_out: $!" . __FILE__ . ":" . __LINE__ ) && return 0;
    <$fh>;
  };

  # unlink("$name_out");

  $png_end_heading = ret_graph_param( $ret, $t );
  return 0;
}

sub graph_amsaggreg {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT: ";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT: ";
  my $head        = "COMMENT:                            Average   \\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph Memory Aggreg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;    # some workaround, it should not go here
  }
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();

  my $header         = "Active Memory Sharing : last $text";
  my $vertical_label = "--vertical-label=Memory in GBytes";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";                   # nope string
    $header         = "Active Memory Sharing: $text";
  }
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "";            # just a trick

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "Active Memory Sharing: $start_human - $end_human";
    }
  }

  my @files = "";
  opendir( DIR, "$wrkdir/$server/$host" ) || error( " directory does not exists : $wrkdir/$server/$host" . __FILE__ . ":" . __LINE__ ) && return 0;
  if ( $type_sam =~ "m" ) {
    my @files_unsorted = grep( /\.rmm$/, readdir(DIR) );
    @files = sort { lc $a cmp lc $b } @files_unsorted;
  }
  if ( $type_sam =~ "h" ) {
    my @files_unsorted = grep( /\.rmh$/, readdir(DIR) );
    @files = sort { lc $a cmp lc $b } @files_unsorted;
  }
  if ( $type_sam =~ "d" ) {
    my @files_unsorted = grep( /\.rmd$/, readdir(DIR) );
    @files    = sort { lc $a cmp lc $b } @files_unsorted;
    $req_time = $act_time_u - 31536000;
  }
  closedir(DIR);
  my $file = "";
  my $i    = 0;
  my $cmd  = "";
  my $j    = 0;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \\\"$name_out\\\"";
  $cmd .= " --title \\\"$header\\\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " \\\"$vertical_label\\\"";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( "$type" =~ "d" ) {
    $cmd .= " COMMENT:\\\"Current allocated memory in GB\\:    average    maximum     last\\l\\\"";
  }
  else {
    $cmd .= " COMMENT:\\\"Current allocated memory in GB\\:    average    maximum\\l\\\"";
  }
  my $gtype = "AREA";

  my $wrkdir_managedname_host_mem_pool = "$wrkdir/$server/$host/mem-pool.rr$type_sam";
  $wrkdir_managedname_host_mem_pool =~ s/:/\\:/g;

  if ( -f "$wrkdir/$server/$host/mem-pool.rr$type_sam" ) {
    $cmd .= " DEF:cur_pool=\\\"$wrkdir_managedname_host_mem_pool\\\":curr_pool_mem:AVERAGE";
    $cmd .= " CDEF:cur_poolg=cur_pool,1024,/";
  }

  my $found_at_least_one = 0;
  my $last_update        = 0;
  my $found              = -1;

  foreach $file (@files) {
    chomp($file);
    $found++;
    $found_at_least_one = 1;

    # avoid old lpars which do not exist in the period
    my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$file") )[9];
    if ( $rrd_upd_time < $req_time ) {
      next;
    }
    if ( $rrd_upd_time > $last_update ) {
      $last_update = $rrd_upd_time;
    }

    $lpar = $file;
    $lpar =~ s/.rmh//;
    $lpar =~ s/.rmm//;
    $lpar =~ s/.rmd//;
    my $lpar_space_proc = $lpar;
    my $lpar_space      = $lpar;
    $lpar_space =~ s/\&\&1/\//g;

    # add spaces to lpar name to have 25 chars total (for formating graph legend)
    $lpar_space =~ s/\&\&1/\//g;
    for ( my $k = length($lpar_space); $k < 25; $k++ ) {
      $lpar_space .= " ";
    }

    # Exclude pools and memory
    if ( ( ( "$lpar" eq "pool" ) && ( length($lpar) == 4 ) ) || ( ( "$lpar" eq "mem" ) && ( length($lpar) == 3 ) ) || ( $lpar =~ "SharedPool[0-9]" ) || ( $lpar =~ "SharedPool[1-9][0-9]" ) ) {
      next;
    }

    print "$wrkdir/$server/$host/$file $rrd_upd_time $req_time $act_time\n" if ( $DEBUG == 3 );

    # to keep same count of characters
    $lpar_space =~ s/\\:/:/g;
    $lpar_space = sprintf( "%-25s", $lpar_space );
    $lpar_space      =~ s/:/\\:/g;
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;    # anti '%'

    my $wrkdir_managedname_host_file = "$wrkdir/$server/$host/$file";
    $wrkdir_managedname_host_file =~ s/:/\\:/g;
    my $wrkdir_managedname_host_file_legend = $wrkdir_managedname_host_file;
    $wrkdir_managedname_host_file_legend =~ s/%/%%/g;

    # bulid RRDTool cmd
    $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":phys_run_mem:AVERAGE";
    $cmd .= " CDEF:curg${i}=cur${i},1024,/";
    $cmd .= " $gtype:curg${i}$color[$found % ($color_max +1)]:\\\"$lpar_space\\\"";

    $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     %6.2lf \\\"";
    my $item_day_other = "$item-other";
    if ( "$type" =~ "d" ) {
      $item_day_other = "$item-day";
    }

    $cmd .= " PRINT:curg${i}:AVERAGE:\\\"%6.2lf $delimiter $item_day_other $delimiter $lpar_space_proc $delimiter $color[$found % ($color_max +1)] $delimiter $wrkdir_managedname_host_file_legend\\\"";
    if ( "$type" =~ "d" ) {
      $cmd .= " GPRINT:curg${i}:MAX:\\\" %6.2lf \\\"";
      $cmd .= " PRINT:curg${i}:MAX:\\\"%6.2lf $delimiter \\\"";
      $cmd .= " GPRINT:curg${i}:LAST:\\\" %6.2lf \\l\\\"";
      $cmd .= " PRINT:curg${i}:LAST:\\\"%6.2lf $delimiter \\\"";
    }
    else {
      $cmd .= " GPRINT:curg${i}:MAX:\\\" %6.2lf \\l\\\"";
      $cmd .= " PRINT:curg${i}:MAX:\\\"%6.2lf $delimiter \\\"";
    }

    # put carriage return after each second lpar in the legend
    if ( $j == 1 ) {
      $j = 0;
    }
    else {
      # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)
      $j++;
    }
    $i++;
    $gtype = "STACK";
  }

  if ( $found_at_least_one == 0 ) {
    return 0;    # no source has been found
  }

  if ( -f "$wrkdir/$server/$host/mem-pool.rr$type_sam" ) {
    $cmd .= " COMMENT:\\n";
    $cmd .= " LINE2:cur_poolg#000000:\\\"Configured max mem pool  \\\"";
    $cmd .= " GPRINT:cur_poolg:AVERAGE:\\\"     %6.2lf \\l\\\"";
    $cmd .= " PRINT:cur_poolg:AVERAGE:\"%6.2lf $delimiter $item-end $delimiter Configured max mem pool $delimiter #000000\"";

  }

  #if ( "$type" =~ "d" ) {
  my $ltime = localtime($last_update);
  $ltime =~ s/:/\\\:/g;
  $t = "COMMENT:\\\"Updated\\\: $ltime\\\"";
  $cmd .= " $t";

  #}

  $cmd .= " HRULE:0#000000";

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph AMS rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #$t = "" if "$type" !~ "d";
  $png_end_heading = ret_graph_param( $ret, $t );
  return 0;
}

sub graph_ldomagg {
  my $host          = shift;
  my $server        = shift;
  my $lpar          = shift;
  my $type          = shift;
  my $name_out      = shift;
  my $type_sam      = shift;
  my $detail        = shift;
  my $graph_hours   = shift;
  my $entitle       = shift;
  my $start_unix    = shift;
  my $end_unix      = shift;
  my $t             = "COMMENT:\" \" ";
  my $t2            = "COMMENT:\\n";
  my $step_new      = $step;
  my $last          = "COMMENT: ";
  my $act_time      = localtime();
  my $act_time_u    = time();
  my $req_time      = 0;
  my $line_items    = 0;                     # how many items in the legend per a line (default 2, when detail then 3)
  my $last_day_back = $act_time_u - 86400;

  if ( $detail == 1 ) {
    $line_items = 2;
  }
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lparagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }
  my $head = "LDOMs cpu";
  if ( $item eq "solaris_ldom_agg_c" ) {
    $head = "LDOMs cpu";
  }
  elsif ( $item eq "solaris_ldom_agg_m" ) {
    $head = "LDOMs mem";
  }
  my $header = "$head aggregated :$last_txt$text";

  if ( $detail == 1 ) {
    $header = "$head aggregated: $server :$last_txt$text";
    $header = "$head aggregated: $lpar :$last_txt$text" if ( $item =~ "wlm" );
    $header = "$head aggregated: $last_txt$text"        if ( $item eq "multicluster" );
    $header = "$head aggregated: $host :$last_txt$text" if ($hitachi);
  }

  if ( $detail == 2 ) {

    # $header = "$server :$last_txt$text";
    $header = "LDOMs aggregated :$last_txt$text";
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # my $start_time = "now-1$type";
  # my $end_time = "now-1$type+1$type";

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  # print STDERR "$start_time $end_time \n";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "";                # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$head aggregated: $server : $start_human - $end_human";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my @cluster_arr;
  my @files = "";

  #  print STDERR"$wrkdir/$server/$host/$lpar/\n";
  opendir( DIR, "$wrkdir/Solaris/" ) || error( " directory does not exists : $wrkdir/Solaris/ " . __FILE__ . ":" . __LINE__ ) && return 0;
  my @ldom_names = grep !/^\.\.?$/, readdir(DIR);
  closedir(DIR);
  foreach my $ldom_name (@ldom_names) {
    chomp $ldom_name;
    if ( -d "$wrkdir/Solaris/$ldom_name/ZONE/" ) {
      if ( -f "$wrkdir/Solaris/$ldom_name/ZONE/total.mmm" ) {
        push @files, "$wrkdir/Solaris/$ldom_name/ZONE/total.mmm\n";
      }
    }
  }

  #  my $file_count = @files;

  my $file = "";
  my $i    = 0;

  #  my $lpar = "";
  my $aix_ser = $lpar;
  my $cmd     = "";
  my $j       = 0;

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "";
  if ( $item eq "solaris_ldom_agg_c" ) {
    $vertical_label = "--vertical-label=\"CPU cores\"";
  }
  elsif ( $item eq "solaris_ldom_agg_m" ) {
    $vertical_label = "--vertical-label=\"GB\"";
  }

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  my $units = "cores";

  if ( $item eq "solaris_ldom_agg_c" ) {
    if ( $detail == 1 ) {
      $cmd .= " COMMENT:\"Utilization in CPU $units\\:    average  maximum                             average  maximum                               average  maximum\\l\"";
    }
    else {
      $cmd .= " COMMENT:\"Utilization in CPU $units\\:    average  maximum\\l\"";
    }
  }
  elsif ( $item eq "solaris_ldom_agg_m" ) {
    if ( $detail == 1 ) {
      $cmd .= " COMMENT:\"Used memory in GB\\:       average  maximum                           average  maximum                               average  maximum\\l\"";
    }
    else {
      $cmd .= " COMMENT:\"Used Memory in GB\\:    average  maximum\\l\"";
    }
  }

  my $lpar_color_index  = -1;
  my $color_WLM_counter = 0;
  my $gtype             = "AREA";
  my $color_indx        = 0;
  my $line_indx         = 0;        # place enter every 3rd line
  my $files_index       = -1;       # for vmware it is color index
  foreach $file (@files) {
    chomp($file);
    if ( defined $file && $file eq "" ) {next}
    my $rrd_file_update = ( stat("$file") )[9];

    #if ($rrd_file_update < $last_day_back) {next}

    if ( "$type" =~ "d" ) {
      $req_time = $act_time_u - 86400;
      if ( $rrd_file_update < $req_time ) {next}
    }
    if ( "$type" =~ "w" ) {
      $req_time = $act_time_u - 604800;
      if ( $rrd_file_update < $req_time ) {next}
    }
    if ( "$type" =~ "m" ) {
      $req_time = $act_time_u - 2764800;
      if ( $rrd_file_update < $req_time ) {next}
    }
    if ( "$type" =~ "y" ) {
      $req_time = $act_time_u - 31536000;
      if ( $rrd_file_update < $req_time ) {next}
    }
    my $file_orig = $file;    # keep for vmware
                              #    $files_index = $files_index++ % $color_max; # not possible !!!
    $files_index++;
    $files_index = $files_index % $color_max;

    $lpar_color_index++;
    my @arr_path = split( "\/", $file );
    $file   = $arr_path[-1];
    $host   = $arr_path[-2];
    $server = $arr_path[-3];

    # avoid old lpars which do not exist in the period
    #my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$file") )[9];
    #next if ( $rrd_upd_time < $req_time );

    $lpar = $file;
    $lpar =~ s/.rrh//;
    $lpar =~ s/.rrm//;
    $lpar =~ s/.rrd//;
    $lpar =~ s/.mmm//;
    $lpar =~ s/.hlm//;                          # hitachi suffix
    $lpar =~ s/wlm-// if ( $item =~ "wlm-" );

    my $lpar_space_proc = human_vmware_name( $lpar, "", $server );
    my $lpar_space      = $lpar_space_proc;

    # add spaces to lpar name to have 25 chars total (for formating graph legend)
    $lpar_space =~ s/\&\&1/\//g;
    for ( my $k = length($lpar_space); $k < 25; $k++ ) {
      $lpar_space .= " ";
    }

    # max 25 chars
    $lpar_space = substr( $lpar_space, 0, 24 );

    $lpar_space      =~ s/:/\\:/g;    # anti ':'
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;     # anti '%

    my $wrkdir_server_host_file = "$wrkdir/Solaris/$server/$host/$file";
    $wrkdir_server_host_file =~ s/:/\\:/g;
    my $wrkdir_server_host_file_legend = $wrkdir_server_host_file;
    $wrkdir_server_host_file_legend =~ s/%/%%/g;
    my $server_space = $server;
    $server_space =~ s/\&\&1/\//g;
    for ( my $k = length($server_space); $k < 25; $k++ ) {
      $server_space .= " ";
    }

    # max 25 chars
    $server_space = substr( $server_space, 0, 24 );

    $server_space =~ s/:/\\:/g;    # anti ':'
    my $ds_name1  = "";
    my $lf_format = "";
    my $item_l    = "";
    ###### CMD PART
    if ( $item eq "solaris_ldom_agg_c" ) {
      $ds_name1  = "cpu_used";
      $lf_format = "%5.2lf";
    }
    elsif ( $item eq "solaris_ldom_agg_m" ) {
      $ds_name1  = "phy_mem_us";
      $lf_format = "%3.1lf";
    }
    $cmd .= " DEF:util_tot${i}=\"$wrkdir_server_host_file\":$ds_name1:AVERAGE";
    if ( $item eq "solaris_ldom_agg_m" ) {
      $cmd .= " CDEF:utiltot${i}=util_tot${i},1000,/,1000,/";
    }
    elsif ( $item eq "solaris_ldom_agg_c" ) {
      $cmd .= " CDEF:utiltot${i}=util_tot${i},1,/";
    }
    if ( $color_indx == 52 ) {
      $color_indx = 0;
    }
    my $index_to_display = $color_indx;
    if ( $lpar_color_index > -1 ) {
      $index_to_display = $lpar_color_index;
    }
    $cmd .= " $gtype:utiltot${i}$color[$color_indx]:\"$server_space\"";
    $cmd .= " GPRINT:utiltot${i}:AVERAGE:\"$lf_format \"";
    $cmd .= " GPRINT:utiltot${i}:MAX:\" $lf_format \"";

    $cmd .= " PRINT:utiltot${i}:AVERAGE:\"$lf_format $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_indx]\"";
    $cmd .= " PRINT:utiltot${i}:MAX:\" $lf_format $delimiter $wrkdir_server_host_file_legend\"";

    #$cmd .= " GPRINT:utiltot${i}:MAX:\" %5.2lf \\l\"";
    # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)

    $color_indx = ( $color_indx + 1 ) % ( $color_max + 1 );

    #    $col_indx++;
    $gtype = "STACK";
    $i++;
    if ( $line_indx == $line_items ) {

      # put carriage return after each second lpar in the legend
      $cmd .= " COMMENT:\"\\l\"";
      $line_indx = 0;
    }
    else {
      $line_indx++;
    }

  }
  $cmd .= " COMMENT:\"\\l\"";    # last legend line in detail not across whole line

  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;        # a trick, there was a problem with aggregated and "COMMENT: "

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  # print STDERR "7464 detail-graph-cgi.pl lparagg \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;

}

sub graph_error_agg {
  my $host          = shift;
  my $server        = shift;
  my $lpar          = shift;
  my $type          = shift;
  my $name_out      = shift;
  my $type_sam      = shift;
  my $detail        = shift;
  my $graph_hours   = shift;
  my $entitle       = shift;
  my $start_unix    = shift;
  my $end_unix      = shift;
  my $t             = "COMMENT:\" \" ";
  my $t2            = "COMMENT:\\n";
  my $step_new      = $step;
  my $last          = "COMMENT: ";
  my $act_time      = localtime();
  my $act_time_u    = time();
  my $req_time      = 0;
  my $line_items    = 0;                     # how many items in the legend per a line (default 2, when detail then 3)
  my $last_day_back = $act_time_u - 86400;

  if ( $detail == 1 ) {
    $line_items = 2;
  }

  #$headline1      = "COMMENT:Errors";
  #$headline2      = "COMMENT: Int          Avg      Max";
  #$vertical_label = "--vertical-label= FC errors / sec";
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lparagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }
  my $head   = "FC errors";
  my $header = "$head aggregated :$last_txt$text";

  if ( $detail == 1 ) {
    $header = "$head aggregated: $server :$last_txt$text";
    $header = "$head aggregated: $lpar :$last_txt$text" if ( $item =~ "wlm" );
    $header = "$head aggregated: $last_txt$text"        if ( $item eq "multicluster" );
    $header = "$head aggregated: $host :$last_txt$text" if ($hitachi);
  }

  if ( $detail == 2 ) {

    # $header = "$server :$last_txt$text";
    $header = "FC errors aggregated :$last_txt$text";
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # my $start_time = "now-1$type";
  # my $end_time = "now-1$type+1$type";

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  # print STDERR "$start_time $end_time \n";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "";                # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$head aggregated: $server : $start_human - $end_human";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  my @cluster_arr;
  my @files = "";

  #  print STDERR"$wrkdir/$server/$host/$lpar/\n";
  opendir( DIR, "$wrkdir/$server/$host/" ) || error( " directory does not exists : $wrkdir/$server/$host/ " . __FILE__ . ":" . __LINE__ ) && return 0;
  my @lpar_names = grep !/^\.\.?$/, readdir(DIR);
  closedir(DIR);
  foreach my $lpar_name (@lpar_names) {
    chomp $lpar_name;
    if ( -d "$wrkdir/$server/$host/$lpar_name" ) {
      opendir( DIR, "$wrkdir/$server/$host/$lpar_name/" ) || error( " directory does not exists : $wrkdir/$server/$host/ " . __FILE__ . ":" . __LINE__ ) && return 0;
      my @error_fcs = grep /^san_error/, readdir(DIR);
      closedir(DIR);
      foreach my $error_fc (@error_fcs) {
        if ( -f "$wrkdir/$server/$host/$lpar_name/$error_fc" ) {
          push @files, "$wrkdir/$server/$host/$lpar_name/$error_fc\n";
        }
      }
    }
  }

  #  my $file_count = @files;

  my $file = "";
  my $i    = 0;

  #  my $lpar = "";
  my $aix_ser = $lpar;
  my $cmd     = "";
  my $j       = 0;

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=\"FC errors / sec\"";

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  my $units = "cores";

  if ( $detail == 1 ) {
    $cmd .= " COMMENT:\"LPAR name                  FCS name\\:      average  maximum\\l\"";
  }
  else {
    $cmd .= " COMMENT:\"LPAR name                  FCS name\\:      average  maximum\\l\"";
  }

  my $lpar_color_index  = -1;
  my $color_WLM_counter = 0;
  my $gtype             = "AREA";
  my $color_indx        = 0;
  my $line_indx         = 0;        # place enter every 3rd line
  my $files_index       = -1;       # for vmware it is color index
  foreach $file (@files) {
    chomp($file);
    if ( defined $file && $file eq "" ) {next}
    my $rrd_file_update = ( stat("$file") )[9];

    #if ($rrd_file_update < $last_day_back) {next}

    if ( "$type" =~ "d" ) {
      $req_time = $act_time_u - 86400;
      if ( $rrd_file_update < $req_time ) {next}
    }
    if ( "$type" =~ "w" ) {
      $req_time = $act_time_u - 604800;
      if ( $rrd_file_update < $req_time ) {next}
    }
    if ( "$type" =~ "m" ) {
      $req_time = $act_time_u - 2764800;
      if ( $rrd_file_update < $req_time ) {next}
    }
    if ( "$type" =~ "y" ) {
      $req_time = $act_time_u - 31536000;
      if ( $rrd_file_update < $req_time ) {next}
    }
    my $file_orig = $file;    # keep for vmware
                              #    $files_index = $files_index++ % $color_max; # not possible !!!
    $files_index++;
    $files_index = $files_index % $color_max;

    $lpar_color_index++;
    my @arr_path = split( "\/", $file );
    $file   = $arr_path[-1];
    $host   = $arr_path[-2];
    $server = $arr_path[-3];
    my $power_name = $arr_path[-4];

    # avoid old lpars which do not exist in the period
    #my $rrd_upd_time = ( stat("$wrkdir/$server/$host/$file") )[9];
    #next if ( $rrd_upd_time < $req_time );

    $lpar = $file;
    $lpar =~ s/.rrh//;
    $lpar =~ s/.rrm//;
    $lpar =~ s/.rrd//;
    $lpar =~ s/.mmm//;

    my $lpar_space_proc = human_vmware_name( $lpar, "", $server );
    my $lpar_space      = $lpar_space_proc;

    # add spaces to lpar name to have 25 chars total (for formating graph legend)
    $lpar_space =~ s/\&\&1/\//g;
    for ( my $k = length($lpar_space); $k < 25; $k++ ) {
      $lpar_space .= " ";
    }

    # max 25 chars
    $lpar_space = substr( $lpar_space, 0, 24 );

    $lpar_space      =~ s/:/\\:/g;         # anti ':'
    $lpar_space      =~ s/san_error-//g;
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;          # anti '%
    $lpar_space_proc =~ s/san_error-//g;

    my $wrkdir_server_host_file = "$wrkdir/$power_name/$server/$host/$file";
    $wrkdir_server_host_file =~ s/:/\\:/g;
    my $wrkdir_server_host_file_legend = $wrkdir_server_host_file;
    $wrkdir_server_host_file_legend =~ s/%/%%/g;
    my $server_space = $host;
    $server_space =~ s/\&\&1/\//g;
    for ( my $k = length($server_space); $k < 25; $k++ ) {
      $server_space .= " ";
    }

    # max 25 chars
    $server_space = substr( $server_space, 0, 24 );

    $server_space =~ s/:/\\:/g;    # anti ':'
    my $ds_name1  = "error_fcs";
    my $lf_format = "%4.0lf";
    my $item_l    = "";

    $cmd .= " DEF:util_tot${i}=\"$wrkdir_server_host_file\":$ds_name1:AVERAGE";
    $cmd .= " CDEF:utiltot${i}=util_tot${i},1,/";
    if ( $color_indx == 52 ) {
      $color_indx = 0;
    }
    my $index_to_display = $color_indx;
    if ( $lpar_color_index > -1 ) {
      $index_to_display = $lpar_color_index;
    }
    $cmd .= " $gtype:utiltot${i}$color[$color_indx]:\"$server_space $lpar_space\"";
    $cmd .= " GPRINT:utiltot${i}:AVERAGE:\"$lf_format \"";
    $cmd .= " GPRINT:utiltot${i}:MAX:\" $lf_format \"";

    $cmd .= " PRINT:utiltot${i}:AVERAGE:\"$lf_format $delimiter $item $delimiter $server_space $delimiter $lpar_space_proc $delimiter $color[$color_indx]\"";

    #$cmd .= " PRINT:utiltot${i}:AVERAGE:\"$lf_format $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_indx]\"";
    $cmd .= " PRINT:utiltot${i}:MAX:\" $lf_format $delimiter $wrkdir_server_host_file_legend\"";
    $cmd .= " $t2";

    #$cmd .= " GPRINT:utiltot${i}:MAX:\" %5.2lf \\l\"";
    # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)

    $color_indx = ( $color_indx + 1 ) % ( $color_max + 1 );

    #    $col_indx++;
    $gtype = "STACK";
    $i++;
    if ( $line_indx == $line_items ) {

      # put carriage return after each second lpar in the legend
      $cmd .= " COMMENT:\"\\l\"";
      $line_indx = 0;
    }
    else {
      $line_indx++;
    }

  }
  $cmd .= " COMMENT:\"\\l\"";    # last legend line in detail not across whole line

  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;        # a trick, there was a problem with aggregated and "COMMENT: "

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  # print STDERR "7464 detail-graph-cgi.pl lparagg \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;

}

sub encode_base64 {
  if ( $] >= 5.006 ) {
    require bytes;
    if ( bytes::length( $_[0] ) > length( $_[0] )
      || ( $] >= 5.008 && $_[0] =~ /[^\0-\xFF]/ ) )
    {
      require Carp;
      Carp::croak("The Base64 encoding is only defined for bytes");
    }
  }

  use integer;

  my $eol = $_[1];
  $eol = "\n" unless defined $eol;

  my $res = pack( "u", $_[0] );

  # Remove first character of each line, remove newlines
  $res =~ s/^.//mg;
  $res =~ s/\n//g;

  $res =~ tr|` -_|AA-Za-z0-9+/|;    # `# help emacs
                                    # fix padding at the end
  my $padding = ( 3 - length( $_[0] ) % 3 ) % 3;
  $res =~ s/.{$padding}$/'=' x $padding/e if $padding;

  # break encoded string into lines of no more than 76 characters each
  if ( length $eol ) {
    $res =~ s/(.{1,76})/$1$eol/g;
  }
  return $res;
}

sub human_vmware_name {
  my $lpar         = shift;
  my $arrow        = shift;
  my $local_server = shift;

  $arrow = "" if !defined $arrow;

  return "$lpar" if ( !$vmware && !$hyperv );    # only for vmware or hyperv
                                                 # read file and find human lpar name from uuid or
                                                 # if 'neg' then find uuid from name
                                                 # print STDERR "11609 \$lpar $lpar \$arrow $arrow\n";
  my $vms_dir = "vmware_VMs";
  if ($hyperv) {
    $vms_dir = "$local_server/$all_hyperv_VMs";
    if ( $local_server !~ /^windows/ ) {
      ;    #$wrkdir/windows/$host/$all_hyperv_VMs/$lpar.rrm";
      $vms_dir = "windows/$vms_dir";
    }
  }

  # my $trans_file = "$wrkdir/$server/$host/lpar_trans.txt"; # old solution on servers
  my $trans_file = "$wrkdir/$vms_dir/vm_uuid_name.txt";

  # print STDERR "13770 $wrkdir/$vms_dir/vm_uuid_name.txt \n";
  if ( -f "$trans_file" ) {
    my $name      = "";
    my $file_time = 0;

    # there can be more UUID for same Vm name when param is 'neg', choose latest one
    open( FR, "< $trans_file" );
    foreach my $linep (<FR>) {
      chomp($linep);

      # print STDERR "12956 $linep\n";
      ( my $id, my $name_tmp, undef ) = split( /,/, $linep );
      if ( "$arrow" eq "neg" ) {
        ( $name_tmp, $id, undef ) = split( /,/, $linep );

        # print STDERR "12960 \$id $id \$lpar $lpar\n";
        if ( "$id" eq "$lpar" ) {
          next if !-f "$wrkdir/$vms_dir/$name_tmp.rrm";
          my $act_file_time = ( stat("$wrkdir/$vms_dir/$name_tmp.rrm") )[9];
          if ( $act_file_time > $file_time ) {
            $file_time = $act_file_time;
            $name      = $name_tmp;

            # print STDERR "11630 \$name $name \$file_time $file_time\n";
          }
        }
      }
      else {
        if ( "$id" eq "$lpar" ) {
          $name = $name_tmp;
          last;
        }
      }
    }
    close(FR);
    $lpar = "$name" if $name ne "";
  }
  return "$lpar";    #human name - if found, or original
}

sub find_human_ds_name {
  my ( $server, $host, $lpar ) = @_;
  my @files     = bsd_glob "$wrkdir/$server/$host/*.$lpar";
  my $lpar_name = $lpar;
  if ( defined $files[0] && $files[0] ne "" ) {
    $lpar_name = ( split( "\/", $files[0] ) )[-1];
    $lpar_name =~ s/\.$lpar$//;
  }
  return $lpar_name;
}

sub graph_vmw_disk {
  my ( $host, $server, $lpar, $type, $name_out, $type_sam, $detail, $start_unix, $end_unix ) = @_;
  my $t        = "COMMENT:\" \"";
  my $t2       = "COMMENT:\"\\n\"";
  my $step_new = $step;
  my $last     = "COMMENT: ";
  my $head     = "COMMENT:                            Average   Max\\n";

  my $xgrid         = xgrid_set( $type, $detail );
  my $text          = text_set($type);
  my $human_ds_name = "";

  my $filter = 0;

  # due to historical reports where is specific time passed
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }

      # finding human datastore name
      if ( $item eq 'dsrw' || $item eq 'dsarw' || $item eq 'dslat' ) {
        $human_ds_name = find_human_ds_name( $server, $host, $lpar );
      }
    }
  }

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST: %4.0lf";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  # print STDERR "12966 detail-graph-cgi.pl $host:$server:$lpar \$detail $detail \$start_unix $start_unix \$end_unix $end_unix \$item $item\n";
  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_vmw_disk: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;                    # some workaround, it should not go here
  }

  my $rrd;

  # print STDERR "13864 \$hyperv $hyperv $wrkdir / $server / $host / $lpar\n";
  if ( $item =~ 'vmdisk' || $item =~ 'vmnet' ) {    # ESXi server tabs
    $lpar = "pool";
    $rrd  = "$wrkdir/$server/$host/$lpar.rrm";
    if ( $item eq 'vmnetrw' ) {
      $lpar = "$host";
      $lpar = "pool" if $detail eq 2;
    }
  }
  elsif ( $item =~ 'dsrw' || $item =~ 'dsarw' ) {    # datastore Read Write, Averaged
    $rrd = "$wrkdir/$server/$host/$lpar.rrt";
  }
  elsif ( $item =~ 'dslat' ) {                       # datastore Latency
    $rrd = "$wrkdir/$server/$host/$lpar.rru";
  }
  elsif ($hyperv) {
    if ( $item =~ 'hyp-disk' || $item =~ 'hyp-mem' || $item =~ 'hyp-cpu' || $item =~ 'hyp-net' ) {    # VM disk
      $rrd = "$wrkdir/$server/$all_hyperv_VMs/$lpar.rrm";
    }
    elsif ( $item =~ 'lfd_dat' || $item =~ 'lfd_io' || $item =~ 'lfd_lat' ) {
      $rrd = "$wrkdir/$server/$host/Local_Fixed_Disk_$lpar.rrm";
    }
    elsif ( $item =~ 'csv_dat' || $item =~ 'csv_io' || $item =~ 'csv_lat' ) {
      $lpar =~ s/CSV//;

      #$rrd = "$wrkdir/$server/$host/Cluster_Storage_Volume$lpar.rrm";
      $rrd = "$wrkdir/$server/$host/Cluster_Storage_$lpar.rrm";
    }
    elsif ( $item =~ 'phys_disk_io' || $item =~ 'phys_disk_latency' || $item =~ 'phys_disk_data' ) {
      $rrd = "$wrkdir/$server/$host/pdisks/pd_$lpar.rrm";

      #print STDERR "19783 \$hyperv $hyperv $wrkdir / $server / $host / $lpar\n";
    }
    elsif ( $item =~ 's2dvol_io' || $item =~ 's2dvol_latency' || $item =~ 's2dvol_data' ) {
      $rrd = "$wrkdir/$server/$host/volumes/vol_$lpar.rrm";

      #print STDERR "19783 \$hyperv $hyperv $wrkdir / $server / $host / $lpar\n";
    }
    else {    #server
      $lpar = "pool";
      $rrd  = "$wrkdir/$server/$host/$lpar.rrm";
    }

    # print STDERR "13883 \$rrd $rrd\n";
  }
  elsif ( $item =~ /^solaris_zone_cpu|^solaris_zone_os_cpu|^solaris_zone_mem|^solaris_zone_net/ ) {
    if ( $lpar =~ /:/ ) {
      my ( undef, undef, $name_ldom ) = split( /:/, $lpar );
      chomp $name_ldom;
      $lpar = $name_ldom;
    }
    $rrd = "$wrkdir/Solaris/$server/ZONE/$lpar.mmm";
  }
  elsif ( $item =~ /^solaris_ldom_cpu|^solaris_ldom_mem/ ) {
    my $char_l = "_ldom";
    if ( $server =~ /Solaris--unknown|Solaris\d+--unknown/ ) { $server = $lpar; }
    if ( $lpar   =~ /:/ ) {
      my ( undef, $name_ldom ) = split( /:/, $lpar );
      chomp $name_ldom;
      $lpar = $name_ldom;
    }
    $rrd = "$wrkdir/Solaris/$server/$lpar$char_l.mmm";
  }
  elsif ( $item =~ /^s10_g_cpu|^s10_g_mem/ ) {
    $rrd = "$wrkdir/Solaris/$server/ZONE/$lpar.mmm";
  }
  elsif ( $item =~ /^s10_z_cpu|^s10_z_mem/ ) {
    $rrd = "$wrkdir/Solaris/$server/ZONE/$lpar.mmm";
  }
  else {    # VM tabs
    $rrd = "$wrkdir/$all_vmware_VMs/$lpar.rrm";

    # print STDERR "14476 detail-graph-cgi.pl vmw_disk $rrd \$server $server \$host $host\n";
  }

  if ( !-f "$rrd" ) {
    error( "for $item file $rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $lpar_slash = human_vmware_name( $lpar, "", $server );

  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  $lpar_slash_nmon =~ s/\(.*\)//;

  my $header_prefix  = "VM :";
  my $head_pref      = "";
  my $legend_head    = " COMMENT:\"    GB               Avrg     Max\\n\"";
  my $vertical_label = "--vertical-label=\"Memory in GBytes\"";
  my $leg_write      = "Mem baloon  ";
  my $leg_read       = "Mem active  ";
  my $leg_usage      = "Mem granted ";
  my $gprint_frm     = "%6.2lf";
  my $upper_limit    = 0.1;
  my $clu_name       = "CLU";

  if ( $item =~ "hyp-net" ) {
    $header_prefix  = "VM :";
    $head_pref      = "LAN";
    $legend_head    = " COMMENT:\"[MB/sec]               Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=\"Read MB/s Write\"";
    $leg_write      = "";
    $leg_read       = "";
    $leg_usage      = "";
  }
  if ( $item =~ "hyp-mem" ) {
    $header_prefix  = "VM :";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"    GB               Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=\"Memory in GBytes\"";
    $leg_write      = "";
    $leg_read       = "";
    $leg_read       = "Usage" if $item eq "vmw-disk" || $item eq "vmdisk";
    $leg_usage      = "";
  }
  if ( $item =~ "hyp-cpu" ) {
    $head_pref      = "CPU";
    $legend_head    = " COMMENT:\"[cores]            Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=CPU-usage";
    $leg_write      = "Usage     ";
    $leg_read       = "Usage     ";
    $leg_usage      = "";
    $upper_limit    = 0.1;
    $gprint_frm     = "%6.1lf";
  }
  if ( $item =~ "vmw-disk" || $item =~ "vmdisk" || $item =~ "hyp-disk" ) {

    #$header_prefix  = "Disk:";
    $head_pref      = "Disk";
    $legend_head    = " COMMENT:\"[MB/sec]        Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=Read-MB/sec-Write";
    $vertical_label = "--vertical-label=Usage-MB/sec" if $item eq "vmw-disk" || $item eq "vmdisk";
    $leg_write      = "Write";
    $leg_read       = "Read ";
    $leg_read       = "Usage" if $item eq "vmw-disk" || $item eq "vmdisk";
    $leg_usage      = "";
    $filter         = $filter_max_lansan / 1000;
  }
  if ( $item =~ "phys_disk" ) {
    $clu_name = $host;
    $clu_name =~ s/cluster_//g;
    $header_prefix  = "$clu_name :";
    $head_pref      = "PD";
    $legend_head    = " COMMENT:\"[IOPS]     Avrg      Max\\n\"";
    $legend_head    = " COMMENT:\"[Latency/ms]   Avrg      Max\\n\"" if $item eq "phys_disk_latency";
    $legend_head    = " COMMENT:\"[MB/sec]    Avrg      Max\\n\""    if $item eq "phys_disk_data";
    $vertical_label = "--vertical-label=Read-IOPS-Write";
    $vertical_label = "--vertical-label=Read-Latency/ms-Write" if $item eq "phys_disk_latency";
    $vertical_label = "--vertical-label=Read-MB/sec-Write"     if $item eq "phys_disk_data";
    $leg_write      = "Write";
    $leg_read       = "Read ";
    $leg_usage      = "";
    $filter         = $filter_max_lansan / 1000;
    $gprint_frm     = "%6.0lf" if $item eq "phys_disk_io";
  }
  if ( $item =~ "s2dvol" ) {
    $clu_name = $host;
    $clu_name =~ s/cluster_//g;
    $header_prefix  = "$clu_name :";
    $head_pref      = "Volume ";
    $legend_head    = " COMMENT:\"[IOPS]     Avrg      Max\\n\"";
    $legend_head    = " COMMENT:\"[Latency/ms]   Avrg      Max\\n\"" if $item eq "s2dvol_latency";
    $legend_head    = " COMMENT:\"[MB/sec]    Avrg      Max\\n\""    if $item eq "s2dvol_data";
    $vertical_label = "--vertical-label=Read-IOPS-Write";
    $vertical_label = "--vertical-label=Read-Latency/ms-Write" if $item eq "s2dvol_latency";
    $vertical_label = "--vertical-label=Read-MB/sec-Write"     if $item eq "s2dvol_data";
    $leg_write      = "Write";
    $leg_read       = "Read ";
    $leg_usage      = "";
    $filter         = $filter_max_lansan / 1000;
    $gprint_frm     = "%6.0lf" if $item eq "s2dvol_io";
  }
  if ( $item =~ "vmw-net" || $item =~ "vmnet" ) {

    #$header_prefix  = "LAN:";
    $head_pref      = "LAN";
    $legend_head    = " COMMENT:\"[MB/sec]          Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=Read-MB/sec-Write";
    $vertical_label = "--vertical-label=Usage-MB/sec" if $item eq "vmw-net" || $item eq "vmnet";
    $leg_write      = "Write    ";
    $leg_read       = "Read     ";
    $leg_read       = "Usage    " if $item eq "vmw-net" || $item eq "vmnet";

    # $leg_usage = "Net usage";
    $filter = $filter_max_lansan / 1000;
  }
  if ( $item eq "vmnetrw" ) {
    $header_prefix = "";
  }
  if ( $item eq "vmw-swap" ) {
    $head_pref      = "Swap";
    $legend_head    = " COMMENT:\"[MB/sec]          Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=Read-MB/sec-Write";
    $leg_write      = "In       ";
    $leg_read       = "Out      ";
  }
  if ( $item eq "vmw-comp" ) {
    $head_pref      = "Comp";
    $legend_head    = " COMMENT:\"[KB/sec]          Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=Read-KB/sec-Write";
    $leg_write      = "Compres  ";
    $leg_read       = "Decompres";
  }
  if ( $item eq "dsrw" ) {
    $header_prefix   = "DS :";
    $head_pref       = "";
    $legend_head     = " COMMENT:\"[MB/sec]          Avrg      Max\\n\"";
    $vertical_label  = "--vertical-label=Read-MB/sec-Write";
    $leg_write       = "Write    ";
    $leg_read        = "Read     ";
    $lpar_slash_nmon = "DATA $human_ds_name";
  }
  if ( $item eq "dsarw" ) {
    $header_prefix   = "DS :";
    $head_pref       = "";
    $legend_head     = " COMMENT:\"[IOPS]              Avrg      Max\\n\"";
    $vertical_label  = "--vertical-label=Read-IOPS-Write";
    $leg_write       = "Write    ";
    $leg_read        = "Read     ";
    $gprint_frm      = "%7.0lf";
    $lpar_slash_nmon = "IOPS $human_ds_name";
  }
  if ( $item eq "dslat" || $item =~ "lfd_lat" || $item =~ "csv_lat" ) {
    $header_prefix = "DS:";
    $head_pref     = "";
    if ( $item =~ 'lfd_lat' || $item =~ "csv_lat" ) {
      $head_pref = "$lpar";
    }
    $legend_head     = " COMMENT:\"[Latency millisec]    Avrg      Max\\n\"";
    $vertical_label  = "--vertical-label=Read-Latency-Write";
    $leg_write       = "Write      ";
    $leg_read        = "Read       ";
    $gprint_frm      = "%7.2lf";
    $lpar_slash_nmon = "Total Latency $human_ds_name";
    $filter          = 10000;
  }
  if ( $item =~ "vmw-proc" ) {
    $head_pref      = "%";
    $legend_head    = " COMMENT:\"[%]                 Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=CPU-usage-%";
    $leg_write      = "Usage       ";
    $leg_read       = "CPU Ready/VM";
    $leg_usage      = "";
    $upper_limit    = 100;
    $gprint_frm     = "%5.1lf";
  }
  if ( $item =~ "vmw-ready" ) {
    $head_pref   = "Ready";
    $legend_head = " COMMENT:\"[%]                    Avrg      Max\\n\"";

    #$legend_head = " COMMENT:\"Millisec          Avrg      Max          Avrg[%]  Max[%] (Right axis)\\n\"";
    $vertical_label = "--vertical-label=CPU-ready-%";
    $leg_write      = "CPU READY/vCPU";
    $leg_read       = "CPU READY/vCPU";
    $leg_usage      = "";
    $upper_limit    = "100";
  }
  if ( $item =~ "vmw-mem" ) {
    $head_pref = "MEM";
  }
  if ( $item eq "hdt_data" || ( $item =~ 'lfd_dat' ) || ( $item =~ 'csv_dat' ) ) {
    $header_prefix = "DS:";
    $head_pref     = "";
    if ( $item =~ 'lfd_dat' || $item =~ 'csv_dat' ) {
      $head_pref = "$lpar";
    }
    $legend_head     = " COMMENT:\"[MB/sec]            Avrg      Max\\n\"";
    $vertical_label  = "--vertical-label=Read-MB/s-Write";
    $leg_write       = "Write    ";
    $leg_read        = "Read     ";
    $gprint_frm      = "%7.0lf";
    $lpar_slash_nmon = "R/W $human_ds_name";
    $filter          = 5000000000000;

    if ( $item eq "hdt_data" ) {
      $header_prefix   = "";
      $lpar_slash_nmon = "R/W: $host";
      $lpar_slash_nmon = "R/W: pool" if $detail eq 2;
    }
  }

  if ( $item eq "hdt_io" || $item =~ 'lfd_io' || ( $item =~ 'csv_io' ) ) {
    $header_prefix = "DS:";
    $head_pref     = "";
    if ( $item =~ 'lfd_io' || $item =~ 'csv_io' ) {
      $head_pref = "$lpar";
    }
    $legend_head     = " COMMENT:\"[IOPS]              Avrg      Max\\n\"";
    $vertical_label  = "--vertical-label=Read-IOPS-Write";
    $leg_write       = "Write    ";
    $leg_read        = "Read     ";
    $gprint_frm      = "%7.0lf";
    $lpar_slash_nmon = "IOPS $human_ds_name";
    $filter          = 50000;

    if ( $item eq "hdt_io" ) {
      $header_prefix   = "";
      $lpar_slash_nmon = "IOPS: $host";
      $lpar_slash_nmon = "IOPS: pool" if $detail eq 2;
    }
  }

  if ( $item eq "solaris_zone_cpu" ) {
    $header_prefix  = "$server : ZONE CPU";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"                              Avrg   Max\\n\"";
    $vertical_label = "--vertical-label=\"CPU cores\"";
    $leg_read       = "Usage in CPU cores    ";
    $gprint_frm     = "%3.2lf";

    #$lpar_slash_nmon = "";
    $filter = 50000;
  }
  if ( $item eq "solaris_zone_mem" ) {
    $header_prefix  = "$server : ZONE Memory";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[GB]              Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=\"GB\"";
    $leg_write      = "Capped memory    ";
    $leg_read       = "Used memory     ";
    $gprint_frm     = "%3.1lf";
    ##$lpar_slash_nmon = "";
    $filter = 100;
  }
  if ( $item eq "solaris_zone_os_cpu" ) {
    $header_prefix  = "$server : ZONE OS CPU";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[%]                 Avrg   Max\\n\"";
    $vertical_label = "--vertical-label=\"CPU-usage-%\"";
    $leg_write      = "Usage    ";
    $leg_read       = "Usage     ";
    $gprint_frm     = "%3.2lf";

    #$lpar_slash_nmon = "";
    $upper_limit = 100;
  }
  if ( $item eq "solaris_zone_net" ) {
    $header_prefix  = "$server : ZONE NET";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[%]                 Avrg   Max\\n\"";
    $vertical_label = "--vertical-label=\"NET-usage-%\"";
    $leg_write      = "Usage    ";
    $leg_read       = "Usage     ";
    $gprint_frm     = "%3.2lf";

    #$lpar_slash_nmon = "";
    $upper_limit = 100;
  }
  if ( $item eq "solaris_ldom_cpu" ) {
    $header_prefix  = "LDOM CPU ";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[%]                 Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=CPU-usage-%";
    $leg_write      = "Usage      ";
    $leg_read       = "Usage      ";
    $leg_usage      = "";
    $upper_limit    = 100;
  }
  if ( $item eq "solaris_ldom_mem" ) {
    $header_prefix  = "LDOM Memory ";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[GB]              Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=\"GB\"";
    $leg_write      = "Capped memory    ";
    $leg_read       = "Allocated memory     ";
    $gprint_frm     = "%3.1lf";
    $filter         = 100;
  }
  if ( $item eq "s10_g_cpu" || $item eq "s10_z_cpu" ) {
    $header_prefix  = "ZONE CPU ";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[%]                 Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=CPU-usage-%";
    $leg_write      = "Usage      ";
    $leg_read       = "Usage      ";
    $leg_usage      = "";
    $upper_limit    = 100;
  }
  if ( $item eq "s10_g_mem" || $item eq "s10_z_mem" ) {
    $header_prefix  = "ZONE Memory ";
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[%]                 Avrg   Max\\n\"";
    $vertical_label = "--vertical-label=MEM-usage-%";
    $leg_write      = "Usage    ";
    $leg_read       = "Usage     ";
    $gprint_frm     = "%3.2lf";

    #$lpar_slash_nmon = "";
    $upper_limit = 100;
  }

  # print STDERR "11193 detail-graph-cgi.pl ".time."\$item $item\n";
  my $last_txt = " last ";

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
    $last_txt       = "";
    $header_prefix  = $head_pref;
    if ( $wpar == 1 ) {
      $header_prefix = $head_pref;
    }
  }
  else {
    $header_prefix .= $head_pref;
  }

  my $header = "$header_prefix : $lpar_slash_nmon : $last_txt$text";
  if ( $header_prefix eq "" ) {
    $header = "$lpar_slash_nmon : $last_txt$text";
  }

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix : $lpar_slash_nmon : $start_human - $end_human";
      $header = "$lpar_slash_nmon : $start_human - $end_human" if $header_prefix eq "";
      if ( $detail != 10 && $detail != 9 && $width < 700 ) {
        $header = "$start_human - $end_human";
      }
    }
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  my $my_max = 15;

  if ( $type =~ "d" ) {
    my $rrd_last = rrd_file_actual("$rrd");
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;

          $last = "";

          #if ( $m_arr[2] > 0 ) {
          #  my $last_mem = sprintf( "%6.2d",$m_arr[2]) / 1024;
          #  my $last_mem_g = sprintf( "%.2f",$m_arr[2] / 1024);
          #  $last ="COMMENT:Last memory consumption in GB         $last_mem_g";
          #}
        }
      }
    }
  }

  # for LPM
  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first
  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "", \@rrd_files, $cgi );

  # print STDERR "lpm_find_files is returning @rrd_files\n";

  # print "graphing PAGING   : $host:$server:$lpar_slash:$type_sam:$type\n" if $DEBUG ;
  # print STDERR "graphing PAGING   : $rrd: $host:$server:$lpar_slash:$type_sam:$type:$start_time:$end_time\n";

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $cmd = "";

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=$upper_limit";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";
  $cmd .= " --base=1024";

  my $i = -1;
  my $j;

  ## define data stream names
  my @ds = ( "Memory_granted", "Memory_active", "Memory_baloon" );
  @ds = ( "Disk_read", "Disk_write" )                                        if ( $item eq "vmw-diskrw" || $item eq "vmdiskrw" );
  @ds = ( "Disk_usage", "Disk_usage" )                                       if ( $item eq "vmw-disk" || $item eq "vmdisk" );       # fake for easy testing later
  @ds = ( "Network_received", "Network_transmitted" )                        if ( $item eq "vmw-netrw" || $item eq "vmnetrw" );
  @ds = ( "Network_usage", "Network_usage" )                                 if ( $item eq "vmw-net" || $item eq "vmnet" );         # fake for easy testing later
  @ds = ( "Memory_swapin", "Memory_swapout" )                                if $item eq "vmw-swap";
  @ds = ( "Memory_compres", "Memory_decompres" )                             if $item eq "vmw-comp";
  @ds = ( "Datastore_read", "Datastore_write" )                              if $item eq "dsrw";
  @ds = ( "Datastore_ReadAvg", "Datastore_WriteAvg" )                        if $item eq "dsarw";
  @ds = ( "Dstore_readLatency", "Dstore_writeLatency" )                      if $item eq "dslat";
  @ds = ( "CPU_usage_Proc", "vCPU", "host_hz", "CPU_usage", "CPU_ready_ms" ) if $item eq "vmw-proc";
  @ds = ( "CPU_ready_ms", "vCPU" )                                           if $item eq "vmw-ready";

  @ds = ( "DiskReadBytesPersec", "DiskWriteBytesPerse", "Timestamp_PerfTime", "Frequency_PerfTime" )                     if ( $item eq "hdt_data" || ( $item =~ 'lfd_dat' ) || ( $item =~ 'csv_dat' ) );
  @ds = ( "BytesReceivedPersec", "BytesSentPersec" )                                                                     if ( $item eq "vmnetrw" && $hyperv );
  @ds = ( "DiskReadsPersec", "DiskWritesPersec", "Timestamp_PerfTime", "Frequency_PerfTime" )                            if ( $item eq "hdt_io" || $item =~ 'lfd_io' || ( $item =~ 'csv_io' ) );
  @ds = ( "AvgDisksecPerRead", "AvgDisksecPerReadB", "AvgDisksecPerWrite", "AvgDisksecPerWriteB", "Frequency_PerfTime" ) if ( $item =~ "lfd_lat" || ( $item =~ 'csv_lat' ) );

  @ds = ( "BytesReceivedPersec", "BytesSentPersec" )     if ( $item eq "hyp-net"  && $hyperv );
  @ds = ( "DiskReadBytesPersec", "DiskWriteBytesPerse" ) if ( $item eq "hyp-disk" && $hyperv );
  @ds = ( "TotalPhysMemory",     "TotalPhysMemory" )     if ( $item eq "hyp-mem"  && $hyperv );
  @ds = ( "PercentTotalRunTime", "Timestamp_PerfTime", "Frequency_PerfTime", "vCPU" ) if $item eq "hyp-cpu";

  @ds = ( "IOPS_Read",         "IOPS_Write" )         if ( $item eq "phys_disk_io"      && $hyperv || $item eq "s2dvol_io"      && $hyperv );
  @ds = ( "Latency_Read_sec",  "Latency_Write_sec" )  if ( $item eq "phys_disk_latency" && $hyperv || $item eq "s2dvol_latency" && $hyperv );
  @ds = ( "Throughput_Read_B", "Throughput_Write_B" ) if ( $item eq "phys_disk_data"    && $hyperv || $item eq "s2dvol_data"    && $hyperv );

  #### SOLARIS SECTION
  @ds = ( "cpu_used", "cpu_used" )                                                     if $item eq "solaris_zone_cpu";
  @ds = ( "cpu_used_perc", "cpu_used_perc" )                                           if $item eq "solaris_zone_os_cpu";
  @ds = ( "phy_mem_us", "cap_used_in_perc", "allocated_memory", "phy_mem_us_in_perc" ) if $item eq "solaris_zone_mem";
  @ds = ( "phy_net_in_perc", "phy_net_in_perc" )                                       if $item eq "solaris_zone_net";
  @ds = ( "cpu_util", "cpu_util" )                                                     if $item eq "solaris_ldom_cpu";
  @ds = ( "mem_allocated", "mem_allocated" )                                           if $item eq "solaris_ldom_mem";
  @ds = ( "cpu_perc", "cpu_perc" ) if $item eq "s10_g_mem" || $item eq "s10_z_mem";
  @ds = ( "mem_perc", "mem_perc" ) if $item eq "s10_g_cpu" || $item eq "s10_z_cpu";

  ## prepare variables for up to 5 stream results and help variables
  my @ids  = ( "first",   "second",   "third",   "fourth",   "fifth" );
  my @rids = ( "first_r", "second_r", "third_r", "fourth_r", "fifth_r" );    # up to 5 streams help var

  foreach $rrd (@rrd_files) {                                                # LPM cycle
    chomp($rrd);
    $i++;
    $j = $i - 1;
    $rrd =~ s/:/\\:/g;

    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}=\"$rrd\":$ds[$k]:AVERAGE"; }

    if ( $i == 0 ) {
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$ids[$k]${i}"; }
      next;
    }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$rids[$k]${j},UN,$ids[$k]${i},$rids[$k]${j},IF"; }
  }
  for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$ids[$k]=$rids[$k]${i}"; }

  my $kbmb = 1024;
  if ( $item =~ "vmw-net" || $item =~ "vmnet" ) {
    $kbmb = 1000;
  }
  if ( $item eq "vmw-swap" ) {
    $kbmb = 1000;
  }
  if ( $item eq "dsarw" || $item eq "dslat" ) {
    $kbmb = 1;
  }
  if ( $item eq "phys_disk_latency" || $item eq "s2dvol_latency" ) {
    $kbmb = 0.001;
  }
  if ( $item eq "phys_disk_io" || $item eq "s2dvol_io" ) {
    $kbmb = 1;
  }
  if ( $item eq "phys_disk_data" || $item eq "s2dvol_data" ) {
    $kbmb *= 1024;
  }
  if ( $item eq "hdt_io" || ( $item =~ 'lfd_io' ) || ( $item =~ 'csv_io' ) ) {
    $kbmb = 1;
  }
  if ( $item eq "lfd_lat" || ( $item =~ 'csv_lat' ) ) {
    $kbmb = 1000;
  }
  if ( $item eq "hdt_data" || ( $item =~ 'lfd_dat' ) || ( $item =~ 'csv_dat' ) ) {
    $kbmb = 1000000;
  }
  if ( $item eq "vmw-proc" ) {
    $kbmb = 100;
  }
  if ( $item eq "vmw-ready" ) {
    $kbmb = 1;
  }
  if ( $hyperv && ( $item =~ "vmnet" || $item =~ "vmdisk" || $item =~ "hyp-disk" || $item =~ "hyp-net" ) ) {
    $kbmb *= 1000 * 1000;
  }

  $cmd .= $legend_head;

  if ( $item eq "vmw-mem" ) {
    $gprint_frm = "%6.1lf";
    $cmd .= " CDEF:usage=$ids[0],$kbmb,/,$kbmb,/";

    #    $cmd .= " CDEF:pageout_b_nf=$ids[1],$kbmb,/,$kbmb,/";
    #    $cmd .= " CDEF:pagein_b=$ids[2],$kbmb,/";  # baloon is MB ?
    #    $cmd .= " CDEF:pagein_b_nf=$ids[2],$kbmb,/";  # baloon is MB ?
    $cmd .= " CDEF:pageout_b_nf=$ids[2],$kbmb,/,$kbmb,/";    # baloon is MB ?
    $cmd .= " CDEF:pagein_b=$ids[1],$kbmb,/,$kbmb,/";        # active
    $cmd .= " CDEF:pagein_b_nf=$ids[1],$kbmb,/,$kbmb,/";     # active
    $cmd .= " AREA:usage$pastel_green:\" $leg_usage  \"";
    $cmd .= " GPRINT:usage:AVERAGE:\" $gprint_frm\"";
    $cmd .= " GPRINT:usage:MAX:$gprint_frm";
    $cmd .= " $t2";
  }
  elsif ( $item eq "vmw-proc" ) {
    $cmd .= " CDEF:CPU_usage_Proc=$ids[0],$kbmb,/";          # orig
    $cmd .= " CDEF:pageout_vcpu=$ids[1],$kbmb,/";

    $cmd .= " CDEF:vCPU=$ids[1],1,/";                                                 # number
    $cmd .= " CDEF:host_MHz=$ids[2],1000,/,1000,/";                                   # to be in MHz
    $cmd .= " CDEF:CPU_usage=$ids[3],1,/";                                            # MHz
    $cmd .= " CDEF:CPU_usage_res=CPU_usage,host_MHz,/,vCPU,/,100,*";                  # usage proc counted
                                                                                      #  $cmd .= " CDEF:pagein_b=CPU_usage_res,1,/"; # counted
                                                                                      #  $cmd .= " CDEF:pagein_b=CPU_usage_Proc,1,/"; # orig from counter metric
    $cmd .= " CDEF:pagein_b_raw=CPU_usage_Proc,UN,CPU_usage_res,CPU_usage_Proc,IF";

    #$cmd .= " CDEF:pagein_b=pagein_b_raw,UN,UNKN,pagein_b_raw,100,GT,100,pagein_b_raw,IF,IF";    # cut more than 100%, VMware does the same
    $cmd .= " CDEF:pageout_b_nf=pagein_b_raw,UN,UNKN,pagein_b_raw,100,GT,100,pagein_b_raw,IF,IF";    # cut more than 100%, VMware does the same

    #    $cmd .= " CDEF:pageout_bn=$ids[4],200,/,$ids[1],/";
    $cmd .= " CDEF:pageout_bn=$ids[4],200,/";                                                        # it is for whole VM or it would be per vCPU like -> =$ids[4],200,/,vCPU,/";

    # care for start time for CPU_ready
    my $stime = 0;
    if ( -f $CPU_ready_time_file ) {
      if ( open( FF, "<$CPU_ready_time_file" ) ) {
        $stime = (<FF>);
        close(FF);

        # print STDERR "12062 \$stime $stime\n";
        chomp $stime;
        $stime *= 1;
      }
    }

    #$cmd .= " CDEF:pageout_b_nf=TIME,$stime,LT,0,pageout_bn,IF";
    $cmd .= " CDEF:pagein_b=TIME,$stime,LT,0,pageout_bn,IF";
  }
  elsif ( $item eq "vmw-ready" ) {    # read literature demystifying-cpu-ready.pdf
    $cmd .= " CDEF:pagein_bn=$ids[0],200,/,$ids[1],/";

    # care for start time for CPU_ready
    my $stime = 0;
    if ( -f $CPU_ready_time_file ) {
      if ( open( FF, "<$CPU_ready_time_file" ) ) {
        $stime = (<FF>);
        close(FF);

        # print STDERR "12062 \$stime $stime\n";
        chomp $stime;
        $stime *= 1;
      }
    }
    $cmd .= " CDEF:pagein_b=TIME,$stime,LT,0,pagein_bn,IF";
    $cmd .= " CDEF:pageout_b_nf=$ids[1],$kbmb,/";
  }
  elsif ( $item eq "hyp-cpu" ) {

    # $cmd .= " CDEF:CPU_usage_Proc=$ids[0],$ids[1],/,$ids[2],*,100000,/,100,/";    # % to be in cores it was 25 but wrong or should it be 100 ?
    $cmd .= " CDEF:CPU_usage_Proc=$ids[0],$ids[1],/,$ids[2],*,100000,/,100,/,$ids[3],*";    # % to be in cores
                                                                                            #$cmd .= " CDEF:pageout_b_nf=$ids[1],$kbmb,/";
    $cmd .= " CDEF:vcpu=$ids[3],1,/";                                                       # number
                                                                                            #$cmd .= " CDEF:host_MHz=$ids[2],1000,/,1000,/";    # to be in MHz
                                                                                            #$cmd .= " CDEF:CPU_usage=$ids[3],1,/";  # MHz
                                                                                            #$cmd .= " CDEF:CPU_usage_res=CPU_usage,host_MHz,/,vCPU,/,100,*"; # usage proc counted
                                                                                            #    $cmd .= " CDEF:pagein_b=CPU_usage_res,1,/"; # counted
                                                                                            #    $cmd .= " CDEF:pagein_b=CPU_usage_Proc,1,/"; # orig from counter metric
                                                                                            #$cmd .= " CDEF:pagein_b_raw=CPU_usage_Proc,UN,CPU_usage_res,CPU_usage_Proc,IF";
                                                                                            # $cmd .= " CDEF:pagein_b=CPU_usage_Proc,UN,0,CPU_usage_Proc,IF";
    $cmd .= " CDEF:pagein_b=CPU_usage_Proc";

    # $cmd .= " CDEF:pagein_b=pagein_b_raw,UN,UNKN,pagein_b_raw,100,GT,100,pagein_b_raw,IF,IF";  # cut more than 100%, VMware does the same
  }
  elsif ( $item eq "solaris_zone_cpu" || $item eq "solaris_zone_os_cpu" || $item eq "solaris_zone_net" || $item eq "s10_g_cpu" || $item eq "s10_z_cpu" || $item eq "s10_g_mem" || $item eq "s10_z_mem" || $item eq "solaris_ldom_cpu" ) {
    $cmd .= " CDEF:pagein_b=$ids[0],1,/";
  }
  elsif ( $item eq "solaris_zone_mem" ) {
    $cmd .= " CDEF:phy_mem_us=$ids[0],1,/";
    $cmd .= " CDEF:cap_used_in_perc=$ids[1],1,/";
    $cmd .= " CDEF:allocated_memory=$ids[2],1,/";
    $cmd .= " CDEF:phy_mem_us_in_perc=$ids[3],1,/";
    $cmd .= " CDEF:phy_mem_used_res=phy_mem_us,1000,/,1000,/";
    $cmd .= " CDEF:res1=allocated_memory,cap_used_in_perc,/";
    $cmd .= " CDEF:res2=res1,phy_mem_us_in_perc,*";
    $cmd .= " CDEF:res3=res2,1000,/,1000,/";

  }
  elsif ( $item eq "solaris_ldom_mem" ) {
    $cmd .= " CDEF:mem_allocated=$ids[0],1,/";
    $cmd .= " CDEF:mem_allocated_a=mem_allocated,100000,/,10000,/";
  }
  else {
    if ( $filter > 0 ) {
      if ( ( $item eq "hdt_data" ) || ( $item eq "hdt_io" ) || ( $item =~ 'lfd_dat' || $item =~ 'lfd_io' ) || ( $item =~ 'csv_dat' || $item =~ 'csv_io' ) ) {
        $cmd .= " CDEF:pagein_b_tmp=$ids[0],$ids[2],/,$ids[3],*,$kbmb,/";
        $cmd .= " CDEF:pagein_b=pagein_b_tmp,$filter,GT,0,pagein_b_tmp,IF";

        # print STDERR "14466 \$item $item \$kbmb $kbmb @rrd_files\n";
        $cmd .= " CDEF:pagein_b_nf=pagein_b,-1,*";
        $cmd .= " CDEF:pageout_b_nf_tmp=$ids[1],$ids[2],/,$ids[3],*,$kbmb,/";
        $cmd .= " CDEF:pageout_b_nf=pageout_b_nf_tmp,$filter,GT,0,pageout_b_nf_tmp,IF";
      }
      elsif ( $item =~ "lfd_lat" || ( $item =~ 'csv_lat' ) ) {
        $cmd .= " CDEF:pagein_b_tmp=$ids[1],0,EQ,0,$ids[0],$ids[1],/,$ids[4],/,$kbmb,*,IF";
        $cmd .= " CDEF:pagein_b=pagein_b_tmp,$filter,GT,0,pagein_b_tmp,IF";
        $cmd .= " CDEF:pagein_b_nf=pagein_b,-1,*";
        $cmd .= " CDEF:pageout_b_nf_tmp=$ids[3],0,EQ,0,$ids[2],$ids[3],/,$ids[4],/,$kbmb,*,IF";
        $cmd .= " CDEF:pageout_b_nf=pageout_b_nf_tmp,$filter,GT,0,pageout_b_nf_tmp,IF";
      }
      else {
        $cmd .= " CDEF:pagein_b=$ids[0],$kbmb,/,$filter,GT,0,$ids[0],$kbmb,/,IF";
        $cmd .= " CDEF:pageout_b_nf=$ids[1],$kbmb,/,$filter,GT,0,$ids[1],$kbmb,/,IF";

        # $cmd .= " CDEF:pagein_b_nf=$ids[0],-$kbmb,/";
        $cmd .= " CDEF:pagein_b_nf=pagein_b,-1,*";
      }
    }
    else {
      $cmd .= " CDEF:pagein_b=$ids[0],$kbmb,/";
      $cmd .= " CDEF:pageout_b_nf=$ids[1],$kbmb,/";
      $cmd .= " CDEF:pagein_b_nf=$ids[0],-$kbmb,/";
    }
  }

  if ( !( $item eq "vmw-disk" || $item eq "vmdisk" || $item eq "vmw-net" || $item eq "vmnet" || $item eq "vmw-proc_ne" || $item eq "vmw-ready" || $item eq "hyp-net" || $item eq "hyp-mem" || $item eq "hyp-cpu" || $item eq "solaris_zone_cpu" || $item eq "solaris_zone_os_cpu" || $item eq "solaris_zone_mem" || $item eq "solaris_zone_net" || $item eq "s10_g_cpu" || $item eq "s10_z_cpu" || $item eq "s10_g_mem" || $item eq "s10_z_mem" || $item eq "solaris_ldom_cpu" || $item eq "solaris_ldom_mem" ) ) {
    if ( $item eq "vmw-proc" ) {
      $cmd .= " LINE1:pageout_b_nf#FF4040:\" $leg_write \"";
    }
    else {
      $cmd .= " LINE1:pageout_b_nf#0080FF:\" $leg_write  \"";
    }
    $cmd .= " GPRINT:pageout_b_nf:AVERAGE:\" $gprint_frm\"";
    $cmd .= " GPRINT:pageout_b_nf:MAX:$gprint_frm";
  }

  $cmd .= " $t2";
  if ( $item eq "vmw-disk" || $item eq "vmdisk" || $item eq "vmw-net" || $item eq "vmnet" || $item eq "vmw-proc" || $item eq "vmw-ready" || $item eq "hyp-net" || $item eq "hyp-mem" || $item eq "hyp-cpu" || $item eq "solaris_zone_cpu" || $item eq "solaris_zone_os_cpu" || $item eq "solaris_zone_net" || $item eq "s10_g_cpu" || $item eq "s10_z_cpu" || $item eq "s10_g_mem" || $item eq "s10_z_mem" || $item eq "solaris_ldom_cpu" ) {
    if ( $item eq "vmw-proc" ) {
      $cmd .= " LINE1:pagein_b#0080FF:\" $leg_read \"";
    }
    else {
      $cmd .= " LINE1:pagein_b#FF4040:\" $leg_read  \"";
    }

    #    if ($item eq "vmw-proc") {
    #      $cmd .= " $t2";
    #      $cmd .= " CDEF:pageout_bn=$ids[4],200,/,$ids[1],/";
    #
    #      # care for start time for CPU_ready
    #      my $stime = 0;
    #      if ( -f $CPU_ready_time_file ) {
    #        if ( open( FF, "<$CPU_ready_time_file" ) ) {
    #          $stime = (<FF>);
    #          close(FF);
    #
    #          # print STDERR "12062 \$stime $stime\n";
    #          chomp $stime;
    #          $stime *= 1;
    #        }
    #      }
    #      $cmd .= " CDEF:pageout_b=TIME,$stime,LT,0,pageout_bn,IF";
##      $cmd .= " CDEF:pageout_b_nf=$ids[1],$kbmb,/";
    #      $cmd .= " LINE1:pageout_b#0080FF:\" $leg_write  \"";
    #      $cmd .= " GPRINT:pageout_b:AVERAGE:\" $gprint_frm\"";
    #      $cmd .= " GPRINT:pageout_b:MAX:$gprint_frm";
    #    }
  }
  elsif ( $item eq "solaris_zone_mem" || $item eq "solaris_ldom_mem" ) {

    #  $cmd .= " CDEF:pagein_b_res1=pagein_b,1000,/,1000,/";
    #  $cmd .= " LINE:pagein_b_res1#FF4040:\" $leg_read  \"";
  }
  else {
    $cmd .= " LINE1:pagein_b_nf#FF4040:\" $leg_read  \"";
  }
  if ( $item eq "solaris_zone_mem" ) {
    $cmd .= " LINE:res3#000000:\" $leg_write  \"";
    $cmd .= " GPRINT:res3:AVERAGE:\" $gprint_frm\"";
    $cmd .= " GPRINT:res3:MAX:$gprint_frm";
    my $t3 = "COMMENT:\\n";
    $cmd .= " $t3";
    $cmd .= " LINE:phy_mem_used_res#FF4040:\" $leg_read  \"";
    $cmd .= " GPRINT:phy_mem_used_res:AVERAGE:\"  $gprint_frm\"";
    $cmd .= " GPRINT:phy_mem_used_res:MAX:$gprint_frm";

  }
  elsif ( $item eq "solaris_ldom_mem" ) {
    $cmd .= " LINE:mem_allocated_a#FF4040:\" $leg_read  \"";
    $cmd .= " GPRINT:mem_allocated_a:AVERAGE:\"  $gprint_frm\"";
    $cmd .= " GPRINT:mem_allocated_a:MAX:$gprint_frm";
  }
  else {
    $cmd .= " GPRINT:pagein_b:AVERAGE:\" $gprint_frm\"";
    $cmd .= " GPRINT:pagein_b:MAX:$gprint_frm";
  }
  if ( $item eq "vmw-ready" ) {

    # necessary to get MAX value to be able to prepare %RDY
    #my $r_end   = "now";
    #my $r_start = "-1$type";
    #if ( ! $start_unix eq '' && ! $end_unix eq '' ) {
    #  if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
    #    $r_start = $start_unix;
    #    $r_end   = $end_unix;
    #  }
    #}
    #RRDp::cmd qq("graph" "example.png"
    #  "--end" "$r_end" "--start" "$r_start"
    #  "DEF:usage=$rrd:CPU_ready_ms:AVERAGE"
    #  "DEF:num_cpu=$rrd:vCPU:AVERAGE"
    #  "PRINT:usage:MAX:%6.2lf"
    #  "PRINT:num_cpu:MAX:%6.0lf"
    #);
    #my $row = RRDp::read;
    #chomp($$row);
    ## print STDERR "$$row\n";
    #(undef, my $max_num, my $v_cpu) = split("\n",$$row);
    #$max_num *=1;
    #my $max_num_ax =100/ $max_num ;
    #$v_cpu *=1;
    ## print STDERR "\$max_num $max_num \$v_cpu $v_cpu\n";

    #$cmd .= " $t2";
    #$cmd .= " CDEF:pagein_b_rdy_leg=pagein_b,200,/,$v_cpu,/";
    ##$cmd .= " CDEF:pagein_b_rdy=pagein_b_rdy_leg,$max_num,*,100,/";
    #$cmd .= " LINE1:pagein_b_rdy#0000FF:\" RDY divided by vCPU              \"";
    #$cmd .= " GPRINT:pagein_b_rdy_leg:AVERAGE:\" $gprint_frm\"";
    #$cmd .= " GPRINT:pagein_b_rdy_leg:MAX:$gprint_frm";

    #$cmd .= " --right-axis $max_num_ax:0";
  }

  if ( $item eq "vmw-proc" || $item eq "vmw-ready" || $item eq "hyp-cpu" ) {
    $cmd .= " $t2";
    if ( $item eq "vmw-proc" ) {
      $cmd .= " CDEF:vcpu=pageout_vcpu,$kbmb,*";
      $cmd .= " COMMENT:\"   vCPU[units]\"";
    }
    elsif ( $item eq "vmw-ready" ) {
      $cmd .= " CDEF:vcpu=pageout_b_nf,$kbmb,*";
      $cmd .= " COMMENT:\"      vCPU[units]\"";
    }
    elsif ( $item eq "hyp-cpu" ) {

      #$cmd .= " CDEF:vcpu=pageout_b_nf,$kbmb,*";
      $cmd .= " COMMENT:\"   vCPU[units]\"";
    }

    $cmd .= " GPRINT:vcpu:AVERAGE:\"%6.0lf\"";
    $cmd .= " GPRINT:vcpu:MAX:\"%6.0lf\"";
  }
  if ( $item eq "vmw-mem" ) {
    $cmd .= " $t2";

    # find MemoryCount GB
    my $mem_count_gb = "undefined";
    my $cpu_html     = "$wrkdir/$server/$host/cpu.csv";
    my @cpu_array;
    if ( ( -f $cpu_html ) && open( FC, "< $cpu_html" ) ) {
      @cpu_array = <FC>;
      close(FC);
      chomp $lpar_slash;

      #print STDERR "15140 CPU-HTML: $cpu_html\n";
      #print STDERR "15141 ,$lpar_slash,\n";
      $lpar_slash =~ s/ \[.*\]//g;
      my ($grep_vm) = grep /^$lpar_slash,/, @cpu_array;
      if ( defined $grep_vm && $grep_vm ne '' ) {
        chomp $grep_vm;
        my ( undef, $v_cpu, $reser_mhz, undef, $shares, $shares_value, $os, $power_state, $tools_status, undef, undef, $memorySizeMB ) = split /,/, $grep_vm;
        $memorySizeMB = 0 if !defined $memorySizeMB;
        $mem_count_gb = sprintf( "$gprint_frm", $memorySizeMB / 1024 );
      }
    }
    $cmd .= " COMMENT:\"   Memory Count     $mem_count_gb\"";
  }
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  #      " VRULE:0#000000"

  $cmd =~ s/\\"/"/g;

  # print STDERR "12945 graph_vmw_disk \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_vmw_disk: $item : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub LPM_easy_trend {

  # this is for case e.g. HMC change, similar to LPM
  # join data streams from rrd files in one data_stream
  # call:
  #  my ($result_cmd,$result_stream_1,...,$result_stream_x) = LPM_easy($path_to_find_files,$data_stream_1,...,$data_stream_x);
  # no limit for x
  # $result_cmd is CMD string for RRD

  my $file_pth = shift @_;    # path to find files
  $file_pth =~ s/ /\\ /g;
  my $no_name = "";

  my @files = (<$file_pth$no_name>);    # unsorted, workaround for space in names
                                        # print STDERR "found pool files: @files\n";

  my @ds = @_;

  #print STDERR "000 in sub LPM_easy \@ds @ds\n";

  # prepare help variables
  my $prep_names = "";
  for ( my $x = 0; $x < @ds; $x++ ) { $prep_names .= "var" . $x . "," }
  my @ids = split( ",", "$prep_names" );
  $prep_names = "";
  for ( my $x = 0; $x < @ds; $x++ ) { $prep_names .= "var_r" . $x . "," }
  my @rids = split( ",", "$prep_names" );

  my $i = -1;
  my $j;
  my $rrd = "";
  my $cmd = "";

  foreach my $rrd (@files) {    # LPM alias cycle
    chomp($rrd);

    $i++;
    $j = $i - 1;
    $rrd =~ s/:/\\:/g;

    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}_1m=\"$rrd\":$ds[$k]:AVERAGE:start=-1m"; }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}_3m=\"$rrd\":$ds[$k]:AVERAGE:start=-3m"; }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}_1y=\"$rrd\":$ds[$k]:AVERAGE:start=-1y"; }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}=\"$rrd\":$ds[$k]:AVERAGE"; }

    if ( $i == 0 ) {
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}_1m=$ids[$k]${i}_1m"; }
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}_3m=$ids[$k]${i}_3m"; }
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}_1y=$ids[$k]${i}_1y"; }
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$ids[$k]${i}"; }
      next;
    }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}_1m=$rids[$k]${j}_1m,UN,$ids[$k]${i}_1m,$rids[$k]${j}_1m,IF"; }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}_3m=$rids[$k]${j}_3m,UN,$ids[$k]${i}_3m,$rids[$k]${j}_3m,IF"; }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}_1y=$rids[$k]${j}_1y,UN,$ids[$k]${i}_1y,$rids[$k]${j}_1y,IF"; }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$rids[$k]${j},UN,$ids[$k]${i},$rids[$k]${j},IF"; }
  }

  my $ret_string = "";
  for ( my $k = 0; $k < @ds; $k++ ) { $ret_string .= "$rids[$k]${i}_1m,"; }
  for ( my $k = 0; $k < @ds; $k++ ) { $ret_string .= "$rids[$k]${i}_3m,"; }
  for ( my $k = 0; $k < @ds; $k++ ) { $ret_string .= "$rids[$k]${i}_1y,"; }
  for ( my $k = 0; $k < @ds; $k++ ) { $ret_string .= "$rids[$k]${i},"; }

  #print STDERR "001 $cmd,split(",",$ret_string)\n";
  return ( $cmd, split( ",", $ret_string ) );
}

# it identifies all files under certain server and returns the one with the most recent timestamp
# it is just to find out most recent rrd file for the last_time purposes

sub rrd_file_actual {
  my ( $rrd_file, $lpm_find ) = @_;

  # print STDERR "12163 detail-graph-cgi.pl sub rrd_file_actual \$rrd_file $rrd_file\n";
  # LPM identifies all servers, however not all HMC under servers
  # Add here data from all HMcs
  # take care if NMON or not
  my $lpar_name      = basename($rrd_file);
  my $server_dir_tmp = dirname($rrd_file);
  my $server_dir     = dirname($server_dir_tmp);
  my $file_pth       = "$server_dir/*/$lpar_name";

  $file_pth =~ s/ /\\ /g;
  my $no_name          = "";
  my $rrd_upd_time_max = 0;

  my @files = (<$file_pth$no_name>);    # unsorted, workaround for space in names
  foreach my $rrd_act (@files) {
    chomp($rrd_act);
    my $rrd_upd_time = ( stat("$rrd_act") )[9];
    if ( $rrd_upd_time < $rrd_upd_time_max ) {
      next;
    }
    if ( ( $rrd_file =~ "--NMON--" && $rrd_act =~ "--NMON--" ) || ( $rrd_file !~ "--NMON--" && $rrd_act !~ "--NMON--" ) ) {
      $rrd_upd_time_max = $rrd_upd_time;
      $rrd_file         = $rrd_act;
    }
  }

  # print STDERR "12188 detail-graph-cgi.pl sub rrd_file_actual \$rrd_file $rrd_file\n";

  return $rrd_file;
}

sub graph_trendcluster {
  my $host     = shift;
  my $server   = shift;
  my $lpar     = shift;
  my $type     = shift;
  my $name_out = shift;
  my $type_sam = shift;
  my $upper    = shift;
  my $detail   = shift;
  my $t        = "COMMENT: ";
  my $t2       = "COMMENT:\\n";
  my $step_new = $step;
  my $xgrid    = "--x-grid=MONTH:1:MONTH:1:MONTH:1:0:%b";

  if ( $upper eq '' || $upper == 0 ) {
    $upper = 0.1;
  }

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt = " ";
  }

  my $vertical_label = "--vertical-label=\"CPU GHz\"";
  my $rrd            = "";
  my $header         = "";

  if ( $item eq "trendcluster" ) {

    #$host =~ s/^cluster_//;
    #$header = "Cluster: $host :$last_txt year";
    $header = "CPU pool :$last_txt year";
    $rrd    = "$wrkdir/$server/$host/cluster.rrc";
  }
  elsif ( $item eq "trendrp" ) {

    #$header = "Resourcepool: $lpar :$last_txt year";
    $header = "CPU pool :$last_txt year";
    $rrd    = "$wrkdir/$server/$host/$lpar.rrc";
  }
  elsif ( $item eq "trendvm" ) {
    $header = "VM : $last_txt year";
    $rrd    = "$wrkdir/vmware_VMs/$lpar.rrm";
  }
  elsif ( $item eq "trendvmem" ) {
    $header         = "VM : $last_txt year";
    $rrd            = "$wrkdir/vmware_VMs/$lpar.rrm";
    $vertical_label = "--vertical-label=\"Memory in GBytes\"";
  }
  elsif ( $item eq "trendrpmem" ) {
    $header         = "Resourcepool : $last_txt year";
    $rrd            = "$wrkdir/$server/$host/$lpar.rrc";
    $vertical_label = "--vertical-label=\"Memory in GBytes\"";
  }
  elsif ( $item eq "trendclmem" ) {
    $header         = "Cluster : $last_txt year";
    $rrd            = "$wrkdir/$server/$host/cluster.rrc";
    $vertical_label = "--vertical-label=\"Memory in GBytes\"";
  }
  else {
    error("creating graph : $host:$server:$lpar:$type_sam:$type:$item:trend");
    return;
  }

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # Trend for yearly chart 1y back  + 1y forward
  #print "creating graph : $host:$server:$lpar:$type_sam:$type:trend\n" if $DEBUG ;
  #error ( "creating graph : $host:$server:$lpar:$type_sam:$type:trend");

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  $rrd =~ s/:/\\:/g;
  $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );

  my $cmd .= "$graph_cmd \"$name_out\"";
  $cmd    .= " --title \"$header - trend\"";
  $cmd    .= " --start now-1$type";
  $cmd    .= " --end now+1$type";
  $cmd    .= " --imgformat PNG";
  $cmd    .= " --slope-mode";
  $cmd    .= " $no_minor";
  $cmd    .= " --width=$width_trend";
  $cmd    .= " --height=$height";
  $cmd    .= " --step=$step";
  $cmd    .= " --lower-limit=0.00";
  $cmd    .= " --color=BACK#$pic_col";
  $cmd    .= " --color=SHADEA#$pic_col";
  $cmd    .= " --color=SHADEB#$pic_col";
  $cmd    .= " --color=CANVAS#$pic_col";
  $cmd    .= " --alt-autoscale-max";
  $cmd    .= " --upper-limit=0.1";
  $cmd    .= " $vertical_label";
  $cmd    .= " --units-exponent=1.00";
  $cmd    .= " --alt-y-grid";
  $cmd    .= " $no_legend";
  $cmd    .= " $disable_rrdtool_tag";
  $cmd    .= " $font_def";
  $cmd    .= " $font_tit";
  $cmd    .= " $xgrid";

  $cmd .= " DEF:cpu_MHz=\"$rrd\":CPU_total_MHz:AVERAGE"   if $item eq "trendcluster";
  $cmd .= " DEF:cpu_MHz=\"$rrd\":CPU_reservation:AVERAGE" if $item eq "trendrp";
  $cmd .= " CDEF:cur=cpu_MHz,1000,/"                      if ( $item eq "trendrp" || $item eq "trendcluster" );

  $cmd .= " DEF:cpu_limit=\"$rrd\":CPU_limit:AVERAGE" if $item eq "trendrp";
  $cmd .= " CDEF:cpu_limg=cpu_limit,1000,/"           if $item eq "trendrp";

  my $usage = "CPU_usage_MHz";
  $usage = "CPU_usage"        if $item eq "trendvm";
  $usage = "Memory_active"    if $item eq "trendvmem";
  $usage = "Memory_active_KB" if $item eq "trendrpmem";
  $usage = "Memory_active_KB" if $item eq "trendclmem";
  $cmd .= " DEF:mem_gra=\"$rrd\":Memory_granted:AVERAGE" if $item eq "trendvmem";
  $cmd .= " CDEF:mem_g=mem_gra,1000000,/"                if $item eq "trendvmem";

  my $kbmb = 1000;
  $kbmb = 1000000 if $item eq "trendvmem";
  $kbmb = 1000000 if $item eq "trendrpmem";
  $kbmb = 1000000 if $item eq "trendclmem";

  $cmd .= " DEF:cpuutiltot_MHz_1m=\"$rrd\":$usage:AVERAGE:start=-1m";
  $cmd .= " CDEF:utiltotd=cpuutiltot_MHz_1m,$kbmb,/";
  $cmd .= " DEF:cpuutiltot_MHz_3m=\"$rrd\":$usage:AVERAGE:start=-3m";
  $cmd .= " CDEF:utiltotm=cpuutiltot_MHz_3m,$kbmb,/";
  $cmd .= " DEF:cpuutiltot_MHz_y=\"$rrd\":$usage:AVERAGE:start=-1y";
  $cmd .= " CDEF:utiltoty=cpuutiltot_MHz_y,$kbmb,/";
  $cmd .= " DEF:cpuutiltot_MHz=\"$rrd\":$usage:AVERAGE";
  $cmd .= " CDEF:utiltot=cpuutiltot_MHz,$kbmb,/";

  $cmd .= " VDEF:Dd=utiltotd,LSLSLOPE";
  $cmd .= " VDEF:Hd=utiltotd,LSLINT";
  $cmd .= " CDEF:utiltottrendd=utiltotd,POP,Dd,COUNT,*,Hd,+";
  $cmd .= " VDEF:Dm=utiltotm,LSLSLOPE";
  $cmd .= " VDEF:Hm=utiltotm,LSLINT";
  $cmd .= " CDEF:utiltottrendm=utiltotm,POP,Dm,COUNT,*,Hm,+";
  $cmd .= " VDEF:Dy=utiltoty,LSLSLOPE";
  $cmd .= " VDEF:Hy=utiltoty,LSLINT";
  $cmd .= " CDEF:utiltottrendy=utiltoty,POP,Dy,COUNT,*,Hy,+";
  $cmd .= " COMMENT:\"   Average   \\n\"";

  $cmd .= " AREA:cur$pastel_green:\" Total/reservation GHz  \"" if ( $item eq "trendrp" || $item eq "trendcluster" );
  $cmd .= " GPRINT:cur:AVERAGE:\" %6.2lf\""                     if ( $item eq "trendrp" || $item eq "trendcluster" );
  $cmd .= " $t2"                                                if ( $item eq "trendrp" || $item eq "trendcluster" );

  #    $cmd .= " AREA:mem_g#00FF00:\" Memory granted GB     \"" if $item eq "trendvmem";
  #    $cmd .= " GPRINT:mem_g:AVERAGE:\" %6.2lf\""              if $item eq "trendvmem";
  #    $cmd .= " $t2"                                           if $item eq "trendvmem";

  $cmd .= " LINE1:cpu_limg#000000:\" Limit in GHz           \"" if $item eq "trendrp";
  $cmd .= " GPRINT:cpu_limg:AVERAGE:\" %6.2lf\""                if $item eq "trendrp";
  $cmd .= " $t2"                                                if $item eq "trendrp";

  my $unit = "GHz";
  $unit = "GB" if $item eq "trendvmem";
  $unit = "GB" if $item eq "trendrpmem";
  $unit = "GB" if $item eq "trendclmem";

  $cmd .= " LINE1:utiltot#FF0000:\" Utilization in $unit     \"";
  $cmd .= " GPRINT:utiltot:AVERAGE:\" %6.2lf\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:utiltottrendd#0088FF:\" Utilization in $unit       - last 1 month trend\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:utiltottrendm#80FFFF:\" Utilization in $unit       - last 3 months trend\"";
  $cmd .= " $t2";
  $cmd .= " LINE2:utiltottrendy#FF8080:\" Utilization in $unit       - last year trend\"";
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_AS400_jobs {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t          = "COMMENT:\" \"";
  my $t2         = "COMMENT:\"\\n\"";
  my $step_new   = $step;
  my $last       = "COMMENT: ";
  my $head       = "COMMENT:                            Average   Max\\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  # due to historical reports where is specific time passed
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT:\" \\g\"";    # just a trick to place there something otherwise rrdtool complains
    }
  }

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST: %4.0lf";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_AS400_jobs: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;                    # some workaround, it should not go here
  }

  my $rrd = "$wrkdir/$server/$host/$lpar--AS400--/S0200ASPJOB.mmm";

  #my $rrd = "$wrkdir/$server/$host/$lpar/S0200ASPJOB.mmm";
  if ( $item eq "ADDR" ) {
    $rrd = "$wrkdir/$server/$host/$lpar--AS400--/S0200ADDR.mmm";

    #$rrd = "$wrkdir/$server/$host/$lpar/S0200ADDR.mmm";
  }

  # print STDERR "10753 detail-graph-cgi.pl \$rrd $rrd\n";

  if ( !-f "$rrd" ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $lpar_slash = $lpar;    # = human_vmware_name($lpar);

  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  $lpar_slash_nmon =~ s/\(.*\)//;

  my $header_prefix  = "LPAR :";
  my $head_pref      = "";
  my $legend_head    = " COMMENT:\"                     Avrg     Max\\n\"";
  my $vertical_label = "--vertical-label=\"JOBS & THREADS\"";
  my $leg_write      = "JOBS Total  ";
  my $leg_read       = "JOBS active ";
  my $leg_usage      = "Threads     ";
  my $gprint_frm     = "%6.0lf";
  my $upper_limit    = 0.1;

  if ( $item eq "ASP" ) {
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[GB]            Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=GB";
    $leg_write      = "Total";
    $leg_read       = "Used ";
    $leg_usage      = "";
  }

  if ( $item eq "ADDR" ) {
    $head_pref      = "";
    $legend_head    = " COMMENT:\"[PERCENT]            Avrg      Max\\n\"";
    $vertical_label = "--vertical-label=%";
    $leg_write      = "Total";
    $leg_read       = "Used ";
    $leg_usage      = "";
  }

  my $last_txt             = " last ";
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  #  my $header_prefix = "VM :";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
    $last_txt       = "";
    if ( $item eq "S0200ASPJOB" ) {
      $head_pref            = "JOBS";
      $lpar_slash_nmon_head = "" if $server eq "as400";
    }
    $header_prefix = $head_pref;
    if ( $wpar == 1 ) {
      $header_prefix = $head_pref;
    }
  }

  my $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
    }
  }

  if ( $type =~ "d" ) {
    my $rrd_last = rrd_file_actual("$rrd");
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;

          $last = "";

          #if ( $m_arr[2] > 0 ) {
          #  my $last_mem = sprintf( "%6.2d",$m_arr[2]) / 1024;
          #  my $last_mem_g = sprintf( "%.2f",$m_arr[2] / 1024);
          #  $last ="COMMENT:Last memory consumption in GB         $last_mem_g";
          #}
        }
      }
    }
  }

  # for LPM
  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;    #actual is the first
                           #lpm_find_files ($wrkdir,$server,$host,$lpar,"\$lpar_slash",$lpm_suff,$type_sam,$type,"",\@rrd_files,$cgi);
                           # print STDERR "10543 detail-graph-cgi.pl lpm_find_files is returning array @rrd_files\n";

  # print STDERR "graphing AS400_jobs   : $rrd: $host:$server:$lpar_slash:$type_sam:$type:$start_time:$end_time\n";

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $cmd = "";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=$upper_limit";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";
  $cmd .= " --base=1024";

  my $i = -1;
  my $j;

  ## define data stream names
  my @ds = ( "par3", "par4", "par5", "par6", "par7", "par8" );

  ## prepare variables for up to 6 stream results and help variables
  my @ids  = ( "first",   "second",   "third",   "fourth",   "fifth",   "sixth" );
  my @rids = ( "first_r", "second_r", "third_r", "fourth_r", "fifth_r", "sixth_r" );    # up to 6 streams help var

  foreach $rrd (@rrd_files) {                                                           # LPM cycle
    chomp($rrd);
    $i++;
    $j = $i - 1;
    $rrd =~ s/:/\\:/g;

    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}=\"$rrd\":$ds[$k]:AVERAGE"; }

    if ( $i == 0 ) {
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$ids[$k]${i}"; }
      next;
    }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$rids[$k]${j},UN,$ids[$k]${i},$rids[$k]${j},IF"; }
  }
  for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$ids[$k]=$rids[$k]${i}"; }

  my $kbmb = 1024;
  if ( $item =~ "vmw-net" || $item =~ "vmnet" ) {
    $kbmb = 1000;
  }
  if ( $item eq "vmw-swap" ) {
    $kbmb = 1000;
  }
  if ( $item eq "dsarw" ) {
    $kbmb = 1;
  }
  if ( $item eq "vmw-proc" ) {
    $kbmb = 100;
  }
  if ( $item eq "vmw-ready" ) {
    $kbmb = 1;
  }

  $cmd .= $legend_head;

  if ( $item eq "S0200ASPJOB" ) {
    $cmd .= " CDEF:jobs_total=$ids[0]";
    $cmd .= " CDEF:jobs_activ=$ids[4]";

    # value threads is in S0200PROCS:6
    # so it is necessary the same precedure - LPM
    # for LPM
    @rrd_files = ();
    $lpm_suff  = "rrl";
    $cgi       = 0;
    $rrd       = "$wrkdir/$server/$host/$lpar--AS400--/S0200PROCS.mmm";

    #$rrd = "$wrkdir/$server/$host/$lpar/S0200PROCS.mmm";
    $rrd_files[0] = $rrd;    #actual is the first
                             #lpm_find_files ($wrkdir,$server,$host,$lpar,"\$lpar_slash",$lpm_suff,$type_sam,$type,"",\@rrd_files,$cgi);
                             # print STDERR "11723 detail-graph-cgi.pl lpm_find_files is returning array @rrd_files\n";

    # print STDERR "11725 graphing AS400_jobs   : $rrd: $host:$server:$lpar_slash:$type_sam:$type:$start_time:$end_time\n";
    $i = -1;

    #$j ;

    ## define data stream names
    @ds   = ("par8");
    @ids  = ("seventh");
    @rids = ("seventh_r");    # up to 1 streams help var

    foreach $rrd (@rrd_files) {    # LPM cycle
      chomp($rrd);
      $i++;
      $j = $i - 1;
      $rrd =~ s/:/\\:/g;

      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " DEF:$ids[$k]${i}=\"$rrd\":$ds[$k]:AVERAGE"; }

      if ( $i == 0 ) {
        for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$ids[$k]${i}"; }
        next;
      }
      for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$rids[$k]${i}=$rids[$k]${j},UN,$ids[$k]${i},$rids[$k]${j},IF"; }
    }
    for ( my $k = 0; $k < @ds; $k++ ) { $cmd .= " CDEF:$ids[$k]=$rids[$k]${i}"; }

    $cmd .= " CDEF:threads=$ids[0]";
    $cmd .= " LINE1:threads#00FF00:\" THREADS     \"";
    $cmd .= " GPRINT:threads:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:threads:MAX:%6.0lf";
    $cmd .= " $t2";
    $cmd .= " LINE1:jobs_total#0080FF:\" JOBS total  \"";
    $cmd .= " GPRINT:jobs_total:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:jobs_total:MAX:%6.0lf";
    $cmd .= " $t2";
    $cmd .= " LINE1:jobs_activ#FF4040:\" JOBS active \"";
    $cmd .= " GPRINT:jobs_activ:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:jobs_activ:MAX:%6.0lf";
    $cmd .= " $t2";
  }
  elsif ( $item eq "ASP" ) {
    $cmd .= " CDEF:total_MB=$ids[1]";
    $cmd .= " CDEF:total=total_MB,1024,/";
    $cmd .= " CDEF:used_proc=$ids[2]";
    $cmd .= " CDEF:used=total,100,/,used_proc,*";
    $cmd .= " AREA:total#00FF00:\" TOTAL   \"";
    $cmd .= " GPRINT:total:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:total:MAX:%6.0lf";
    $cmd .= " $t2";
    $cmd .= " AREA:used#FF4040:\" USED    \"";
    $cmd .= " GPRINT:used:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:used:MAX:%6.0lf";
    $cmd .= " $t2";
  }
  elsif ( $item eq "ADDR" ) {
    $cmd .= " CDEF:perm=$ids[0]";
    $cmd .= " CDEF:temp=$ids[1]";
    $cmd .= " CDEF:temp_256MB=$ids[2]";
    $cmd .= " CDEF:temp_4GB=$ids[3]";
    $cmd .= " CDEF:perm_256MB=$ids[4]";
    $cmd .= " CDEF:perm_4GB=$ids[5]";

    #    $cmd .= " CDEF:total=total_MB,1024,/";
    #    $cmd .= " CDEF:used_proc=$ids[2]";
    #    $cmd .= " CDEF:used=total,100,/,used_proc,*";
    $cmd .= " LINE1:perm#FF0000:\" PERM         \"";         #"#FF0000", "#0000FF", "#C0C0C0", "#FFFF00", "#00FFFF", "#FFA500", "#00FF00", "#808080", "#FF00FF", "#800080"
    $cmd .= " GPRINT:perm:AVERAGE:\" %6.3lf\"";
    $cmd .= " GPRINT:perm:MAX:%6.3lf";
    $cmd .= " $t2";
    $cmd .= " LINE1:temp#0000FF:\" TEMP         \"";
    $cmd .= " GPRINT:temp:AVERAGE:\" %6.3lf\"";
    $cmd .= " GPRINT:temp:MAX:%6.3lf";
    $cmd .= " $t2";
    $cmd .= " LINE1:temp_256MB#C0C0C0:\" temp 256MB   \"";
    $cmd .= " GPRINT:temp_256MB:AVERAGE:\" %6.3lf\"";
    $cmd .= " GPRINT:temp_256MB:MAX:%6.3lf";
    $cmd .= " $t2";
    $cmd .= " LINE1:temp_4GB#FFFF00:\" temp 4GB     \"";
    $cmd .= " GPRINT:temp_4GB:AVERAGE:\" %6.3lf\"";
    $cmd .= " GPRINT:temp_4GB:MAX:%6.3lf";
    $cmd .= " $t2";
    $cmd .= " LINE1:perm_256MB#00FFFF:\" perm 256MB   \"";
    $cmd .= " GPRINT:perm_256MB:AVERAGE:\" %6.3lf\"";
    $cmd .= " GPRINT:perm_256MB:MAX:%6.3lf";
    $cmd .= " $t2";
    $cmd .= " LINE1:perm_4GB#FFA500:\" perm 4GB     \"";
    $cmd .= " GPRINT:perm_4GB:AVERAGE:\" %6.3lf\"";
    $cmd .= " GPRINT:perm_4GB:MAX:%6.3lf";
    $cmd .= " $t2";

  }
  else {
    error( "not known item $item " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  #      " VRULE:0#000000";

  $cmd =~ s/\\"/"/g;

  # print STDERR "$cmd\n";
  my $ret = "";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : AS400_jobs: $item : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_as4job {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $upper       = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;             # 1 do not show entitle area
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $as4job      = shift;             # rrd filename of job
  my $t           = "COMMENT:\" \"";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT:\" \"";
  my $rigid       = "\n --rigid";

  # print STDERR "sub graph_as4job ,$host,$server,$lpar,$type,$item,$type_sam,$graph_hours,$as4job\n";
  # $item as4job_dbusy, as4job_diskio_sec

  # $lpar .= "--AS400--";

  my $in_cores     = 0;    # graph for vmware is in MHz
  my $one_core_hz  = 1;
  my $one_core_mhz = 1;
  my $one_core_ghz = 1;

  my $keep_virtual = 0;
  if ( $ENV{KEEP_VIRTUAL} ) {
    $keep_virtual = $ENV{KEEP_VIRTUAL};    # keep number of virt processors in RRD --> etc/.magic
  }
  else {
    $keep_virtual = 0;
  }

  # print STDERR "in graph_as4job \$upper $upper\n";

  if ( $upper eq '' || $upper =~ "entitle" || $upper == 0 ) {    # entitle is badly sent param
    $upper = 0.1;
  }

  my $units_exponent = "--units-exponent=1.00";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_as4job: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
    }
  }

  my $header_prefix = "JOB:";
  $header_prefix = "DISK:" if $item =~ /dbusy/ || $item =~ /diskio_sec/;

  my $rrd = "$wrkdir/$server/$host/$lpar--AS400--/JOB/$as4job.mmc";
  $rrd = "$wrkdir/$server/$host/$lpar--AS400--/DSK/$as4job.mmc" if $item =~ /dbusy/ || $item =~ /diskio_sec/;

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;
  $lpar_slash_nmon =~ s/--AS400--//;
  $lpar_slash_nmon .= " : $as4job";

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt      = " ";
    $header_prefix = "";
  }

  my $header = "$header_prefix $lpar_slash_nmon :$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
    }
  }

  #  my $vcpu = 0;

  if ( ( $type =~ "d" && $graph_hours == 0 ) || $vmware ) {
    my $rrd_last = rrd_file_actual("$rrd");
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    if ( $type =~ "d" ) {
      $l =~ s/:/\\:/g;
      $t = "COMMENT:Updated\\:\" $l \"";
    }

    # get LAST value from RRD
    #my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    #RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    #my $row = RRDp::read;
    #chomp($$row);
    #my @row_arr = split(/\n/,$$row);
    # #print STDERR "12092 detail-graph-cgi.pl \@row_arr @row_arr\n";
    #my $m = "";
    #my $i = 0;

    #foreach $m (@row_arr) {
    #  chomp($m);
    #   $i++;
    #   if ( $i == 3 ) {
    #     my @m_arr = split(/ /,$m);
    #     # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
    #     if ($m_arr[1] =~ /\d/ && $m_arr[5] =~ /\d/ && $m_arr[6] =~ /\d/ ) {
    #       # print STDERR "\n$m_arr[1] $m_arr[5] $m_arr[6]";# if $DEBUG ;
    #       my $util = "";
    #       $util = sprintf ("%5.2f",$m_arr[1]) if $item eq "as4job_proc";
    #       $util = sprintf ("%5.2f",$m_arr[6]/1000) if $item eq "as4job_core";
    #       $util = sprintf ("%5.2f",$m_arr[5]) if $item eq "as4job_disk";
    #       $last ="COMMENT:\"Last utilization      $util\"";
    #     }
    #   }
    #}
  }

  #  my $start_time = "now-1$type";
  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $v_label = "CPU %";
  $v_label = "CPU cores"   if $item eq "as4job_core";
  $v_label = "Disk IO"     if $item eq "as4job_disk";
  $v_label = "Disk Busy %" if $item eq "as4job_dbusy";
  $v_label = "Disk IO/sec" if $item eq "as4job_diskio_sec";

  my $vertical_label = "--vertical-label=\"$v_label\"";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  # print STDERR " detail-graph-cgi.pl 11276 creating graph : $host:$server:$lpar_slash:$type_sam:$type:$name_out:$rrd:$entitle:$item\n"; # if $DEBUG ;

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $cmd = "";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";

  #  $cmd .= " --upper-limit=$upper";
  $cmd .= " $vertical_label";
  $cmd .= " $units_exponent";        #--units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  #  for LPM
  my @rrd_files;
  my $lpm_suff = "rrl";
  my $cgi      = 0;
  $rrd_files[0] = $rrd;              #actual is the first

  lpm_find_files( $wrkdir, $server, $host, $lpar, "\$lpar_slash", $lpm_suff, $type_sam, $type, "", \@rrd_files, $cgi );

  #print STDERR "lpm_find_files is returning @rrd_files\n";

  my $i = -1;                        # iterators for LPM cycle
  my $j;

  my $cores_mhz = "cores";           # for vmware graph legend
  if ( $in_cores == 2 ) {
    $cores_mhz = "     ";
  }
  my $gprint_form = "8.2lf";

  foreach my $rrd_tot (@rrd_files) {    # LPM cycle
    chomp($rrd_tot);

    # for AS400 LPM is not OK
    # print STDERR "21458 \$item $item \$rrd_tot $rrd_tot\n";
    if ( $item eq "as4job_proc" || $item eq "as4job_core" || $item eq "as4job_disk" || $item eq "as4job_dbusy" ) {
      if ( $rrd_tot !~ /\.mmc$/ ) {
        next;
      }
    }

    # LPM identifies all servers, however not all HMC under servers
    # Add here data from all HMcs
    my $lpar_name  = basename($rrd_tot);
    my $server_dir = dirname($rrd_tot) . "/..";
    my $file_pth   = "$server_dir/*/$lpar_name";

    $file_pth =~ s/ /\\ /g;
    my $no_name = "";

    my @files = (<$file_pth$no_name>);    # unsorted, workaround for space in names
    foreach $rrd (@files) {               # LPM alias cycle
      chomp($rrd);

      $i++;
      $j = $i - 1;
      $rrd =~ s/:/\\:/g;

      $cmd .= " DEF:cur${i}=\"$rrd\":par3:AVERAGE" if $item eq "as4job_proc" || $item eq "as4job_dbusy";
      $cmd .= " DEF:cur${i}=\"$rrd\":par8:AVERAGE" if $item eq "as4job_core";
      $cmd .= " DEF:cur${i}=\"$rrd\":par7:AVERAGE" if $item eq "as4job_disk";
      $cmd .= " DEF:cur${i}=\"$rrd\":par4:AVERAGE" if $item eq "as4job_diskio_sec";

      if ( $i == 0 ) {
        $cmd .= " CDEF:curr${i}=cur${i}";
        next;
      }
      $cmd .= " CDEF:curr${i}=curr${j},UN,cur${i},curr${j},IF";
    }
  }
  if ( $item eq "as4job_core" ) {
    $cmd .= " CDEF:cur=curr${i},1000,/";
  }
  else {
    $cmd .= " CDEF:cur=curr${i}";
  }

  #        $cmd .= " CDEF:curgt${i}=cur${i},1,/";
  $cmd .= " CDEF:curg=cur,UN,0,cur,IF,1,/";    #avg across entire season - d,w

  $cmd .= " COMMENT:\"                 AvgRun    Avg      Max\\n\"";

  if ( $entitle != 1 ) {

    # default one, show entitlement area
    # else do not show entitled area --> customers request

    $cmd .= " LINE:cur#FF0000:\" Utilization\"";
    $cmd .= " GPRINT:cur:AVERAGE:\" %5.2lf\"";
    $cmd .= " GPRINT:curg:AVERAGE:\" %5.2lf\"";
    $cmd .= " GPRINT:cur:MAX:\" %5.2lf\"";
    $cmd .= " $t2";
  }

  $cmd .= " $last";
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  #  "VRULE:0#000000"

  $cmd =~ s/\\"/"/g;

  # print STDERR "$cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_as4job : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_aspmem {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT: ";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT: ";
  my $head        = "COMMENT:                            Average   \\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph ASP MEM: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $lpar_orig   = $lpar;
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";

  my $vertical_label = "--vertical-label=GBytes";
  my $header         = "ASP : last $text";
  if ( $item =~ m/cap_free/ ) {
    $header = "ASP Free: $lpar : last $text";
  }
  elsif ( $item =~ m/cap_used/ ) {
    $header = "ASP Used: $lpar : last $text";
  }
  elsif ( $item =~ m/cap_proc/ ) {
    $header         = "ASP percent : last $text";
    $vertical_label = "--vertical-label=percent";
    $upper_limit    = "100";
  }
  elsif ( $item =~ m/dsk_svc_as/ ) {
    $header         = "DSK SVC: $lpar : last $text";
    $vertical_label = "--vertical-label=millisec";
  }
  elsif ( $item =~ m/dsk_wait_as/ ) {
    $header         = "DSK WAIT: $lpar : last $text";
    $vertical_label = "--vertical-label=millisec";
  }
  elsif ( $item =~ m/dsk_latency/ ) {
    $header         = "DSK LATENCY: $lpar : last $text";
    $vertical_label = "--vertical-label=millisec";
  }

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";        # nope string
    $header         = "ASP Memory: $text";
    my $lpart = ": $lpar ";
    $lpart = "" if $server eq "as400";
    if ( $item =~ m/cap_free/ ) {
      $header = "ASP Free$lpart:$text";
    }
    elsif ( $item =~ m/cap_used/ ) {
      $header = "ASP Used$lpart:$text";
    }
    elsif ( $item =~ m/cap_proc/ ) {
      $header = "ASP %$lpart:$text";
    }
    elsif ( $item =~ m/dsk_svc_as/ ) {
      $header = "DSK SVC$lpart:$text";
    }
    elsif ( $item =~ m/dsk_wait_as/ ) {
      $header = "DSK WAIT$lpart:$text";
    }
    elsif ( $item =~ m/dsk_latency/ ) {
      $header = "DSK LAT$lpart:$text";
    }
  }
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "";            # just a trick

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "ASP : $start_human - $end_human";
    }
  }

  my $aspdir = "$wrkdir/$server/$host/$lpar--AS400--/ASP";
  if ( $item =~ m/dsk_svc_as/ || $item =~ m/dsk_wait_as/ || $item =~ m/dsk_latency/ ) {
    $aspdir = "$wrkdir/$server/$host/$lpar--AS400--/LTC";
  }
  my @files = "";
  if ( $type_sam =~ "m" || $type_sam =~ "x" ) {
    opendir( DIR, "$aspdir" ) || error( " directory does not exists : $aspdir" . __FILE__ . ":" . __LINE__ ) && return 0;
    my @files_unsorted = ();
    if ( $item =~ m/dsk_svc_as/ || $item =~ m/dsk_wait_as/ || $item =~ m/dsk_latency/ ) {
      @files_unsorted = grep( /LTC.*Parm1\.mmc$/, readdir(DIR) );
    }
    else {
      @files_unsorted = grep( /Parm3\.mmc$/, readdir(DIR) );
    }
    closedir(DIR);
    @files = sort { lc $a cmp lc $b } @files_unsorted;
  }

  # print STDERR "16351 detail-graph-cgi.pl $wrkdir/$server/$host/$lpar ,@files,\n";
  my $file = "";
  my $i    = 0;
  my $cmd  = "";
  my $j    = 0;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \\\"$name_out\\\"";
  $cmd .= " --title \\\"$header\\\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=$upper_limit";
  $cmd .= " \\\"$vertical_label\\\"";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  my $alloc_free = "allocated memory in GB\\:";
  $alloc_free = "free memory in GB\\:     "  if $item eq "cap_free";
  $alloc_free = "used memory in percent\\: " if $item eq "cap_proc";

  if ( $item =~ m/dsk_svc_as/ ) {
    $cmd .= " COMMENT:\\\"Disk service time in millisec       average    maximum\\l\\\""          if "$type" !~ "d";
    $cmd .= " COMMENT:\\\"Disk service time in millisec       average    maximum     last\\l\\\"" if "$type" =~ "d";
  }
  elsif ( $item =~ m/dsk_wait_as/ ) {
    $cmd .= " COMMENT:\\\"Disk wait time in millisec          average    maximum\\l\\\""          if "$type" !~ "d";
    $cmd .= " COMMENT:\\\"Disk wait time in millisec          average    maximum     last\\l\\\"" if ( "$type" =~ "d" );
  }
  elsif ( $item =~ m/dsk_latency/ ) {
    $cmd .= " COMMENT:\\\"Disk latency time in millisec       average    maximum\\l\\\""          if "$type" !~ "d";
    $cmd .= " COMMENT:\\\"Disk latency time in millisec       average    maximum     last\\l\\\"" if ( "$type" =~ "d" );
  }
  else {
    if ( "$type" =~ "d" ) {
      $cmd .= " COMMENT:\\\"Current $alloc_free    average    maximum     last\\l\\\"";
    }
    else {
      $cmd .= " COMMENT:\\\"Current $alloc_free    average    maximum\\l\\\"";
    }
  }
  my $gtype = "AREA";

  my $found_at_least_one = 0;
  my @bubble_info        = ();
  my $last_update        = 0;
  my $found              = -1;    # colors

  foreach $file (@files) {
    chomp($file);

    # prepare color according ASP number
    #my $found = "";
    #if ( $item =~ m/dsk_svc_as/ || $item =~ m/dsk_wait_as/) {
    #  $found = $file;
    #  $found =~ s/LTC//;
    #  $found =~ s/Parm1\.mmc//;
    #  $found = ($found + 1 ) % ( $color_max + 1 );
    #}
    #else {
    #  $found = ( ( substr $file, 3, 3 ) + 1 ) % ( $color_max + 1 );    # ASP033 see 033 as color, +1 cus color 33 is not nice
    #}
    $found++;
    $found = $found % ( $color_max + 1 );

    $found_at_least_one = 1;

    # avoid old lpars which do not exist in the period
    my $rrd_upd_time = ( stat("$aspdir/$file") )[9];
    if ( $rrd_upd_time < $req_time ) {
      next;
    }

    # find date of latest file
    # prepare string in format: Updated: Fri Jul 17 10:40:01 2015

    if ( $rrd_upd_time > $last_update ) {
      $last_update = $rrd_upd_time;
    }

    my $ltime = localtime($last_update);
    $ltime =~ s/:/\\\:/g;
    $t = "COMMENT:Updated\\\: $ltime ";

    $lpar = $file;
    $lpar =~ s/Parm3.rrc//;
    my $lpar_space_proc = $lpar;
    my $lpar_space      = $lpar;
    $lpar_space =~ s/\&\&1/\//g;
    my $lpar_space_orig = $lpar_space;    # for cap_
    $lpar_space_orig =~ s/Parm3.mmc//;
    $lpar_space_orig =~ s/:/\\:/g;

    # add spaces to lpar name to have 25 chars total (for formating graph legend)
    for ( my $k = length($lpar_space); $k < 25; $k++ ) {
      $lpar_space .= " ";
    }

    my $fake_name = "";
    if ( $item eq "dsk_svc_as" || $item eq "dsk_wait_as" || $item eq "dsk_latency" ) {
      $gtype = "LINE";
      my $rrd = "$aspdir/$file";

      #( $fake_name, $bubble_info[$i] ) = asp_fake_name($rrd);
      #$bubble_info[$i] =~ s/:/\\:/g;
      $bubble_info[$i] = "";
      $fake_name = $file;
      $fake_name =~ s/LTC//;
      $fake_name =~ s/Parm1.mmc//;

      # print STDERR "16442 \$fake_name $fake_name\n";
      if ( $fake_name == 1 ) {
        $fake_name = "*SYSTEM";
      }
      elsif ( $fake_name < 10 ) {
        $fake_name = "ASP00$fake_name";
      }
      elsif ( $fake_name < 33 ) {
        $fake_name = "ASP0$fake_name";
      }
      else {
        $fake_name = $fake_name - 32;
        $fake_name = "IASP0$fake_name";
      }
    }
    else {
      ( $fake_name, $bubble_info[$i] ) = asp_fake_name("$aspdir/$file");
      $bubble_info[$i] =~ s/:/\\:/g;
    }

    # print STDERR "16495 detail-graph-cgi.pl after asp_fake_name from $aspdir/$file got \$fake_name $fake_name \$bubble_info[$i] $bubble_info[$i]\n";

    $lpar_space      = $fake_name;
    $lpar_space_proc = $fake_name;

    # to keep same count of characters
    $lpar_space =~ s/\\:/:/g;
    $lpar_space =~ s/Parm3.mmc//;
    $lpar_space = sprintf( "%-25s", $lpar_space );
    $lpar_space      =~ s/:/\\:/g;
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/Parm3.mmc//;
    $lpar_space_proc =~ s/%/%%/g;        # anti '%'

    my $wrkdir_managedname_host_file = "$aspdir/$file";
    $wrkdir_managedname_host_file =~ s/:/\\:/g;
    my $wrkdir_managedname_host_file_legend = $wrkdir_managedname_host_file;
    $wrkdir_managedname_host_file_legend =~ s/Parm3.mmc//;
    $wrkdir_managedname_host_file_legend =~ s/%/%%/g;

    # bulid RRDTool cmd
    if ( $item eq "dsk_svc_as" ) {
      $cmd .= " DEF:curg${i}=\\\"$wrkdir_managedname_host_file\\\":par6:AVERAGE";
      $wrkdir_managedname_host_file_legend = "";    # do not clickable legend
    }
    elsif ( $item eq "dsk_wait_as" ) {
      $cmd .= " DEF:curg${i}=\\\"$wrkdir_managedname_host_file\\\":par7:AVERAGE";
      $wrkdir_managedname_host_file_legend = "";    # do not clickable legend
    }
    elsif ( $item eq "dsk_latency" ) {
      $cmd .= " DEF:curgsix${i}=\\\"$wrkdir_managedname_host_file\\\":par6:AVERAGE";
      $cmd .= " DEF:curgseven${i}=\\\"$wrkdir_managedname_host_file\\\":par7:AVERAGE";
      $cmd .= " CDEF:curg${i}=curgsix${i},curgseven${i},+";
      $wrkdir_managedname_host_file_legend = "";    # do not clickable legend
    }
    else {
      # total capacity
      $cmd .= " DEF:cur${i}=\\\"$wrkdir_managedname_host_file\\\":par3:AVERAGE";
      $cmd .= " DEF:curfree${i}=\\\"$wrkdir_managedname_host_file\\\":par4:AVERAGE";
      if ( $item eq "cap_free" ) {
        $cmd .= " CDEF:curg${i}=curfree${i},1000,/";
      }
      elsif ( $item eq "cap_used" ) {
        $cmd .= " CDEF:curg${i}=cur${i},curfree${i},-,1000,/";
      }
      else {                                        #cap_proc
        $gtype = "LINE";
        $cmd .= " CDEF:curg${i}=cur${i},curfree${i},-,cur${i},/,100,*";
      }
    }
    $cmd .= " $gtype:curg${i}$color[$found]:\\\"$lpar_space\\\"";

    $cmd .= " GPRINT:curg${i}:AVERAGE:\\\"     %6.0lf \\\"";
    my $item_day_other = "$item-other";
    if ( "$type" =~ "d" ) {
      $item_day_other = "$item-day";
    }

    $cmd .= " PRINT:curg${i}:AVERAGE:\\\"%6.0lf $delimiter $item_day_other $delimiter $lpar_space_proc $delimiter $color[$found] $delimiter $wrkdir_managedname_host_file_legend\\\"";
    my $new_line = "";
    $new_line = "\\l" if "$type" !~ "d";
    $cmd .= " GPRINT:curg${i}:MAX:\\\" %6.0lf $new_line\\\"";
    $cmd .= " PRINT:curg${i}:MAX:\\\"%6.0lf $delimiter $bubble_info[$i] $delimiter $lpar_space_orig\\\"";
    if ( "$type" =~ "d" ) {
      $cmd .= " GPRINT:curg${i}:LAST:\\\" %6.0lf \\l\\\"";
      $cmd .= " PRINT:curg${i}:LAST:\\\"%6.0lf $delimiter\\\"";
    }

    # put carriage return after each second lpar in the legend
    if ( $j == 1 ) {
      $j = 0;
    }
    else {
      # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)
      $j++;
    }
    $i++;
    $gtype = "STACK";
  }

  if ( $found_at_least_one == 0 ) {
    return 0;    # no source has been found
  }

  #  print "Updated: " . localtime($last_update) . "\n";
  #if ( "$type" =~ "d" ) {
  my $ltime = localtime($last_update);
  $ltime =~ s/:/\\\:/g;
  $t = "COMMENT:\\\"Updated\\\: $ltime\\\"";
  $cmd .= " $t";
  $t = "COMMENT:Updated\\\: $ltime";

  #}

  $cmd .= " HRULE:0#000000";

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph ASP Mem rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $t               = "" if "$type" !~ "d";
  $png_end_heading = ret_graph_param( $ret, $t );
  return 0;
}

sub asp_fake_name {

  # from full asp filename returns fake filename, cfg text for bubble in legend
  my $full_asp_file_name = shift;
  my @name_parts         = split( "\/", $full_asp_file_name );
  my $file               = $name_parts[-1];
  my $fake_name          = $file;

  # instead of ASP001 return '*SYSTEM'
  $fake_name =~ s/ASP001/*SYSTEM/;    # if it is
  $fake_name =~ s/Parm\d.mmc//;

  my $bubble_info = "";               # legend bubble for lpar (ASP) name
  $file =~ s/Parm\d.mmc//;
  if ( $file =~ /ASP\d\d\d/ ) {
    my $file_cfg = $full_asp_file_name;
    $file_cfg =~ s/Parm\d.mmc/Parm\.cfg/;

    # print STDERR "11957 \$full_asp_file_name $full_asp_file_name \$file_cfg $file_cfg\n";
    if ( !-f "$file_cfg" ) {
      $file_cfg =~ s/Parm\.cfg/Parm1\.cfg/;    #sometimes is there
    }
    if ( -f "$file_cfg" ) {
      open( FF, "<$file_cfg" ) || error( "can't open $file_cfg: $! :" . __FILE__ . ":" . __LINE__ ) && return ( $fake_name, $bubble_info );
      $bubble_info = (<FF>);

      # print STDERR "11961 \$bubble_info $bubble_info\n";
      close(FF);

      # for ASP33 & higher use name "Device name" if exists
      # 'Resource name: IASP, Device description name: IASP, ASP usage: primary iASP,...'
      my $aspnum = $file;
      $aspnum =~ /.*(ASP\d\d\d)/;
      $aspnum = $1;
      my $aspnum_all = $aspnum;
      $aspnum =~ s/ASP//;
      if ( $aspnum > 32 ) {
        ( undef, my $device_name, undef ) = split( /,/, $bubble_info );
        ( undef, $fake_name, undef ) = split( ": ", $device_name );
        $bubble_info .= "ASP number: $aspnum";
      }
    }
  }

  # print STDERR "12760 detail-graph-cgi.pl \$full_asp_file_name $full_asp_file_name \$fake_name $fake_name \$bubble_info $bubble_info\n";
  return ( $fake_name, $bubble_info );
}

sub graph_aspcap {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $upper       = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;             # 1 do not show entitle area
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT:\" \"";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT:\" \"";
  my $rigid       = "\n --rigid";

  # print STDERR "11921 sub graph_aspcap ,$host,$server,$lpar,$type,$item,$type_sam,$graph_hours\n";

  #  my $in_cores = 1; # graph for vmware is in cores
  my $in_cores     = 0;    # graph for vmware is in MHz
                           #my $in_cores = 2;  # graph for vmware has right axis
  my $one_core_hz  = 1;
  my $one_core_mhz = 1;
  my $one_core_ghz = 1;

  my $keep_virtual = 0;
  if ( $ENV{KEEP_VIRTUAL} ) {
    $keep_virtual = $ENV{KEEP_VIRTUAL};    # keep number of virt processors in RRD --> etc/.magic
  }
  else {
    $keep_virtual = 0;
  }

  if ( !defined $upper || $upper eq '' || $upper =~ "entitle" || $upper == 0 ) {    # entitle is badly sent param
    $upper = 0.1;
  }

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $units_exponent = "--units-exponent=1.00";
  $units_exponent = "" if $vmware;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lpar: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
    }
  }

  my $header_prefix = "LPAR:";

  $lpar =~ s/&&1/\//g;
  my $rrd = "$wrkdir/$server/$host/$lpar" . "Parm3.mmc";

  # print STDERR "11969 detail-graph-cgi.pl \$rrd $rrd\n";

  ( my $fake_name, undef ) = asp_fake_name($rrd);

  # print STDERR "12023 detail-graph-cgi.pl \$fake_name $fake_name\n";

  my @lpar_path  = split( "\/", $lpar );
  my $lpar_space = $lpar_path[-1];
  $lpar_space =~ s/\\:/:/g;
  $lpar_space =~ s/Parm3.mmc//;
  $lpar_space = sprintf( "%-25s", $lpar_space );
  $lpar_space =~ s/:/\\:/g;

  if ( !-f "$rrd" ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $lpar_slash = $lpar_path[-1];

  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $last_txt = " last ";
  if ( $detail == 2 ) {
    $last_txt      = " ";
    $header_prefix = "";
    $fake_name     = "" if $server eq "as400";
  }

  #my $header = "$header_prefix $lpar_slash_nmon :$last_txt$text";
  my $header = "$header_prefix $fake_name :$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
    }
  }
  my $vcpu = 0;

  if ( ( $type =~ "d" && $graph_hours == 0 ) || $vmware ) {
    my $rrd_last = rrd_file_actual("$rrd");
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    if ( $type =~ "d" ) {
      $l =~ s/:/\\:/g;
      $t = "COMMENT:Updated\\:\" $l \"";
    }

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );

    # print STDERR "\@row_arr @row_arr\n";
    my $m = "";
    my $i = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );
        if ($vmware) {

          # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
          if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ ) {

            #print "m : $m\n" if $DEBUG ;
            #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
            my $utiltot_mhz = 1;
            my $utiltot_ghz = 1;
            $utiltot_mhz = sprintf( "%e", $m_arr[2] );
            $utiltot_ghz = $utiltot_mhz / 1000;
            $one_core_hz = sprintf( "%e", $m_arr[3] );
            if ($in_cores) {
              my $util = sprintf( "%5.2f", $utiltot_mhz / $one_core_hz * 1000000 );
              if ( $type !~ "d" ) {next}
              $last = "COMMENT:\"Last CPU usage in cores      $util\"";
              if ( $in_cores == 2 ) {
                my $utlt_mhz = sprintf( "%5.0f", $utiltot_mhz );
                my $utlt_ghz = sprintf( "%5.2f", $utiltot_ghz );
                $last = "COMMENT:\"Last CPU usage                $util    $utlt_ghz\"";
              }
            }
            else {
              $utiltot_mhz = $utiltot_mhz / 1000;
              my $util = sprintf( "%5.2f", $utiltot_mhz );
              $last = "COMMENT:\"Last utilization            $util\"";
            }

            # get vCPU
            # print STDERR "\$m_arr[18] $m_arr[18]\n";
            $vcpu = $m_arr[18];
            $vcpu = sprintf( "%e", $vcpu );
            $vcpu = $vcpu * 1;
            if ( !defined $vcpu ) {
              $vcpu = 'not defined';
            }
          }
        }
        else {
          # go further ony if it is a digit (avoid it when NaNQ (== no data) is there)
          if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ && $m_arr[4] =~ /\d/ ) {

            #print "m : $m\n" if $DEBUG ;
            #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;
            my $entitled_cycles = 1;
            my $capped_cycles   = 1;
            my $uncapped_cycles = 1;
            my $curr_proc       = 1;

            if ( $keep_virtual == 1 ) {

              # when KEEP_VIRTUAL then virtual_procs is the second field
              $entitled_cycles = sprintf( "%e", $m_arr[3] );
              $capped_cycles   = sprintf( "%e", $m_arr[4] );
              $uncapped_cycles = sprintf( "%e", $m_arr[5] );
              $curr_proc       = sprintf( "%e", $m_arr[1] );
            }
            else {
              $entitled_cycles = sprintf( "%e", $m_arr[2] );
              $capped_cycles   = sprintf( "%e", $m_arr[3] );
              $uncapped_cycles = sprintf( "%e", $m_arr[4] );
              $curr_proc       = sprintf( "%e", $m_arr[1] );
            }
            if ( $entitled_cycles != 0 ) {
              my $util = sprintf( "%5.2f", ( $capped_cycles + $uncapped_cycles ) / $entitled_cycles ) * $curr_proc;

              #print ("\n $util $curr_proc $entitled_cycles $capped_cycles $uncapped_cycles\n");

              # $last ="COMMENT:\"Last utilization in CPU cores  $util\"";
            }
          }
        }
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  my $vertical_label = "--vertical-label=\"GBytes\"";
  $vertical_label = "--vertical-label=\"CPU usage in Hz\"" if $vmware && !$in_cores;
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  #print "creating graph : $host:$server:$lpar_slash:$type_sam:$type:$name_out:$rrd:$entitle:$item\n" if $DEBUG ;

  my $cmd = "";

  $cmd .= "$graph_cmd \"$name_out\"";
  if ( $in_cores == 2 && $vmware ) {

    #  $cmd .= " --right-axis-label \"CPU usage in MHz\"";
    $one_core_mhz = int( $one_core_hz / 1000000 );
    $one_core_ghz = $one_core_mhz / 1000;
    if ($yes_right_axis) {
      $cmd .= " --right-axis $one_core_ghz:0";
      $cmd .= " --right-axis-format %1.2lf";
    }
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=$upper";
  $cmd .= " $vertical_label";
  $cmd .= " $units_exponent";           #--units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  my $cores_mhz = "cores";              # for vmware graph legend
  if ( $in_cores == 2 ) {
    $cores_mhz = "     ";
  }
  my $gprint_form = "8.2lf";

  my $wrkdir_managedname_host_file = "$rrd";
  $wrkdir_managedname_host_file =~ s/:/\\:/g;
  my $wrkdir_managedname_host_file_legend = $wrkdir_managedname_host_file;
  $wrkdir_managedname_host_file_legend =~ s/Parm3.mmc//;
  $wrkdir_managedname_host_file_legend =~ s/%/%%/g;

  # bulid RRDTool cmd
  # total capacity
  $cmd .= " DEF:totalm=\\\"$wrkdir_managedname_host_file\\\":par3:AVERAGE";
  $cmd .= " CDEF:total=totalm,1000,/";
  $cmd .= " DEF:freem=\\\"$wrkdir_managedname_host_file\\\":par4:AVERAGE";
  $cmd .= " CDEF:free=freem,1000,/";
  $cmd .= " DEF:total_protm=\\\"$wrkdir_managedname_host_file\\\":par5:AVERAGE";
  $cmd .= " CDEF:total_prot=total_protm,1000,/";
  $cmd .= " DEF:free_protm=\\\"$wrkdir_managedname_host_file\\\":par6:AVERAGE";
  $cmd .= " CDEF:free_prot=free_protm,1000,/";

  $cmd .= " CDEF:used=total,free,-";
  $cmd .= " CDEF:used_prot=total_prot,free_prot,-";
  $cmd .= " CDEF:used_noprot=used,used_prot,-";
  $cmd .= " CDEF:free_noprot=free,free_prot,-";

  $cmd .= " COMMENT:\"Memory GB                  Average       Max\\n\"";
  $cmd .= " AREA:used_prot#FF0000:\\\"Used protected    \\\"";
  $cmd .= " GPRINT:used_prot:AVERAGE:\\\"     %6.0lf \\\"";
  $cmd .= " GPRINT:used_prot:MAX:\\\" %6.0lf \\n\"";

  #    if ( "$type" =~ "d" ) {
  #      $cmd .= " GPRINT:used:LAST:\\\" %6.0lf \\l\\\"";
  #    }
  $cmd .= " STACK:used_noprot#FFCC00:\\\"Used not protected\\\"";
  $cmd .= " GPRINT:used_noprot:AVERAGE:\\\"     %6.0lf \\\"";
  $cmd .= " GPRINT:used_noprot:MAX:\\\" %6.0lf \\n\"";
  $cmd .= " STACK:free_prot#009900:\\\"Free protected    \\\"";
  $cmd .= " GPRINT:free_prot:AVERAGE:\\\"     %6.0lf \\\"";
  $cmd .= " GPRINT:free_prot:MAX:\\\" %6.0lf \\n\"";
  $cmd .= " STACK:free_noprot#66FF00:\\\"Free not protected\\\"";
  $cmd .= " GPRINT:free_noprot:AVERAGE:\\\"     %6.0lf \\\"";
  $cmd .= " GPRINT:free_noprot:MAX:\\\" %6.0lf \\\"";

  $cmd .= " $t2";

  $cmd .= " $last";
  $cmd .= " $t2";
  $cmd .= " $t";
  $cmd .= " HRULE:0#000000";

  #  "VRULE:0#000000"

  $cmd =~ s/\\"/"/g;

  #print STDERR "$cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_lpar : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub timing_debug {
  my $text = shift;

  if ( defined $ENV{LPAR2RRD_UI_TIME_DEBUG} ) {
    my $act_time = localtime();
    print STDERR "DEBUG: $0 : $$ : $act_time : $text\n";
  }
  return 1;
}

sub graph_hitachi_percentages {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $lpar_orig   = $lpar;
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "100";
  my $cmd         = "";
  my $rrd         = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph hitachi percentages: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  my $start_time     = "now-1$type";
  my $end_time       = "now-1$type+1$type";
  my $vertical_label = "--vertical-label=CPU usage %";
  my $time           = "last $text";

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  my $header = $lpar eq "pool" ? "System : $time" : "CPU %: $lpar : $time";

  if ( $detail == 1 ) {
    if ( $lpar =~ /pool/ ) {
      $header = "System: $host : $time";
    }
  }

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  $cmd .= "$graph_cmd \\\"$name_out\\\"";
  $cmd .= " --title \\\"$header\\\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=$upper_limit";
  $cmd .= " \\\"$vertical_label\\\"";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( $lpar eq "pool" ) {
    my $cpu      = "$wrkdir/$server/$host/SYS-CPU.hrm";
    my $sys1     = "$wrkdir/$server/$host/SYS1.hrm";
    my $sys2     = "$wrkdir/$server/$host/SYS2.hrm";
    my $shr_lpar = "$wrkdir/$server/$host/SHR_LPAR.hrm";
    my $ded_lpar = "$wrkdir/$server/$host/DED_LPAR.hrm";

    my $file_exist_err = 0;
    if ( !-f "$cpu" )      { error( "$cpu does not exists " . __FILE__ . ":" . __LINE__ );      $file_exist_err = 1; }
    if ( !-f "$sys1" )     { error( "$sys1 does not exists " . __FILE__ . ":" . __LINE__ );     $file_exist_err = 1; }
    if ( !-f "$sys2" )     { error( "$sys2 does not exists " . __FILE__ . ":" . __LINE__ );     $file_exist_err = 1; }
    if ( !-f "$shr_lpar" ) { error( "$shr_lpar does not exists " . __FILE__ . ":" . __LINE__ ); $file_exist_err = 1; }
    if ( !-f "$ded_lpar" ) { error( "$ded_lpar does not exists " . __FILE__ . ":" . __LINE__ ); $file_exist_err = 1; }

    if   ($file_exist_err) { return 0; }
    else                   { $rrd = $cpu; }

    $cmd .= " DEF:cpu=\"$cpu\":cpu_usedp:AVERAGE";
    $cmd .= " CDEF:percent=cpu,100,/";
    $cmd .= " DEF:sys1=\"$sys1\":usedp:AVERAGE";
    $cmd .= " CDEF:sys1p=sys1,percent,/";
    $cmd .= " COMMENT:\"[%]                  Avrg\\n\"";
    $cmd .= " AREA:sys1p#FF0000:\" SYS1         \"";
    $cmd .= " GPRINT:sys1p:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " DEF:sys2=\"$sys2\":usedp:AVERAGE";
    $cmd .= " CDEF:sys2p=sys2,percent,/";
    $cmd .= " STACK:sys2p#00FF00:\" SYS2         \"";
    $cmd .= " GPRINT:sys2p:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " DEF:ded_lpar=\"$ded_lpar\":usedp:AVERAGE";
    $cmd .= " CDEF:ded_lparp=ded_lpar,percent,/";
    $cmd .= " STACK:ded_lparp#FF00FF:\" DED_LPAR     \"";
    $cmd .= " GPRINT:ded_lparp:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " CDEF:shr_lparp=100,ded_lparp,-,sys2p,-,sys1p,-";
    $cmd .= " STACK:shr_lparp#0000FF:\" SHR_LPAR     \"";
    $cmd .= " GPRINT:shr_lparp:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
  }
  else {
    $rrd = "$wrkdir/$server/$host/$lpar.hlm";

    if ( !-f "$rrd" ) {
      error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
      return 0;
    }

    $cmd .= " DEF:usedp=\"$rrd\":usedp:AVERAGE";
    $cmd .= " DEF:delayp=\"$rrd\":delayp:AVERAGE";
    $cmd .= " DEF:idlep=\"$rrd\":idlep:AVERAGE";
    $cmd .= " DEF:iowp=\"$rrd\":iowp:AVERAGE";
    $cmd .= " DEF:niowp=\"$rrd\":niowp:AVERAGE";
    $cmd .= " CDEF:robp=100,usedp,-,delayp,-,idlep,-,iowp,-,niowp,-";
    $cmd .= " CDEF:robp_positive=robp,0,GT,robp,0,IF";
    $cmd .= " COMMENT:\"[%]                  Avrg\\n\"";
    $cmd .= " AREA:usedp#FF0000:\" Used        \"";
    $cmd .= " GPRINT:usedp:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " STACK:robp_positive#FF00FF:\" ROB         \"";
    $cmd .= " GPRINT:robp_positive:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " STACK:iowp#00FFFF:\" IO wait     \"";
    $cmd .= " GPRINT:iowp:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " STACK:niowp#0000FF:\" Non IO wait \"";
    $cmd .= " GPRINT:niowp:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " STACK:delayp#FFFF00:\" Delay       \"";
    $cmd .= " GPRINT:delayp:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " STACK:idlep$pastel_green:\" Idle        \"";
    $cmd .= " GPRINT:idlep:AVERAGE:\" %6.1lf\"";
    $cmd .= " $t2";
  }

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);

  return 0;
}    #end sub_hitachi graph_percentages

sub graph_hitachi_adapters {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $lpar_orig   = $lpar;
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph adapters: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $vertical_label = "--vertical-label=Read - Bytes/sec - Write";
  my $time           = "last $text";
  my $rrd;
  my $header;
  my $output_byte;

  if ( $item eq "hitachi-lan" ) {
    $rrd         = "$wrkdir/$server/$host/$lpar.hnm";
    $header      = "LAN : $lpar : ";
    $output_byte = "sbyte";
  }
  else {
    $rrd         = "$wrkdir/$server/$host/$lpar.hhm";
    $header      = "SAN : $lpar : ";
    $output_byte = "wbyte";
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  if ( !-f $rrd ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " \"$vertical_label\"";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  $cmd .= " DEF:rkbyte=\"$rrd\":rbyte:AVERAGE";
  $cmd .= " DEF:skbyte=\"$rrd\":$output_byte:AVERAGE";
  $cmd .= " CDEF:rbyte_neg=rkbyte,-1000,*";
  $cmd .= " CDEF:sbyte=skbyte,1000,*";
  $cmd .= " CDEF:rmbyte=rkbyte,1000,/";
  $cmd .= " CDEF:smbyte=skbyte,1000,/";
  $cmd .= " COMMENT:\"[MB/sec]             Avrg\\n\"";
  $cmd .= " AREA:rbyte_neg#FF0000:\" Read        \"";
  $cmd .= " GPRINT:rmbyte:AVERAGE:\" %6.1lf\"";
  $cmd .= " $t2";
  $cmd .= " AREA:sbyte#0000FF:\" Write       \"";
  $cmd .= " GPRINT:smbyte:AVERAGE:\" %6.1lf\"";
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_hitachi_adapters_agg {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $step_new   = $step;
  my $last       = "COMMENT: ";
  my $act_time   = localtime();
  my $act_time_u = time();
  my $req_time   = 0;
  my $cmd        = "";
  my $xgrid      = xgrid_set( $type, $detail );
  my $text       = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lparagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $is_lan = $item eq "hitachi-lan-totals";
  my $head   = $is_lan ? "LAN" : "SAN";
  my $header = "$head aggregated : last $text";
  if ( $detail == 1 ) {
    $header = "$head aggregated: $host : last $text";
  }
  elsif ( $detail == 2 ) {
    $header = "LPARs aggregated : $text";
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  elsif ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  elsif ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $header = "$head aggregated: $host : $start_human - $end_human";
  }

  my $rrd_type = $is_lan ? qr/.hnm$/ : qr/.hhm$/;
  opendir( DIR, "$wrkdir/$server/$host" ) || error( "can't opendir $wrkdir/$server/$host: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @files_unsorted = grep( /$rrd_type/, readdir(DIR) );
  my @files          = sort { lc $a cmp lc $b } @files_unsorted;
  closedir(DIR);

  my $vertical_label = "--vertical-label=\"Read - Bytes/sec - Write\"";

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";
  $cmd .= " COMMENT:\"Average [MB/sec]\\l\"";

  if ( $detail == 1 ) {
    $cmd .= " COMMENT:\"Int        READ     Avg      Max      WRITE     Avg      Max\\l\"";
  }

  my $last_update_time = 0;
  my $i                = 0;
  my $gtype            = "AREA";
  my $color_index      = 0;
  my $cmdx             = "";
  my $write_var        = $is_lan ? "sbyte" : "wbyte";
  foreach my $file (@files) {
    chomp($file);
    my $file_orig = $file;
    $lpar = $file;
    $lpar =~ s/$rrd_type//;    # remove rrd suffix

    my $lpar_space_proc = $lpar;
    my $lpar_space      = $lpar;

    # add spaces to lpar name to have 12 chars total (for formating graph legend)
    $lpar_space =~ s/\&\&1/\//g;
    $lpar_space .= " " x ( 12 - length($lpar_space) ) if ( length($lpar_space) < 12 );

    $lpar_space      =~ s/:/\\:/g;    # anti ':'
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;     # anti '%

    my $wrkdir_server_host_file = "$wrkdir/$server/$host/$file";
    $wrkdir_server_host_file =~ s/:/\\:/g;
    my $wrkdir_server_host_file_legend = $wrkdir_server_host_file;
    $wrkdir_server_host_file_legend =~ s/%/%%/g;

    my $rrd_update_time = ( stat($wrkdir_server_host_file) )[9];
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd .= " DEF:rkbyte${i}=\"$wrkdir_server_host_file\":rbyte:AVERAGE";
    $cmd .= " CDEF:rbyte${i}_neg=rkbyte${i},-1000,*";                            #1024
    $cmd .= " CDEF:rmbyte${i}=rkbyte${i},1000,/";
    $cmd .= " DEF:wkbyte${i}=\"$wrkdir_server_host_file\":$write_var:AVERAGE";
    $cmd .= " CDEF:wbyte${i}=wkbyte${i},1000,*";
    $cmd .= " CDEF:wmbyte${i}=wkbyte${i},1000,/";

    $cmd .= " COMMENT:\"$lpar_space\"";
    $cmd .= " $gtype:rbyte${i}_neg$color[$color_index]:\" \"";
    $cmd .= " GPRINT:rmbyte${i}:AVERAGE:\" %5.2lf \"";
    $cmd .= " GPRINT:rmbyte${i}:MAX:\" %5.2lf        \"";
    $cmd .= " PRINT:rmbyte${i}:AVERAGE:\"%5.2lf $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
    $cmd .= " PRINT:rmbyte${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";

    $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

    $cmdx .= " $gtype:wbyte${i}$color[$color_index]: ";
    $gtype = "STACK";
    $cmd .= " $gtype:0$color[$color_index]:\" \"";
    $cmd .= " GPRINT:wmbyte${i}:AVERAGE:\" %5.2lf \"";
    $cmd .= " GPRINT:wmbyte${i}:MAX:\" %5.2lf \"";
    $cmd .= " PRINT:wmbyte${i}:AVERAGE:\"%5.2lf $delimiter $color[$color_index]\"";
    $cmd .= " PRINT:wmbyte${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";
    $cmd .= " $t2";

    $color_index = ( $color_index + 1 ) % ( $color_max + 1 );
    $i++;
    $cmd .= " COMMENT:\"\\l\"";
  }

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  $cmd .= " $cmdx";
  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;    # a trick, there was a problem with aggregated and "COMMENT: "
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_power_adapters2 {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $item        = shift;
  my $t2          = "COMMENT:\\n";
  my $lpar_orig   = $lpar;
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  my $sriov_log_port_list;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph adapters: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";

  if ( $lpar =~ m/totals/ ) {
    return (0);
  }
  my $data_packets;
  if ( $item =~ /_data/ ) {
    $data_packets = "data";
    $item =~ s/_data//;
  }
  elsif ( $item =~ /_io/ ) {
    $data_packets = "packets";
    $item =~ s/_io//;
  }

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      $xgrid      = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
    }
  }
  my $vertical_label = "";
  if ( $data_packets =~ m/data/ ) {
    $vertical_label = "--vertical-label=Read - Bytes/sec - Write";
  }
  elsif ( $data_packets =~ m/packets/ && ( $item =~ m/power_lan/ || $item =~ m/power_sri/ || $item =~ m/power_hea/ ) ) {
    $vertical_label = "--vertical-label=Read - Packets/sec - Write";
  }
  elsif ( $data_packets =~ m/packets/ && $item =~ m/power_san/ ) {
    $vertical_label = "--vertical-label=Read - IOPS - Write";
  }
  elsif ( $data_packets =~ m/packets/ && $item =~ m/power_sas/ ) {
    $vertical_label = "--vertical-label=Read - IOPS - Write";
  }
  else {
    $vertical_label = "--vertical-label=Read - NaN - Write";
  }

  my $time = "last $text";
  my $rrd;
  my $header;
  my $output_byte;
  my $done;

  if ( $item =~ m/power_san/ ) {
    ( my $lpar_header, undef ) = split( '.r', $lpar );
    $rrd         = "$wrkdir/$server/$host/adapters/$lpar";
    $header      = "SAN : $lpar_header : $time";
    $output_byte = "sbyte";
  }
  elsif ( $item =~ m/power_sas/ ) {
    ( my $lpar_header, undef ) = split( '.r', $lpar );
    $rrd         = "$wrkdir/$server/$host/adapters/$lpar";
    $header      = "SAS : $lpar_header : $time";
    $output_byte = "sbyte";
  }
  elsif ( $item =~ m/power_lan/ ) {
    ( my $lpar_header, undef ) = split( '.r', $lpar );
    $rrd         = "$wrkdir/$server/$host/adapters/$lpar";
    $header      = "LAN : $lpar_header : $time";
    $output_byte = "sbyte";
  }
  elsif ( $item =~ m/power_hea/ ) {
    ( my $lpar_header, undef ) = split( '.r', $lpar );
    $rrd         = "$wrkdir/$server/$host/adapters/$lpar";
    $header      = "HEA : $lpar_header : $time";
    $output_byte = "sbyte";
  }
  elsif ( $item =~ m/power_sri/ ) {
    ( my $lpar_header, undef ) = split( '.r', $lpar );
    if ( -f "$basedir/data/$server/$host/sriov_log_port_list.json" ) {
      $sriov_log_port_list = read_json("$basedir/data/$server/$host/sriov_log_port_list.json");
    }
    $rrd         = "$wrkdir/$server/$host/adapters/$lpar";
    $header      = "SR-IOV : $lpar_header : $time";
    $output_byte = "sbyte";
  }
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      $xgrid      = "";             # just a trick

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $time = "$start_human - $end_human";
    }
  }

  #if ( $detail == 1 ) {
  #  if ( $lpar =~ /pool/ ) {
  #    $header = "System: $host : $time";
  #  }
  #}

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  if ( !-f $rrd ) {
    error( "$rrd does not exists " . __FILE__ . ":" . __LINE__ );
    return 0;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " \"$vertical_label\"";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( $data_packets =~ m/data/ ) {
    my $file_pth = "$wrkdir/$server/*/adapters/$lpar";
    my ( $result_cmd, $read, $write ) = LPM_easy( "AVERAGE", $file_pth, "0", "0", "read", "write" );
    $cmd .= $result_cmd;

    #$cmd .= " DEF:read=\"$rrd\":read:AVERAGE";
    #$cmd .= " DEF:write=\"$rrd\":write:AVERAGE";

    $cmd .= " CDEF:write_B=$write,1024,*";
    $cmd .= " CDEF:read_B=$read,1024,*";

    $cmd .= " CDEF:write_B_neg=write_B,-1,*";
    $cmd .= " CDEF:read_B_neg=read_B,-1,*";

    $cmd .= " CDEF:read_kB=read_B,1024,/";
    $cmd .= " CDEF:write_kB=write_B,1024,/";

    $cmd .= " CDEF:read_MB=read_kB,1024,/";
    $cmd .= " CDEF:write_MB=write_kB,1024,/";

    $cmd .= " CDEF:read_GB=read_MB,1024,/";
    $cmd .= " CDEF:write_GB=write_MB,1024,/";

    $cmd .= " COMMENT:\"[MB/sec]             Avrg      Max\\n\"";
    $cmd .= " AREA:read_B_neg#FF0000:\" Read        \"";
    $cmd .= " GPRINT:read_MB:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:read_MB:MAX:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " AREA:write_B#0000FF:\" Write       \"";
    $cmd .= " GPRINT:write_MB:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:write_MB:MAX:\" %6.1lf\"";
  }
  elsif ( $data_packets =~ m/packets/ ) {
    my $file_pth = "$wrkdir/$server/*/adapters/$lpar";
    my ( $result_cmd, $ioread, $iowrite ) = LPM_easy( "AVERAGE", $file_pth, "0", "0", "io_read", "io_write" );
    $cmd .= $result_cmd;

    #$cmd .= " DEF:io_read=\"$rrd\":io_read:AVERAGE";
    #$cmd .= " DEF:io_write=\"$rrd\":io_write:AVERAGE";
    $cmd .= " CDEF:io_read=$ioread,1,/";
    $cmd .= " CDEF:io_write=$iowrite,1,/";
    $cmd .= " CDEF:io_write_neg=$iowrite,-1,*";
    $cmd .= " CDEF:io_read_neg=$ioread,-1,*";

    if ( ( $data_packets =~ /packets/ ) && ( $item =~ /power_lan/ || $item =~ /power_sri/ || $item =~ /power_hea/ ) ) {
      $cmd .= " COMMENT:\"[Packets]              Avrg    Max\\n\"";
    }
    elsif ( $data_packets =~ /packets/ && $item =~ /power_san/ ) {
      $cmd .= " COMMENT:\"[IOPS]            Avrg    Max\\n\"";
    }
    elsif ( $data_packets =~ /packets/ && $item =~ /power_sas/ ) {
      $cmd .= " COMMENT:\"[IOPS]            Avrg    Max\\n\"";
    }
    $cmd .= " AREA:io_read_neg#FF0000:\" Read        \"";
    $cmd .= " GPRINT:io_read:AVERAGE:\" %.0lf\"";
    $cmd .= " GPRINT:io_read:MAX:\" %.0lf\"";
    $cmd .= " $t2";
    $cmd .= " AREA:io_write#0000FF:\" Write       \"";
    $cmd .= " GPRINT:io_write:AVERAGE:\" %.0lf\"";
    $cmd .= " GPRINT:io_write:MAX:\" %.0lf\"";
  }
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

#expects {
sub graph_power_rrd_test {
  my $host   = shift;
  my $server = shift;
  my $lpar   = shift;
  my $in     = shift;
  my %in     = %{$in};
  my $rrd    = "$wrkdir/$server/$host/pool_total.rrt";

  #my $rrd = "$wrkdir/$server/$host/pool_total.rrm";
  my $metrics     = $in{metrics};
  my $description = $in{description};
  my $cmd;
  $cmd .= "graph";
  foreach my $par ( @{$metrics} ) {

    #warn Dumper $par;
    $cmd .= " DEF:\"$rrd\":$par:AVERAGE";

    #warn "### DEF:\"$rrd\":$par:AVERAGE";
  }

  $cmd .= " COMMENT:\"[$description]              Avrg    Max\\n\"";
  foreach my $par ( @{$metrics} ) {
    $cmd .= " AREA:$par#FF0000:\" $par        \"";
  }

  foreach my $par ( @{$metrics} ) {
    $cmd .= " GPRINT:par:AVERAGE:\" %.0lf\"";
  }

  $cmd .= " HRULE:0#000000";

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  return 0;
}

sub graph_power_vcpu {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $item        = shift;
  my $t2          = "COMMENT:\\n";
  my $lpar_orig   = $lpar;
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  my $sriov_log_port_list;

  #warn "item : $item\n";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;
  my $text  = text_set($type);
  my $xgrid = xgrid_set( $type, $detail );

  my $time           = "last $text";
  my $vertical_label = "--vertical-label=vCPU Cores";

  my $suffix_rrd  = "rvm";
  my $header_type = "vCPU";
  my $cf          = "AVERAGE";
  my $header      = "$header_type : last $text";    #graph header

  if ( $start_unix ne '' && $end_unix ne '' ) {
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $header = "$header_type : $server : $start_human - $end_human";
  }

  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph adapters: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $start_unix ne '' && $end_unix ne '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      if ( $detail != 10 ) {        # KZ: why is this funcion here twice???
        $xgrid = "";                # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $time = "$start_human - $end_human";
    }
  }
  if ( $start_unix ne '' && $end_unix ne '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      if ( $detail != 10 ) {        # KZ: why is this funcion here twice???
        $xgrid = "";                # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $time = "$start_human - $end_human";
    }
  }

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  # use header or time range when zoom
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0
      && $detail != 10 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " \"$vertical_label\"";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";     #800m to 0.8
  $cmd .= " --lower-limit=0.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";

  my $file_pth_vcpu = "$wrkdir/$server/*/$lpar.rvm";
  my ( $result_vcpu_cmd, $vcpu ) = LPM_easy( "AVERAGE", $file_pth_vcpu, "0", "0", "allocated_cores" );

  $cmd .= $result_vcpu_cmd;

  $cmd .= " $xgrid";

  $cmd .= " CDEF:allocated=$vcpu,1,*";

  # following must be for RRD 1.2+
  $cmd .= " COMMENT:\"[cores]                       Avrg      Max\\n\"";
  $cmd .= " $t2";

  #$cmd .= " AREA:curr_proc_units_avg$pastel_green:\" Configured CPU cores     \"";
  #$cmd .= " GPRINT:curr_proc_units_avg:MAX:\" %3.1lf  \"";
  #$cmd .= " GPRINT:curr_proc_units_max:AVERAGE:\" %3.1lf  \"";
  #$cmd .= " $t2";

  $cmd .= " LINE1:allocated#FF0000:\" vCPU cores \"";
  $cmd .= " GPRINT:allocated:$cf:\" %3.1lf  \"";
  $cmd .= " $t2";

  # add updated line - the last time pool_total.rrt was updated
  my $rrd_last = "$wrkdir/$server/$host/pool_total.rrt";
  RRDp::cmd qq(last "$rrd_last");
  my $last_tt = RRDp::read;
  my $l       = localtime( time_from_last_tt($last_tt) );
  $l =~ s/:/\\:/g;
  $cmd .= " COMMENT:Updated\\:\" $l \"" if ( $type eq "d" );
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);

  return 0;
}

sub graph_power_vcpu_trend {

  return 0;
}

sub graph_power_servers_total {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $item        = shift;
  my $t2          = "COMMENT:\\n";
  my $lpar_orig   = $lpar;
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  my $sriov_log_port_list;

  #warn "item : $item\n";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;
  my $text  = text_set($type);
  my $xgrid = xgrid_set( $type, $detail );

  my $time           = "last $text";
  my $vertical_label = "--vertical-label=CPU Cores";

  my $suffix_rrd  = "rrt";
  my $header_type = "CPU Total";
  my $cf          = "AVERAGE";

  if ( $item eq "pool-total" ) {
    $suffix_rrd  = "rrt";
    $header_type = "CPU Total";
    $cf          = "AVERAGE";
  }
  elsif ( $item eq "pool-total-max" ) {
    $suffix_rrd  = "rxm";
    $header_type = "CPU Total Max";
    $cf          = "MAX";
  }

  my $header = "$header_type : last $text";    #graph header
  if ( $detail == 1 ) {
    $header = "$header_type: $server : last $text";
  }

  if ( $start_unix ne '' && $end_unix ne '' ) {
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $header = "$header_type : $server : $start_human - $end_human";
  }

  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph adapters: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $start_unix ne '' && $end_unix ne '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      if ( $detail != 10 ) {        # KZ: why is this funcion here twice???
        $xgrid = "";                # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $time = "$start_human - $end_human";
    }
  }

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  # use header or time range when zoom
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0
      && $detail != 10 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " \"$vertical_label\"";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";     #800m to 0.8
  $cmd .= " --lower-limit=0.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";

  #my $servers = [ "Power770", "Power710:testovani dlouheeeeeho" ];

  #foreach my $server ( @{$servers} ) {

  my $file_pth_max = "$wrkdir/$server/*/pool_total.rxm";
  my $file_pth_avg = "$wrkdir/$server/*/pool_total.rrt";

  my $file_pth_pool     = "$wrkdir/$server/*/pool.rrm";
  my $file_pth_pool_max = "$wrkdir/$server/*/pool.xrm";

  my ( $result_cmd_max, $configured_max, $curr_proc_units_max, $entitled_max, $capped_max, $uncapped_max ) = LPM_easy( "MAX", $file_pth_max, "0", "0", "configured", "curr_proc_units", "entitled_cycles", "capped_cycles", "uncapped_cycles" );
  my ( $result_cmd_pool,     $borrowed_avg ) = LPM_easy( "AVERAGE", $file_pth_pool,     "1", "0", "bor_proc_units" );
  my ( $result_cmd_pool_max, $borrowed_max ) = LPM_easy( "MAX",     $file_pth_pool_max, "2", "0", "bor_proc_units" );

  if ( $item =~ m/max/ ) {
    $curr_proc_units_max =~ s/var/varmax/g;
    $entitled_max        =~ s/var/varmax/g;
    $capped_max          =~ s/var/varmax/g;
    $uncapped_max        =~ s/var/varmax/g;

    my $result_to_parse = $result_cmd_max;
    $result_to_parse =~ s/^\s+//g;
    $result_to_parse =~ s/\s+$//g;
    $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

    my @result_cmd_lines = split( "\n", $result_to_parse );
    my $result_cmd_max_new;

    foreach my $cmd_line (@result_cmd_lines) {
      chomp $cmd_line;

      #print "$cmd_line\n";
      $cmd_line =~ s/^\s+//g;
      $cmd_line =~ s/\s+$//g;
      my $line_max = $cmd_line;
      if ( $cmd_line =~ "^DEF:" ) {
        $line_max =~ s/^DEF:var/DEF:varmax/;
        $line_max =~ s/:AVERAGE$/:MAX/;
      }
      if ( $cmd_line =~ "^CDEF:" ) {
        $line_max =~ s/var/varmax/g;
      }

      $result_cmd_max_new .= " $line_max";
    }

    $cmd .= $result_cmd_max_new;
  }

  $cmd .= $result_cmd_pool;
  $cmd .= $result_cmd_pool_max;

  my ( $result_cmd_avg, $configured_avg, $curr_proc_units_avg, $entitled_avg, $capped_avg, $uncapped_avg ) = LPM_easy( "AVERAGE", $file_pth_avg, "0", "0", "configured", "curr_proc_units", "entitled_cycles", "capped_cycles", "uncapped_cycles" );

  $cmd .= $result_cmd_avg;

  $cmd .= " $xgrid";

  $cmd .= " CDEF:curr_proc_units_max=$curr_proc_units_max,1,*";
  $cmd .= " CDEF:entitled_max=$entitled_max,1,*";
  $cmd .= " CDEF:capped_max=$capped_max,1,*";
  $cmd .= " CDEF:uncapped_max=$uncapped_max,1,*";
  $cmd .= " CDEF:configured_max=$configured_max,1,*";

  $cmd .= " CDEF:curr_proc_units_avg=$curr_proc_units_avg,1,*";
  $cmd .= " CDEF:entitled_avg=$entitled_avg,1,*";
  $cmd .= " CDEF:capped_avg=$capped_avg,1,*";
  $cmd .= " CDEF:uncapped_avg=$uncapped_avg,1,*";
  $cmd .= " CDEF:configured_avg=$configured_avg,1,*";

  # to simulate lower configured - comment above line, uncomment following line
  #$cmd .= " CDEF:configured_avg=$configured_avg,0.5,*";

  #borrowed
  $cmd .= " CDEF:borrowed_avg=$borrowed_avg,1,*";
  $cmd .= " CDEF:ded_ent_avg=configured_avg,borrowed_avg,-";
  $cmd .= " CDEF:borrowed_max=$borrowed_max,1,*";
  $cmd .= " CDEF:ded_ent_max=configured_max,borrowed_max,-";

  $cmd .= " CDEF:tot_max=capped_max,uncapped_max,+";
  $cmd .= " CDEF:util_max=tot_max,entitled_max,/,$cpu_max_filter,GT,UNKN,tot_max,entitled_max,/,IF";
  $cmd .= " CDEF:utilperct_max=util_max,100,*";
  $cmd .= " CDEF:utiltot_max_peak=util_max,curr_proc_units_max,*";

  $cmd .= " CDEF:tot_avg=capped_avg,uncapped_avg,+";
  $cmd .= " CDEF:util_avg=tot_avg,entitled_avg,/,$cpu_max_filter,GT,UNKN,tot_avg,entitled_avg,/,IF";
  $cmd .= " CDEF:utilperct_avg=util_avg,100,*";
  $cmd .= " CDEF:utiltot_avg_peak=util_avg,curr_proc_units_avg,*";

  # there are sometimes peaks in utiltot higher than configured
  # replace them for -nan
  $cmd .= " CDEF:utiltot_max=utiltot_max_peak,configured_avg,GT,UNKN,utiltot_max_peak,IF";
  $cmd .= " CDEF:utiltot_avg=utiltot_avg_peak,configured_avg,GT,UNKN,utiltot_avg_peak,IF";

  # following must be for RRD 1.2+
  $cmd .= " COMMENT:\"[cores]                       Avrg      Max\\n\"";
  $cmd .= " $t2";

  #$cmd .= " AREA:curr_proc_units_avg$pastel_green:\" Configured CPU cores     \"";
  #$cmd .= " GPRINT:curr_proc_units_avg:MAX:\" %3.1lf  \"";
  #$cmd .= " GPRINT:curr_proc_units_max:AVERAGE:\" %3.1lf  \"";
  #$cmd .= " $t2";

  $cmd .= " LINE1:utiltot_avg#FF0000:\" Utilization in CPU cores \"";

  #$cmd .= " GPRINT:utiltot_avg:$cf:\" %3.1lf  \""; # this is bad
  #$cmd .= " GPRINT:utiltot_max:$cf:\" %3.1lf  \""; # this is bad
  $cmd .= " GPRINT:utiltot_avg:AVERAGE:\" %3.1lf  \"";
  $cmd .= " GPRINT:utiltot_avg:MAX:\" %3.1lf  \"";

  $cmd .= " $t2";

  $cmd .= " LINE2:configured_avg#888888:\" Configured               \"";
  $cmd .= " GPRINT:configured_avg:$cf:\" %3.1lf  \"";
  $cmd .= " GPRINT:configured_max:$cf:\" %3.1lf  \"";

  $cmd .= " $t2";

  $cmd .= " LINE2:ded_ent_avg$pastel_green:\" CPU allocated            \"";
  $cmd .= " GPRINT:ded_ent_avg:$cf:\" %3.1lf  \"";
  $cmd .= " GPRINT:ded_ent_max:$cf:\" %3.1lf  \"";
  $cmd .= " $t2";

  if ( $item =~ m/max/ ) {
    $cmd .= " LINE1:utiltot_max#0088FF:\" Maximum peaks in CPU cores\":dashes=1,2";
    $cmd .= " GPRINT:utiltot_avg:$cf:\"%3.1lf   \"";
    $cmd .= " GPRINT:utiltot_max:$cf:\"%3.1lf   \"";
  }
  $cmd .= " $t2";

  # add updated line - the last time pool_total.rrt was updated
  #my $rrd_last = "$wrkdir/$server/$host/pool_total.rrt";
  #RRDp::cmd qq(last "$rrd_last");
  #my $last_tt = RRDp::read;
  #my $l = localtime(time_from_last_tt($last_tt));
  #$l =~ s/:/\\:/g;
  $cmd .= " COMMENT:Updated\\:\" l \"" if ( $type eq "d" );
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";

  #}

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_power_total {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $item        = shift;
  my $t2          = "COMMENT:\\n";
  my $lpar_orig   = $lpar;
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  my $sriov_log_port_list;

  #warn "item : $item\n";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;
  my $text  = text_set($type);
  my $xgrid = xgrid_set( $type, $detail );

  my $time           = "last $text";
  my $vertical_label = "--vertical-label=CPU Cores";

  my $suffix_rrd  = "rrt";
  my $header_type = "CPU Total";
  my $cf          = "AVERAGE";

  if ( $item eq "pool-total" ) {
    $suffix_rrd  = "rrt";
    $header_type = "CPU Total";
    $cf          = "AVERAGE";
  }
  elsif ( $item eq "pool-total-max" ) {
    $suffix_rrd  = "rxm";
    $header_type = "CPU Total Max";
    $cf          = "MAX";
  }

  my $header = "$header_type : last $text";    #graph header
  if ( $detail == 1 ) {
    $header = "$header_type: $server : last $text";
  }

  if ( $start_unix ne '' && $end_unix ne '' ) {
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $header = "$header_type : $server : $start_human - $end_human";
  }

  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph adapters: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $start_unix ne '' && $end_unix ne '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $req_time   = $start_time;    # set here too
      $end_time   = $end_unix;
      if ( $detail != 10 ) {        # KZ: why is this funcion here twice???
        $xgrid = "";                # just a trick
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $time = "$start_human - $end_human";
    }
  }

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }

  # use header or time range when zoom
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0
      && $detail != 10 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " \"$vertical_label\"";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";     #800m to 0.8
  $cmd .= " --lower-limit=0.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";

  my $file_pth_max = "$wrkdir/$server/*/pool_total.rxm";
  my $file_pth_avg = "$wrkdir/$server/*/pool_total.rrt";

  my $file_pth_pool     = "$wrkdir/$server/*/pool.rrm";
  my $file_pth_pool_max = "$wrkdir/$server/*/pool.xrm";

  my ( $result_cmd_max, $configured_max, $curr_proc_units_max, $entitled_max, $capped_max, $uncapped_max ) = LPM_easy( "MAX", $file_pth_max, "0", "0", "configured", "curr_proc_units", "entitled_cycles", "capped_cycles", "uncapped_cycles" );
  my ( $result_cmd_pool,     $borrowed_avg ) = LPM_easy( "AVERAGE", $file_pth_pool,     "1", "0", "bor_proc_units" );
  my ( $result_cmd_pool_max, $borrowed_max ) = LPM_easy( "MAX",     $file_pth_pool_max, "2", "0", "bor_proc_units" );

  if ( $item =~ m/max/ ) {
    $curr_proc_units_max =~ s/var/varmax/g;
    $entitled_max        =~ s/var/varmax/g;
    $capped_max          =~ s/var/varmax/g;
    $uncapped_max        =~ s/var/varmax/g;

    my $result_to_parse = $result_cmd_max;
    $result_to_parse =~ s/^\s+//g;
    $result_to_parse =~ s/\s+$//g;
    $result_to_parse =~ s/ ([C]*DEF:)/\n$1/g;

    my @result_cmd_lines = split( "\n", $result_to_parse );
    my $result_cmd_max_new;

    foreach my $cmd_line (@result_cmd_lines) {
      chomp $cmd_line;

      #print "$cmd_line\n";
      $cmd_line =~ s/^\s+//g;
      $cmd_line =~ s/\s+$//g;
      my $line_max = $cmd_line;
      if ( $cmd_line =~ "^DEF:" ) {
        $line_max =~ s/^DEF:var/DEF:varmax/;
        $line_max =~ s/:AVERAGE$/:MAX/;
      }
      if ( $cmd_line =~ "^CDEF:" ) {
        $line_max =~ s/var/varmax/g;
      }

      $result_cmd_max_new .= " $line_max";
    }

    $cmd .= $result_cmd_max_new;
  }

  $cmd .= $result_cmd_pool;
  $cmd .= $result_cmd_pool_max;

  my ( $result_cmd_avg, $configured_avg, $curr_proc_units_avg, $entitled_avg, $capped_avg, $uncapped_avg ) = LPM_easy( "AVERAGE", $file_pth_avg, "0", "0", "configured", "curr_proc_units", "entitled_cycles", "capped_cycles", "uncapped_cycles" );

  $cmd .= $result_cmd_avg;

  $cmd .= " $xgrid";

  $cmd .= " CDEF:curr_proc_units_max=$curr_proc_units_max,1,*";
  $cmd .= " CDEF:entitled_max=$entitled_max,1,*";
  $cmd .= " CDEF:capped_max=$capped_max,1,*";
  $cmd .= " CDEF:uncapped_max=$uncapped_max,1,*";
  $cmd .= " CDEF:configured_max=$configured_max,1,*";

  $cmd .= " CDEF:curr_proc_units_avg=$curr_proc_units_avg,1,*";
  $cmd .= " CDEF:entitled_avg=$entitled_avg,1,*";
  $cmd .= " CDEF:capped_avg=$capped_avg,1,*";
  $cmd .= " CDEF:uncapped_avg=$uncapped_avg,1,*";
  $cmd .= " CDEF:configured_avg=$configured_avg,1,*";

  # to simulate lower configured - comment above line, uncomment following line
  #$cmd .= " CDEF:configured_avg=$configured_avg,0.5,*";

  #borrowed
  $cmd .= " CDEF:borrowed_avg=$borrowed_avg,1,*";
  $cmd .= " CDEF:ded_ent_avg=borrowed_avg,configured_avg,LT,configured_avg,borrowed_avg,-,UNKN,IF";
  $cmd .= " CDEF:borrowed_max=$borrowed_max,1,*";
  $cmd .= " CDEF:ded_ent_max=configured_max,borrowed_max,-";

  $cmd .= " CDEF:tot_max=capped_max,uncapped_max,+";
  $cmd .= " CDEF:util_max=tot_max,entitled_max,/,$cpu_max_filter,GT,UNKN,tot_max,entitled_max,/,IF";
  $cmd .= " CDEF:utilperct_max=util_max,100,*";
  $cmd .= " CDEF:utiltot_max_peak=util_max,curr_proc_units_max,*";

  $cmd .= " CDEF:tot_avg=capped_avg,uncapped_avg,+";
  $cmd .= " CDEF:util_avg=tot_avg,entitled_avg,/,$cpu_max_filter,GT,UNKN,tot_avg,entitled_avg,/,IF";
  $cmd .= " CDEF:utilperct_avg=util_avg,100,*";
  $cmd .= " CDEF:utiltot_avg_peak=util_avg,curr_proc_units_avg,*";

  # there are sometimes peaks in utiltot higher than configured
  # replace them for -nan
  $cmd .= " CDEF:utiltot_max=utiltot_max_peak,configured_avg,GT,UNKN,utiltot_max_peak,IF";
  $cmd .= " CDEF:utiltot_avg=utiltot_avg_peak,configured_avg,GT,UNKN,utiltot_avg_peak,IF";
  $cmd .= " CDEF:utiltot_avg_perc1=utiltot_avg,configured_avg,/";
  $cmd .= " CDEF:utiltot_avg_perc=utiltot_avg_perc1,100,*";

  # following must be for RRD 1.2+
  $cmd .= " COMMENT:\"Average [CPU cores] \\n\"";
  $cmd .= " $t2";

  $cmd .= " LINE2:configured_avg#888888:\" Configured  \"";
  $cmd .= " GPRINT:configured_avg:$cf:\" %3.1lf  \"";

  #$cmd .= " GPRINT:configured_max:$cf:\" %3.1lf  \"";

  $cmd .= " $t2";

  $cmd .= " LINE2:ded_ent_avg$pastel_green:\" Allocated   \"";
  $cmd .= " GPRINT:ded_ent_avg:$cf:\" %3.1lf  \"";

  #$cmd .= " GPRINT:ded_ent_max:$cf:\" %3.1lf  \"";
  $cmd .= " $t2";

  $cmd .= " LINE1:utiltot_avg#FF0000:\" Utilization \"";
  $cmd .= " GPRINT:utiltot_avg:AVERAGE:\" %3.1lf  \"";

  #$cmd .= " GPRINT:utiltot_avg:MAX:\" %3.1lf  \"";

  $cmd .= " COMMENT:\"(\"";
  $cmd .= " GPRINT:utiltot_avg_perc:AVERAGE:\"%3.1lf\"";
  $cmd .= " COMMENT:\"% )\"";
  $cmd .= " $t2";

  if ( $item =~ m/max/ ) {
    $cmd .= " LINE1:utiltot_max#0088FF:\" Maximum peaks\":dashes=1,2";
    $cmd .= " GPRINT:utiltot_avg:$cf:\"%3.1lf   \"";

    #$cmd .= " GPRINT:utiltot_max:$cf:\"%3.1lf   \"";
  }
  $cmd .= " $t2";

  # add updated line - the last time pool_total.rrt was updated
  my $rrd_last = "$wrkdir/$server/$host/pool_total.rrt";
  $rrd_last = rrd_file_actual("$rrd_last");
  RRDp::cmd qq(last "$rrd_last");
  my $last_tt = RRDp::read;
  my $l       = localtime( time_from_last_tt($last_tt) );
  $l =~ s/:/\\:/g;
  $cmd .= " COMMENT:Updated\\:\" $l \"" if ( $type eq "d" );
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";

  #print STDERR "CMD:\n";
  #print STDERR "===$cmd´===\n";

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_pool : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_power_adapters_agg2 {
  my $host           = shift;
  my $server         = shift;
  my $lpar           = shift;
  my $type           = shift;
  my $name_out       = shift;
  my $type_sam       = shift;
  my $detail         = shift;
  my $graph_hours    = shift;
  my $entitle        = shift;
  my $start_unix     = shift;
  my $end_unix       = shift;
  my $item           = shift;
  my $adapter_suffix = shift;
  my $t2             = "COMMENT:\\n";
  my $step_new       = $step;
  my $last           = "COMMENT: ";
  my $act_time       = localtime();
  my $act_time_u     = time();
  my $req_time       = 0;
  my $done           = 0;
  my $cmd            = "";
  my $xgrid          = xgrid_set( $type, $detail );
  my $text           = text_set($type);

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lparagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  my $lan_san;
  my $data_packets;

  $lan_san = "LAN" if ( $item =~ m/power_lan/ );
  $lan_san = "HEA" if ( $item =~ m/power_hea/ );
  $lan_san = "SAN" if ( $item =~ m/power_san/ );
  $lan_san = "SAS" if ( $item =~ m/power_sas/ );
  $lan_san = "SRI" if ( $item =~ m/power_sri/ );
  my @files_aliases = <$wrkdir/$server/*\/$lan_san\_aliases.json>;
  my $interface_aliases;
  foreach my $al_file (@files_aliases) {
    if ( $al_file !~ m/$lan_san/ ) { next; }
    ( my $host_tmp, undef ) = split( "/$lan_san\_aliases", $al_file );
    ( undef, $host_tmp ) = split( "$server/", $host_tmp );
    $interface_aliases->{$host_tmp} = read_json($al_file) if ( -f $al_file );
  }
  $data_packets = "data"    if ( $item =~ m/data/ );
  $data_packets = "packets" if ( $item =~ m/io/ );
  $item =~ s/_data//;
  $item =~ s/_io//;

  if ( !defined $lan_san || !defined $data_packets || $lan_san eq "" || $data_packets eq "" ) {
    error("Not defined item or lpar parameter parsing to graph_power_adapters_agg2 subroutine\n");
    return (0);
  }

  my $head = $lan_san;
  if ( $head eq "SRI" ) {
    $head = "SR-IOV";
  }
  my $header = "$head $data_packets aggregated : $host : last $text";
  if ( $detail == 1 ) {
    $header = "$head $data_packets aggregated : $host : last $text";
  }
  elsif ( $detail == 2 ) {
    $header = "$head $data_packets aggregated: $text";
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  elsif ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  elsif ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $header = "$head $data_packets aggregated: $host : $start_human - $end_human";
  }

  my $rrd_type = $adapter_suffix;
  $server = urldecode($server);
  opendir( DIR, "$wrkdir/$server/$host/adapters" ) || error( "can't opendir $wrkdir/$server/$host/adapters: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
  my @files_unsorted = grep( /$rrd_type/, readdir(DIR) );
  my @files          = sort { lc $a cmp lc $b } @files_unsorted;
  if ( !(@files) ) {
    return;
  }
  closedir(DIR);

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }
  my $vertical_label;
  if ( $data_packets eq "data" ) {
    $vertical_label = "--vertical-label=\"Read - Bytes/sec - Write\"";
  }
  elsif ( $data_packets eq "packets" ) {
    if ( $lan_san eq "LAN" || $lan_san eq "HEA" || $lan_san eq "SRI" ) {
      $vertical_label = "--vertical-label=\"Read - Packets/sec - Write\"";
    }
    else {
      $vertical_label = "--vertical-label=\"Read - IOPS - Write\"";
    }
  }

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 1 ) {
    $cmd .= " COMMENT:\"Int                             READ    Avg       Max           WRITE   Avg      Max\\l\"";
  }

  my $file        = "";
  my $i           = 0;
  my $gtype       = "AREA";
  my $color_index = 0;
  my $cmdx        = "";
  my $write_var   = $lan_san ? "sbyte" : "wbyte";
  my $sriov_aliases;
  $sriov_aliases = read_json("$basedir/data/$server/$host/sriov_aliases.json") if ( -f "$basedir/data/$server/$host/sriov_aliases.json" );

  foreach $file (@files) {
    if ( $file eq '' || $file =~ '^\.r' ) {
      next;
    }
    my $file_pth = "$wrkdir/$server/*/adapters/$file";
    my ( $result_cmd, $read, $write, $io_read, $io_write ) = LPM_easy( "AVERAGE", $file_pth, $i, "0", "read", "write", "io_read", "io_write" );
    $cmd .= $result_cmd;
    $cmd .= " CDEF:r${i}=$read";
    $cmd .= " CDEF:w${i}=$write";
    $cmd .= " CDEF:io_r${i}=$io_read";
    $cmd .= " CDEF:io_w${i}=$io_write";
    chomp($file);
    my $file_orig = $file;

    $lpar = $file;
    $lpar =~ s/$rrd_type//;    # remove rrd suffix
    $lpar =~ s/\.//;

    #if ($file =~ m/-V[0-9]*-C[0-9]*/){next;} #hash this if you want Virtual Adapters with XXXXX-V*-C*-T* in name

    my $lpar_space_proc = $lpar;
    my $lpar_space      = $lpar;

    # add spaces to lpar name to have 12 chars total (for formating graph legend)
    $lpar_space =~ s/\&\&1/\//g;
    $lpar_space .= " " x ( 12 - length($lpar_space) ) if ( length($lpar_space) < 12 );

    $lpar_space      =~ s/:/\\:/g;    # anti ':'
    $lpar_space_proc =~ s/:/\\:/g;
    $lpar_space_proc =~ s/%/%%/g;     # anti '%a
                                      #$lpar_space_proc = $file;
    my $new_alias     = "";
    my $new_partition = "";
    if ( !defined $interface_aliases->{$host}{$lpar}{alias} ) {
      foreach my $h ( keys %{$interface_aliases} ) {
        $new_alias     = $interface_aliases->{$h}{$lpar}{alias}     if defined $interface_aliases->{$h}{$lpar}{alias};
        $new_partition = $interface_aliases->{$h}{$lpar}{partition} if defined $interface_aliases->{$h}{$lpar}{partition};
      }
    }
    else {
      $new_alias     = $interface_aliases->{$host}{$lpar}{alias};
      $new_partition = $interface_aliases->{$host}{$lpar}{partition};
    }
    if ( defined $lpar && $lpar ne "" && defined $new_alias && $new_alias ne "" ) {
      $lpar_space_proc = "$new_partition $new_alias";
    }
    else {
      $lpar_space_proc = $lpar;
    }
    my $adapter_legend_png = $lpar_space_proc;
    if ( defined $sriov_aliases->{$lpar} ) {
      $adapter_legend_png = "$adapter_legend_png ($sriov_aliases->{$lpar})";
    }
    while ( length($adapter_legend_png) < 30 ) {
      $adapter_legend_png = "$adapter_legend_png ";
    }

    my $wrkdir_server_host_file = "$wrkdir/$server/$host/adapters/$file";
    $wrkdir_server_host_file =~ s/:/\\:/g;
    my $wrkdir_server_host_file_legend = $wrkdir_server_host_file;

    $wrkdir_server_host_file_legend =~ s/%/%%/g;
    ( undef, $wrkdir_server_host_file_legend ) = split( 'adapters/', $wrkdir_server_host_file_legend );
    ( $wrkdir_server_host_file_legend, undef ) = split( '.', $wrkdir_server_host_file_legend );
    if ( $data_packets eq "data" && $lan_san ne "HEA" ) {

      $cmd .= " CDEF:write_kB${i}=w${i},1,/";
      $cmd .= " CDEF:read_kB${i}=r${i},1,/";

      $cmd .= " CDEF:write_B${i}=write_kB${i},1024,*";
      $cmd .= " CDEF:read_B${i}=read_kB${i},1024,*";

      $cmd .= " CDEF:write_MB${i}=write_kB${i},1024,/";
      $cmd .= " CDEF:read_MB${i}=read_kB${i},1024,/";

      $cmd .= " CDEF:write_B_neg${i}=write_B${i},-1,*";
      $cmd .= " CDEF:read_B_neg${i}=read_B${i},-1,*";

      $cmd .= " COMMENT:\"$adapter_legend_png\"";
      $cmd .= " $gtype:read_B_neg${i}$color[$color_index]:\" \"";
      $cmd .= " GPRINT:read_MB${i}:AVERAGE:\" %5.2lf \"";
      $cmd .= " GPRINT:read_MB${i}:MAX:\" %5.2lf        \"";
      $cmd .= " PRINT:read_MB${i}:AVERAGE:\"%5.2lf $delimiter $item $delimiter $lpar $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:read_MB${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";

      $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

      $cmdx .= " $gtype:write_B${i}$color[$color_index]: ";
      $gtype = "STACK";
      $cmd .= " $gtype:0$color[$color_index]:\" \"";
      $cmd .= " GPRINT:write_MB${i}:AVERAGE:\" %5.2lf \"";
      $cmd .= " GPRINT:write_MB${i}:MAX:\" %5.2lf \"";
      $cmd .= " PRINT:write_MB${i}:AVERAGE:\"%5.2lf $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:write_MB${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";
      $cmd .= " $t2";
    }
    if ( $data_packets eq "data" && $lan_san eq "HEA" ) {
      $cmd .= " CDEF:write_kB${i}=w${i},1,/";
      $cmd .= " CDEF:read_kB${i}=r${i},1,/";

      $cmd .= " CDEF:write_B${i}=write_kB${i},1024,*";
      $cmd .= " CDEF:read_B${i}=read_kB${i},1024,*";

      $cmd .= " CDEF:write_MB${i}=write_kB${i},1024,/";
      $cmd .= " CDEF:read_MB${i}=read_kB${i},1024,/";

      $cmd .= " CDEF:write_B_neg${i}=write_B${i},-1,*";
      $cmd .= " CDEF:read_B_neg${i}=read_B${i},-1,*";

      $cmd .= " COMMENT:\"$adapter_legend_png\"";
      $cmd .= " $gtype:read_B_neg${i}$color[$color_index]:\" \"";
      $cmd .= " GPRINT:read_MB${i}:AVERAGE:\" %5.2lf \"";
      $cmd .= " GPRINT:read_MB${i}:MAX:\" %5.2lf        \"";
      $cmd .= " PRINT:read_MB${i}:AVERAGE:\"%5.2lf $delimiter $item $delimiter $lpar $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:read_MB${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";

      $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

      $cmdx .= " $gtype:write_B${i}$color[$color_index]: ";
      $gtype = "STACK";
      $cmd .= " $gtype:0$color[$color_index]:\" \"";
      $cmd .= " GPRINT:write_MB${i}:AVERAGE:\" %5.2lf \"";
      $cmd .= " GPRINT:write_MB${i}:MAX:\" %5.2lf \"";
      $cmd .= " PRINT:write_MB${i}:AVERAGE:\"%5.2lf $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:write_MB${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";
      $cmd .= " $t2";
    }
    elsif ( $data_packets eq "packets" && ( $lan_san eq "LAN" || $lan_san eq "SRI" || $lan_san eq "HEA" ) ) {
      $cmd .= " CDEF:write_packets${i}=io_w${i},1,/";
      $cmd .= " CDEF:read_packets${i}=io_r${i},1,/";
      $cmd .= " CDEF:write_packets_neg${i}=write_packets${i},-1,*";
      $cmd .= " CDEF:read_packets_neg${i}=read_packets${i},-1,*";

      $cmd .= " COMMENT:\"$adapter_legend_png\"";
      $cmd .= " $gtype:read_packets_neg${i}$color[$color_index]:\" \"";
      $cmd .= " GPRINT:read_packets${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:read_packets${i}:MAX:\" %.0lf        \"";
      $cmd .= " PRINT:read_packets${i}:AVERAGE:\"%.0lf $delimiter $item $delimiter $lpar $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:read_packets${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";

      $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

      $cmdx .= " $gtype:write_packets${i}$color[$color_index]: ";
      $gtype = "STACK";
      $cmd .= " $gtype:0$color[$color_index]:\" \"";
      $cmd .= " GPRINT:write_packets${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:write_packets${i}:MAX:\" %.0lf \"";
      $cmd .= " PRINT:write_packets${i}:AVERAGE:\"%.0lf $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:write_packets${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";
      $cmd .= " $t2";
    }
    elsif ( $data_packets eq "packets" && ( $lan_san eq "LAN" || $lan_san eq "SRI" || $lan_san eq "HEA" ) ) {
      $cmd .= " CDEF:write_packets${i}=io_w${i},1,/";
      $cmd .= " CDEF:read_packets${i}=io_r${i},1,/";
      $cmd .= " CDEF:write_packets_neg${i}=write_packets${i},-1,*";
      $cmd .= " CDEF:read_packets_neg${i}=read_packets${i},-1,*";

      $cmd .= " COMMENT:\"$adapter_legend_png\"";
      $cmd .= " $gtype:read_packets_neg${i}$color[$color_index]:\" \"";
      $cmd .= " GPRINT:read_packets${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:read_packets${i}:MAX:\" %.0lf        \"";
      $cmd .= " PRINT:read_packets${i}:AVERAGE:\"%.0lf $delimiter $item $delimiter $lpar $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:read_packets${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";

      $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

      $cmdx .= " $gtype:write_packets${i}$color[$color_index]: ";
      $gtype = "STACK";
      $cmd .= " $gtype:0$color[$color_index]:\" \"";
      $cmd .= " GPRINT:write_packets${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:write_packets${i}:MAX:\" %.0lf \"";
      $cmd .= " PRINT:write_packets${i}:AVERAGE:\"%.0lf $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:write_packets${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";
      $cmd .= " $t2";
    }
    elsif ( $data_packets eq "packets" && $lan_san eq "SAN" ) {
      $cmd .= " CDEF:write_iops${i}=io_w${i},1,/";
      $cmd .= " CDEF:read_iops${i}=io_r${i},1,/";
      $cmd .= " CDEF:write_iops_neg${i}=write_iops${i},-1,*";
      $cmd .= " CDEF:read_iops_neg${i}=read_iops${i},-1,*";

      $cmd .= " COMMENT:\"$adapter_legend_png\"";
      $cmd .= " $gtype:read_iops_neg${i}$color[$color_index]:\" \"";
      $cmd .= " GPRINT:read_iops${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:read_iops${i}:MAX:\" %.0lf        \"";
      $cmd .= " PRINT:read_iops${i}:AVERAGE:\"%.0lf $delimiter $item $delimiter $lpar $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:read_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";

      $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

      $cmdx .= " $gtype:write_iops${i}$color[$color_index]: ";
      $gtype = "STACK";
      $cmd .= " $gtype:0$color[$color_index]:\" \"";
      $cmd .= " GPRINT:write_iops${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:write_iops${i}:MAX:\" %.0lf \"";
      $cmd .= " PRINT:write_iops${i}:AVERAGE:\"%.0lf $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:write_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";
      $cmd .= " $t2";
    }
    elsif ( $data_packets eq "packets" && $lan_san eq "SAS" ) {
      $cmd .= " CDEF:write_iops${i}=io_w${i},1,/";
      $cmd .= " CDEF:read_iops${i}=io_r${i},1,/";
      $cmd .= " CDEF:write_iops_neg${i}=write_iops${i},-1,*";
      $cmd .= " CDEF:read_iops_neg${i}=read_iops${i},-1,*";

      $cmd .= " COMMENT:\"$adapter_legend_png\"";
      $cmd .= " $gtype:read_iops_neg${i}$color[$color_index]:\" \"";
      $cmd .= " GPRINT:read_iops${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:read_iops${i}:MAX:\" %.0lf        \"";
      $cmd .= " PRINT:read_iops${i}:AVERAGE:\"%.0lf $delimiter $item $delimiter $lpar $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:read_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";

      $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

      $cmdx .= " $gtype:write_iops${i}$color[$color_index]: ";
      $gtype = "STACK";
      $cmd .= " $gtype:0$color[$color_index]:\" \"";
      $cmd .= " GPRINT:write_iops${i}:AVERAGE:\" %.0lf \"";
      $cmd .= " GPRINT:write_iops${i}:MAX:\" %.0lf \"";
      $cmd .= " PRINT:write_iops${i}:AVERAGE:\"%.0lf $delimiter $color[$color_index]\"";
      $cmd .= " PRINT:write_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";
      $cmd .= " $t2";
    }
    $color_index = ( $color_index + 1 ) % ( $color_max + 1 );
    $cmd .= " COMMENT:\"\\l\"";
    $i++;
  }

  $cmd .= " $cmdx";
  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;    # a trick, there was a problem with aggregated and "COMMENT: "
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param( $ret, "", "", $data_packets );
  return 0;
}

# XenServer
sub graph_xenserver {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph XenServer stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $xenserver_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $xenserver_metadata = XenServerDataWrapperOOP->new( { acl_check => $xenserver_acl } );
  my $skip_acl           = ($xenserver_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = XenServerGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = XenServerGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/memory/ ) {
    $cmd_params    = XenServerGraph::get_params_memory();
    $label_context = 'MEM';
  }
  elsif ( $item =~ m/vbd/ ) {
    if ( $item =~ m/vbd-iops/ ) {
      $cmd_params    = XenServerGraph::get_params_storage('iops');
      $label_context = 'IOPS';
    }
    elsif ( $item =~ m/vbd-latency/ ) {
      $cmd_params    = XenServerGraph::get_params_storage('latency');
      $label_context = 'Latency';
    }
    else {
      $cmd_params    = XenServerGraph::get_params_storage();
      $label_context = 'Data';
    }
  }
  elsif ( $item =~ m/lan/ ) {
    $cmd_params    = XenServerGraph::get_params_lan();
    $label_context = 'LAN';
  }

  my ( $graph_info, $rrd );
  if ( $item =~ m/^xen-host/ ) {
    $label_context = 'Host ' . $label_context;
    if ( $item =~ m/^xen-host-cpu-percent$/ ) {
      $graph_info = XenServerGraph::graph_cpu( 'host', $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^xen-host-cpu-cores$/ ) {
      $graph_info = XenServerGraph::graph_cpu( 'host', $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^xen-host-memory$/ ) {
      $graph_info = XenServerGraph::graph_memory( 'host', $server, $skip_acl );
    }
    $rrd    = $xenserver_metadata->get_filepath_rrd( { type => 'host', uuid => $server } );
    $header = XenServerGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^xen-disk/ ) {
    $label_context = 'Disk ' . $label_context;
    if ( $item =~ m/^xen-disk-vbd$/ ) {
      $graph_info = XenServerGraph::graph_storage( 'host', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^xen-disk-vbd-iops$/ ) {
      $graph_info = XenServerGraph::graph_storage( 'host', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^xen-disk-vbd-latency$/ ) {
      $graph_info = XenServerGraph::graph_storage( 'host', $lpar, 'latency', $skip_acl );
    }
    $rrd    = $xenserver_metadata->get_filepath_rrd( { type => 'storage', uuid => $lpar } );
    $header = XenServerGraph::get_header( 'sr', $lpar, $label_context );
  }
  elsif ( $item =~ m/^xen-lan/ ) {
    $graph_info = XenServerGraph::graph_lan( 'host', $lpar, $skip_acl );
    $rrd        = $xenserver_metadata->get_filepath_rrd( { type => 'network', uuid => $lpar } );
    $header     = XenServerGraph::get_header( 'network', $lpar, $label_context );
  }
  elsif ( $item =~ m/^xen-vm/ ) {
    $label_context = 'VM ' . $label_context;
    if ( $item =~ m/^xen-vm-cpu-percent$/ ) {
      $graph_info = XenServerGraph::graph_cpu( 'vm', $lpar, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^xen-vm-cpu-cores$/ ) {
      $graph_info = XenServerGraph::graph_cpu( 'vm', $lpar, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^xen-vm-memory$/ ) {
      $graph_info = XenServerGraph::graph_memory( 'vm', $lpar, $skip_acl );
    }
    elsif ( $item =~ m/^xen-vm-vbd$/ ) {
      $graph_info = XenServerGraph::graph_storage( 'vm', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^xen-vm-vbd-iops$/ ) {
      $graph_info = XenServerGraph::graph_storage( 'vm', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^xen-vm-vbd-latency$/ ) {
      $graph_info = XenServerGraph::graph_storage( 'vm', $lpar, 'latency', $skip_acl );
    }
    elsif ( $item =~ m/^xen-vm-lan$/ ) {
      $graph_info = XenServerGraph::graph_lan( 'vm', $lpar, $skip_acl );
    }
    $rrd    = $xenserver_metadata->get_filepath_rrd( { type => 'vm', uuid => $lpar } );
    $header = XenServerGraph::get_header( 'vm', $lpar, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  # ACL check
  if ( !$rrd ) {
    error( "RRD filepath is not available, you might not be allowed to access it. " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }

  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_xenserver : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_xenserver_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph XenServer aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $xenserver_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $xenserver_metadata = XenServerDataWrapperOOP->new( { acl_check => $xenserver_acl } );
  my $skip_acl           = ($xenserver_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = XenServerGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = XenServerGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/memory/ ) {
    $cmd_params    = XenServerGraph::get_params_memory();
    $label_context = ( $item =~ m/memory-free/ ) ? 'MEM free' : 'MEM used';
  }
  elsif ( $item =~ m/vbd/ ) {
    if ( $item =~ m/vbd-iops/ ) {
      $cmd_params    = XenServerGraph::get_params_storage('iops');
      $label_context = 'IOPS';
    }
    elsif ( $item =~ m/vbd-latency/ ) {
      $cmd_params    = XenServerGraph::get_params_storage('latency');
      $label_context = 'Latency';
    }
    else {
      $cmd_params    = XenServerGraph::get_params_storage();
      $label_context = 'Data';
    }
  }
  elsif ( $item =~ m/lan/ ) {
    $cmd_params    = XenServerGraph::get_params_lan();
    $label_context = 'LAN aggregated';
  }

  my @uuids;
  if ( $item =~ m/^xen-host-vm-(.*)-aggr$/ ) {
    $label_context = 'VM ' . $label_context . ' aggregated';
    my @vms = @{ $xenserver_metadata->get_items( { item_type => 'vm', parent_type => 'host', parent_uuid => $server } ) };
    foreach my $vm (@vms) { my ( $k, $v ) = each %{$vm}; push @uuids, $k; }
    $header = XenServerGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^xen-host-(.*)-aggr$/ ) {
    $label_context = 'Hosts ' . $label_context . ' aggregated';
    my @hosts = @{ $xenserver_metadata->get_items( { item_type => 'host', parent_type => 'pool', parent_uuid => $server } ) };
    foreach my $host (@hosts) { my ( $k, $v ) = each %{$host}; push @uuids, $k; }
    $header = XenServerGraph::get_header( 'pool', $server, $label_context );
  }
  elsif ( $item =~ m/^xen-vm-(.*)-aggr$/ ) {
    $label_context = 'VM ' . $label_context . ' aggregated';
    my @vms = @{ $xenserver_metadata->get_items( { item_type => 'vm', parent_type => 'pool', parent_uuid => $server } ) };
    foreach my $vm (@vms) { my ( $k, $v ) = each %{$vm}; push @uuids, $k; }
    $header = XenServerGraph::get_header( 'pool', $server, $label_context );
  }
  elsif ( $item =~ m/^xen-lan-(.*)-aggr$/ ) {
    my @networks = @{ $xenserver_metadata->get_items( { item_type => 'network', parent_type => 'host', parent_uuid => $server } ) };
    foreach my $network (@networks) { my ( $k, $v ) = each %{$network}; push @uuids, $k; }
    $header = XenServerGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^xen-pool-vbd(.*)-aggr$/ ) {
    $label_context = 'Pool Disk ' . $label_context . ' aggregated';

    # when generating the graph command, for each UUID run $xenserver_metadata->get_items to get storages for each host
    my @hosts = @{ $xenserver_metadata->get_items( { item_type => 'host', parent_type => 'pool', parent_uuid => $server } ) };
    foreach my $host (@hosts) { my ( $k, $v ) = each %{$host}; push @uuids, $k; }
    $header = XenServerGraph::get_header( 'pool', $server, $label_context );
  }
  elsif ( $item =~ m/^xen-disk-(.*)-aggr$/ ) {
    $label_context = 'Disk ' . $label_context . ' aggregated';
    my @storages = @{ $xenserver_metadata->get_items( { item_type => 'storage', parent_type => 'host', parent_uuid => $server } ) };
    foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @uuids, $k; }
    $header = XenServerGraph::get_header( 'host', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";
  if ( $item =~ m/^xen-(host-vm|vm|host)-cpu-(percent|cores)-aggr$/ ) {
    my $metric_type = 'percent';
    if ( $item =~ m/cpu-cores/ ) { $metric_type = 'cores'; }
    $cmd_params = XenServerGraph::get_params_cpu($metric_type);

    my $domain_type = ( $item =~ m/^xen-(host-vm|vm)/ ) ? "vm"   : "host";
    my $group_type  = ( $item =~ m/^xen-host-vm/ )      ? "host" : "pool";

    my $legend_helper0 = ( $group_type eq 'host' ) ? "Host" : "Pool";
    my $legend_helper1 = ( $domain_type eq 'vm' )  ? "VM  " : "Host";
    $cmd_legend0 = " COMMENT:\"[%]\"";
    if ( $metric_type eq 'cores' ) { $cmd_legend0 = " COMMENT:\"[cores]\""; }
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {
      if ( $item =~ m/^xen-(host-vm|vm)/ ) {
        $filepath = $xenserver_metadata->get_filepath_rrd( { type => 'vm', uuid => $this_uuid } );
      }
      else {
        $filepath = $xenserver_metadata->get_filepath_rrd( { type => 'host', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $xenserver_metadata->get_label( $domain_type, $this_uuid );
      $grouplabel = $xenserver_metadata->get_label( $group_type,  $server );
      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = XenServerGraph::graph_cpu_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

  }
  elsif ( $item =~ m/^xen-(host-vm|vm|host)-memory-(used|free)-aggr$/ ) {
    my $metric_type = 'used';
    if ( $item =~ m/memory-free/ ) { $metric_type = 'free'; }
    $cmd_params = XenServerGraph::get_params_memory();

    my $domain_type = ( $item =~ m/^xen-(host-vm|vm)/ ) ? 'vm'   : 'host';
    my $group_type  = ( $item =~ m/^xen-host-vm/ )      ? 'host' : 'pool';

    my $legend_helper0 = ( $group_type eq 'host' ) ? 'Host' : 'Pool';
    my $legend_helper1 = ( $domain_type eq 'vm' )  ? 'VM  ' : 'Host';
    $cmd_legend0 = " COMMENT:\"[GB]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {
      if ( $item =~ m/^xen-(host-vm|vm)/ ) {
        $filepath = $xenserver_metadata->get_filepath_rrd( { type => 'vm', uuid => $this_uuid } );
      }
      else {
        $filepath = $xenserver_metadata->get_filepath_rrd( { type => 'host', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $xenserver_metadata->get_label( $domain_type, $this_uuid );
      $grouplabel = $xenserver_metadata->get_label( $group_type,  $server );
      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = XenServerGraph::graph_memory_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

  }
  elsif ( $item =~ m/^xen-lan-traffic-aggr$/ ) {
    $cmd_params = XenServerGraph::get_params_lan();

    $cmd_legend0 = " COMMENT:\"[MB/s]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"Host                 Interface             Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $host_interface (@uuids) {
      $filepath = $xenserver_metadata->get_filepath_rrd( { type => 'network', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $xenserver_metadata->get_label( 'network', $host_interface );
      $grouplabel = $xenserver_metadata->get_label( 'host',    $server );
      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = XenServerGraph::graph_lan_aggr( 'host', $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^xen-disk-(.*)-aggr$/ || $item =~ m/^xen-pool-vbd(.*)-aggr$/ ) {
    my $metric_type = 'vbd';
    if ( $item =~ m/^xen-(pool|disk)-vbd-iops-aggr$/ )    { $metric_type = 'iops'; }
    if ( $item =~ m/^xen-(pool|disk)-vbd-latency-aggr$/ ) { $metric_type = 'latency'; }

    if ( $metric_type eq 'vbd' ) {
      $cmd_params = XenServerGraph::get_params_storage();
    }
    else {
      $cmd_params = XenServerGraph::get_params_storage($metric_type);
    }

    my $units = 'MiB/s';
    if    ( $metric_type eq 'iops' )    { $units = 'iops'; }
    elsif ( $metric_type eq 'latency' ) { $units = 'millisec'; }
    $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"Host                 Storage               Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    if ( $item =~ m/^xen-pool-vbd(.*)-aggr$/ ) {
      foreach my $host_server (@uuids) {
        my @storage_uuids;
        my @storages = @{ $xenserver_metadata->get_items( { item_type => 'storage', parent_type => 'host', parent_uuid => $host_server } ) };
        foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @storage_uuids, $k; }

        # the following is a copy of the `else` branch, except s/$server/$host_server/; some code abstraction would be neat here
        foreach my $host_interface (@storage_uuids) {
          $filepath = $xenserver_metadata->get_filepath_rrd( { type => 'storage', uuid => $host_interface } );

          if ( !-f $filepath ) {
            error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
            next;
          }

          my $rrd_update_time = ( stat($filepath) )[9];

          # avoid old lpars which do not exist in the period
          if ( $rrd_update_time < $req_time ) {
            next;
          }
          if ( $rrd_update_time > $last_update_time ) {
            $last_update_time = $rrd_update_time;
          }

          $itemlabel  = $xenserver_metadata->get_label( 'sr',   $host_interface );
          $grouplabel = $xenserver_metadata->get_label( 'host', $host_server );
          $itemlabel  =~ s/:/\\:/g;
          $grouplabel =~ s/:/\\:/g;
          $itemcolor  = $color[ $itemcount % $#color ];
          $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

          my $graph = XenServerGraph::graph_storage_aggr( 'host', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
          $cmd_items        .= $graph->{cmd_def};
          $cmd_items        .= $graph->{cmd_cdef};
          $cmd_legend_lower .= $graph->{cmd_legend_lower};
          $cmd_legend_upper .= $graph->{cmd_legend_upper};

          $itemcount++;
        }
      }
    }
    else {
      foreach my $host_interface (@uuids) {
        $filepath = $xenserver_metadata->get_filepath_rrd( { type => 'storage', uuid => $host_interface } );

        if ( !-f $filepath ) {
          error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
          next;
        }

        my $rrd_update_time = ( stat($filepath) )[9];

        # avoid old lpars which do not exist in the period
        if ( $rrd_update_time < $req_time ) {
          next;
        }
        if ( $rrd_update_time > $last_update_time ) {
          $last_update_time = $rrd_update_time;
        }

        $itemlabel  = $xenserver_metadata->get_label( 'sr',   $host_interface );
        $grouplabel = $xenserver_metadata->get_label( 'host', $server );
        $itemlabel  =~ s/:/\\:/g;
        $grouplabel =~ s/:/\\:/g;
        $itemcolor  = $color[ $itemcount % $#color ];
        $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

        my $graph = XenServerGraph::graph_storage_aggr( 'host', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
        $cmd_items        .= $graph->{cmd_def};
        $cmd_items        .= $graph->{cmd_cdef};
        $cmd_legend_lower .= $graph->{cmd_legend_lower};
        $cmd_legend_upper .= $graph->{cmd_legend_upper};

        $itemcount++;
      }
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";

  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_xenserver_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# Nutanix
sub graph_nutanix {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Nutanix stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $nutanix_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $nutanix_metadata = NutanixDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, conf_spec => 1, acl_check => $nutanix_acl } );
  my $skip_acl         = ($nutanix_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = NutanixGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = NutanixGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/memory/ ) {
    $cmd_params    = NutanixGraph::get_params_memory();
    $label_context = 'MEM';
  }
  elsif ( $item =~ m/vbd/ ) {
    if ( $item =~ m/vbd-iops/ ) {
      $cmd_params    = NutanixGraph::get_params_storage('iops');
      $label_context = 'IOPS';
    }
    elsif ( $item =~ m/vbd-latency/ ) {
      if ( $item =~ m/^nutanix-disk-vbd/ ) {
        $cmd_params = NutanixGraph::get_params_storage('latency-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage('latency');
      }
      $label_context = 'Latency';
    }
    elsif ( $item =~ m/vm-vbd/ ) {
      $cmd_params    = NutanixGraph::get_params_storage('vm-total');
      $label_context = 'Data';
    }
    else {
      $cmd_params    = NutanixGraph::get_params_storage();
      $label_context = 'Data';
    }
  }
  elsif ( $item =~ m/lan/ ) {
    $cmd_params    = NutanixGraph::get_params_lan();
    $label_context = 'LAN';
  }
  my ( $graph_info, $rrd );
  if ( $item =~ m/^nutanix-host/ ) {
    $label_context = 'Host ' . $label_context;
    if ( $item =~ m/^nutanix-host-cpu-percent$/ ) {
      $graph_info = NutanixGraph::graph_cpu( 'host', $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-host-cpu-cores$/ ) {
      $graph_info = NutanixGraph::graph_cpu( 'host', $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-host-memory$/ ) {
      $graph_info = NutanixGraph::graph_memory( 'host', $server, $skip_acl );
    }
    $rrd    = $nutanix_metadata->get_filepath_rrd( { 'type' => 'host', 'uuid' => $server } );
    $header = NutanixGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk/ && $item !~ m/sc/ && $item !~ m/vd/ && $item !~ m/vg/ && $item !~ m/sp/ ) {
    $label_context = 'Disk ' . $label_context;
    if ( $item =~ m/^nutanix-disk-vbd$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'host', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-iops$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'host', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-latency$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'host', $lpar, 'latency', $skip_acl );
    }
    $rrd    = $nutanix_metadata->get_filepath_rrd( { 'type' => 'disk', 'uuid' => $lpar } );
    $header = NutanixGraph::get_header( 'disk', $lpar, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk/ && $item =~ m/sc/ ) {
    $label_context = 'Storage Container ' . $label_context;
    if ( $item =~ m/^nutanix-disk-vbd-sc$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'sc', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-iops-sc$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'sc', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-latency-sc$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'sc', $lpar, 'latency', $skip_acl );
    }
    $rrd    = $nutanix_metadata->get_filepath_rrd( { 'type' => 'container', 'uuid' => $lpar } );
    $header = NutanixGraph::get_header( 'container', $lpar, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk/ && $item =~ m/vd/ ) {
    $label_context = 'Virtual Disk ' . $label_context;
    if ( $item =~ m/^nutanix-disk-vbd-vd$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vd', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-iops-vd$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vd', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-latency-vd$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vd', $lpar, 'latency', $skip_acl );
    }
    $rrd    = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vdisk', 'uuid' => $lpar } );
    $header = NutanixGraph::get_header( 'vdisk', $lpar, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk/ && $item =~ m/vg/ ) {
    $label_context = 'Volume Group ' . $label_context;
    if ( $item =~ m/^nutanix-disk-vbd-vg$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vg', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-iops-vg$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vg', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-latency-vg$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vg', $lpar, 'latency', $skip_acl );
    }
    $rrd    = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vgroup', 'uuid' => $lpar } );
    $header = NutanixGraph::get_header( 'vgroup', $lpar, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk/ && $item =~ m/sp/ ) {
    $label_context = 'Storage Pool ' . $label_context;
    if ( $item =~ m/^nutanix-disk-vbd-sp$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'sp', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-iops-sp$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'sp', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-disk-vbd-latency-sp$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'sp', $lpar, 'latency', $skip_acl );
    }
    $rrd    = $nutanix_metadata->get_filepath_rrd( { 'type' => 'pool', 'uuid' => $lpar } );
    $header = NutanixGraph::get_header( 'pool', $lpar, $label_context );
  }
  elsif ( $item =~ m/^nutanix-lan/ ) {
    $graph_info = NutanixGraph::graph_lan( 'host', $lpar, $skip_acl );
    $rrd        = $nutanix_metadata->get_filepath_rrd( { 'type' => 'lan', 'uuid' => $lpar } );
    $header     = NutanixGraph::get_header( 'network', $lpar, $label_context );
  }
  elsif ( $item =~ m/^nutanix-vm/ ) {
    $label_context = 'VM ' . $label_context;
    if ( $item =~ m/^nutanix-vm-cpu-percent$/ ) {
      $graph_info = NutanixGraph::graph_cpu( 'vm', $lpar, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-vm-cpu-cores$/ ) {
      $graph_info = NutanixGraph::graph_cpu( 'vm', $lpar, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-vm-memory$/ ) {
      $graph_info = NutanixGraph::graph_memory( 'vm', $lpar, $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-vm-vbd$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vm', $lpar, 'vbd', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-vm-vbd-iops$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vm', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-vm-vbd-latency$/ ) {
      $graph_info = NutanixGraph::graph_storage( 'vm', $lpar, 'latency', $skip_acl );
    }
    elsif ( $item =~ m/^nutanix-vm-lan$/ ) {
      $graph_info = NutanixGraph::graph_lan( 'vm', $lpar, $skip_acl );
    }
    $rrd    = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vm', 'uuid' => $lpar } );
    $header = NutanixGraph::get_header( 'vm', $lpar, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_nutanix : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_nutanix_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Nutanix aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $nutanix_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $nutanix_metadata = NutanixDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, acl_check => $nutanix_acl } );
  my $skip_acl         = ($nutanix_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = NutanixGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = NutanixGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/memory/ ) {
    $cmd_params    = NutanixGraph::get_params_memory();
    $label_context = ( $item =~ m/memory-free/ ) ? 'MEM free' : 'MEM used';
  }
  elsif ( $item =~ m/vbd/ ) {
    if ( $item =~ m/vbd-iops/ ) {
      $cmd_params    = NutanixGraph::get_params_storage('iops');
      $label_context = 'IOPS';
    }
    elsif ( $item =~ m/vbd-latency/ ) {
      if ( $item =~ m/^nutanix-disk-vbd/ ) {
        $cmd_params = NutanixGraph::get_params_storage('latency-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage('latency');
      }
      $label_context = 'Latency';
    }
    elsif ( $item =~ m/vm-vbd/ ) {
      $cmd_params    = NutanixGraph::get_params_storage('vm-total');
      $label_context = 'Data';
    }
    else {
      $cmd_params    = NutanixGraph::get_params_storage();
      $label_context = 'Data';
    }
  }
  elsif ( $item =~ m/lan/ ) {
    $cmd_params    = NutanixGraph::get_params_lan();
    $label_context = 'LAN aggregated';
  }
  my @uuids;
  if ( $item =~ m/^nutanix-host-vm-(.*)-aggr$/ ) {
    $label_context = 'VM ' . $label_context . ' aggregated';
    my @vms = @{ $nutanix_metadata->get_items( { item_type => 'vm', parent_type => 'host', parent_uuid => $server } ) };
    foreach my $vm (@vms) { my ( $k, $v ) = each %{$vm}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-host-(.*)-aggr$/ ) {
    $label_context = 'Hosts ' . $label_context . ' aggregated';
    my @hosts = @{ $nutanix_metadata->get_items( { item_type => 'host', parent_type => 'cluster', parent_uuid => $server } ) };
    foreach my $host (@hosts) { my ( $k, $v ) = each %{$host}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-vm-(.*)-aggr$/ ) {
    $label_context = 'VM ' . $label_context . ' aggregated';
    my @vms = @{ $nutanix_metadata->get_items( { item_type => 'vm', parent_type => 'cluster', parent_uuid => $server } ) };
    my @sorting;
    foreach my $vm (@vms) {
      my ( $k, $v ) = each %{$vm};
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = NutanixGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-lan-(.*)-aggr$/ ) {
    my @networks = @{ $nutanix_metadata->get_items( { item_type => 'network', parent_type => 'host', parent_uuid => $server } ) };
    foreach my $network (@networks) { my ( $k, $v ) = each %{$network}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-pool-vbd(.*)-aggr$/ || $item =~ m/^nutanix-disk-(.*)-sr-aggr$/ ) {
    $label_context = 'Pool Disk ' . $label_context . ' aggregated';

    # when generating the graph command, for each UUID run $nutanix_metadata->get_items to get storages for each host
    my @hosts = @{ $nutanix_metadata->get_items( { item_type => 'host', parent_type => 'cluster', parent_uuid => $server } ) };
    foreach my $host (@hosts) { my ( $k, $v ) = each %{$host}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-sp-aggr$/ ) {
    $label_context = 'Storage ' . $label_context . ' aggregated';
    my @storages = @{ $nutanix_metadata->get_items( { item_type => 'pool', parent_type => 'cluster', parent_uuid => $server } ) };
    foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-vg-aggr$/ ) {
    $label_context = 'Volume Group ' . $label_context . ' aggregated';
    my @storages = @{ $nutanix_metadata->get_items( { item_type => 'vgroup', parent_type => 'cluster', parent_uuid => $server } ) };
    foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-vd-aggr$/ ) {
    $label_context = 'Virtual Disk ' . $label_context . ' aggregated';
    my @storages = @{ $nutanix_metadata->get_items( { item_type => 'vdisk', parent_type => 'cluster', parent_uuid => $server } ) };
    foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-sc-aggr$/ ) {
    $label_context = 'Storage Container ' . $label_context . ' aggregated';
    my @storages = @{ $nutanix_metadata->get_items( { item_type => 'container', parent_type => 'cluster', parent_uuid => $server } ) };
    foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-aggr$/ ) {
    $label_context = 'Disk ' . $label_context . ' aggregated';
    my @storages = @{ $nutanix_metadata->get_items( { item_type => 'disk', parent_type => 'host', parent_uuid => $server } ) };
    foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @uuids, $k; }
    $header = NutanixGraph::get_header( 'host', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";
  if ( $item =~ m/^nutanix-(host-vm|vm|host)-cpu-(percent|cores)-aggr$/ ) {
    my $metric_type = 'percent';
    if ( $item =~ m/cpu-cores/ ) { $metric_type = 'cores'; }
    $cmd_params = NutanixGraph::get_params_cpu($metric_type);

    my $domain_type = ( $item =~ m/^nutanix-(host-vm|vm)/ ) ? "vm"   : "host";
    my $group_type  = ( $item =~ m/^nutanix-host-vm/ )      ? "host" : "cluster";

    my $legend_helper0 = ( $group_type eq 'host' ) ? "Host" : "Cluster";
    my $legend_helper1 = ( $domain_type eq 'vm' )  ? "VM  " : "Host";
    $cmd_legend0 = " COMMENT:\"[%]\"";
    if ( $metric_type eq 'cores' ) { $cmd_legend0 = " COMMENT:\"[cores]\""; }
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {
      if ( $item =~ m/^nutanix-(host-vm|vm)/ ) {
        $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vm', 'uuid' => $this_uuid } );
      }
      else {
        $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'host', 'uuid' => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $nutanix_metadata->get_label( $domain_type, $this_uuid );
      $grouplabel = $nutanix_metadata->get_label( $group_type,  $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = NutanixGraph::graph_cpu_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

  }
  elsif ( $item =~ m/^nutanix-(host-vm|vm|host)-memory-(used|free)-aggr$/ ) {
    my $metric_type = 'used';
    if ( $item =~ m/memory-free/ ) { $metric_type = 'free'; }
    $cmd_params = NutanixGraph::get_params_memory();

    my $domain_type = ( $item =~ m/^nutanix-(host-vm|vm)/ ) ? 'vm'   : 'host';
    my $group_type  = ( $item =~ m/^nutanix-host-vm/ )      ? 'host' : 'cluster';

    my $legend_helper0 = ( $group_type eq 'host' ) ? 'Host' : 'Cluster';
    my $legend_helper1 = ( $domain_type eq 'vm' )  ? 'VM  ' : 'Host';
    $cmd_legend0 = " COMMENT:\"[GB]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {
      if ( $item =~ m/^nutanix-(host-vm|vm)/ ) {
        $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vm', 'uuid' => $this_uuid } );
      }
      else {
        $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'host', 'uuid' => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }
      $itemlabel  = $nutanix_metadata->get_label( $domain_type, $this_uuid );
      $grouplabel = $nutanix_metadata->get_label( $group_type,  $server );
      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = NutanixGraph::graph_memory_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

  }
  elsif ( $item =~ m/^nutanix-lan-traffic-aggr$/ || $item =~ m/^nutanix-vm-lan(.*)-aggr$/ ) {
    $cmd_params = NutanixGraph::get_params_lan();

    $cmd_legend0 = " COMMENT:\"[MB/s]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    if ( $item =~ m/^nutanix-vm-lan(.*)-aggr$/ ) {
      $cmd_legend0 .= " COMMENT:\"Cluster                 VM             Read     Avrg       Max      Write    Avrg      Max\\n\"";
    }
    else {
      $cmd_legend0 .= " COMMENT:\"Host                 Interface             Read     Avrg       Max      Write    Avrg      Max\\n\"";
    }

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $uuid (@uuids) {

      if ( $item =~ m/^nutanix-vm-lan(.*)-aggr$/ ) {
        $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vm', 'uuid' => $uuid } );
      }
      else {
        $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'lan', 'uuid' => $uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      if ( $item =~ m/^nutanix-vm-lan(.*)-aggr$/ ) {
        $itemlabel  = $nutanix_metadata->get_label( 'vm',      $uuid );
        $grouplabel = $nutanix_metadata->get_label( 'cluster', $server );
      }
      else {
        $itemlabel  = $nutanix_metadata->get_label( 'network', $uuid );
        $grouplabel = $nutanix_metadata->get_label( 'host',    $server );
      }
      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph;
      if ( $item =~ m/^nutanix-vm-lan(.*)-aggr$/ ) {
        $graph = NutanixGraph::graph_lan_aggr( 'vm', $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, 'pool' );
      }
      else {
        $graph = NutanixGraph::graph_lan_aggr( 'host', $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, 'pool' );
      }
      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-sp-aggr$/ || $item =~ m/^nutanix-pool-vbd(.*)-sp-aggr$/ || $item =~ m/^nutanix-vm-vbd(.*)-sp-aggr$/ ) {
    my $metric_type = 'vbd';
    if ( $item =~ m/^nutanix-disk-vbd-iops-sp-aggr$/ )    { $metric_type = 'iops'; }
    if ( $item =~ m/^nutanix-disk-vbd-latency-sp-aggr$/ ) { $metric_type = 'latency'; }
    if ( $metric_type eq 'vbd' ) {
      $cmd_params = NutanixGraph::get_params_storage();
    }
    else {
      if ( $item =~ m/^nutanix-disk-vbd-latency-sp-aggr$/ ) {
        $cmd_params = NutanixGraph::get_params_storage('latency-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage($metric_type);
      }
    }
    my $units = 'MB/s';
    if    ( $metric_type eq 'iops' )    { $units = 'iops'; }
    elsif ( $metric_type eq 'latency' ) { $units = 'millisec'; }

    if ( $metric_type eq 'latency' ) {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Latency     Avrg       Max\\n\"";
    }
    else {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Read     Avrg       Max      Write    Avrg      Max\\n\"";
    }

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $uuid (@uuids) {

      my $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'pool', 'uuid' => $uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $nutanix_metadata->get_label( 'pool',    $uuid );
      $grouplabel = $nutanix_metadata->get_label( 'cluster', $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = NutanixGraph::graph_storage_aggr( 'sp', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-sc-aggr$/ || $item =~ m/^nutanix-pool-vbd(.*)-sc-aggr$/ || $item =~ m/^nutanix-vm-vbd(.*)-sc-aggr$/ ) {
    my $metric_type = 'vbd';
    if ( $item =~ m/^nutanix-disk-vbd-iops-sc-aggr$/ )    { $metric_type = 'iops'; }
    if ( $item =~ m/^nutanix-disk-vbd-latency-sc-aggr$/ ) { $metric_type = 'latency'; }
    if ( $metric_type eq 'vbd' ) {
      $cmd_params = NutanixGraph::get_params_storage();
    }
    else {
      if ( $item =~ m/^nutanix-disk-vbd-latency-sc-aggr$/ ) {
        $cmd_params = NutanixGraph::get_params_storage('latency-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage($metric_type);
      }
    }
    my $units = 'MB/s';
    if    ( $metric_type eq 'iops' )    { $units = 'iops'; }
    elsif ( $metric_type eq 'latency' ) { $units = 'millisec'; }

    if ( $metric_type eq 'latency' ) {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Latency     Avrg       Max\\n\"";
    }
    else {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Read     Avrg       Max      Write    Avrg      Max\\n\"";
    }

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $uuid (@uuids) {

      my $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'container', 'uuid' => $uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $nutanix_metadata->get_label( 'container', $uuid );
      $grouplabel = $nutanix_metadata->get_label( 'cluster',   $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = NutanixGraph::graph_storage_aggr( 'sc', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-vd-aggr$/ || $item =~ m/^nutanix-pool-vbd(.*)-vd-aggr$/ || $item =~ m/^nutanix-vm-vbd(.*)-vd-aggr$/ ) {
    my $metric_type = 'vbd';
    if ( $item =~ m/^nutanix-disk-vbd-iops-vd-aggr$/ )    { $metric_type = 'iops'; }
    if ( $item =~ m/^nutanix-disk-vbd-latency-vd-aggr$/ ) { $metric_type = 'latency'; }
    if ( $metric_type eq 'vbd' ) {
      $cmd_params = NutanixGraph::get_params_storage();
    }
    else {
      if ( $item =~ m/^nutanix-disk-vbd-latency-vd-aggr$/ ) {
        $cmd_params = NutanixGraph::get_params_storage('latency-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage($metric_type);
      }
    }
    my $units = 'MB/s';
    if    ( $metric_type eq 'iops' )    { $units = 'iops'; }
    elsif ( $metric_type eq 'latency' ) { $units = 'millisec'; }

    if ( $metric_type eq 'latency' ) {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Latency     Avrg       Max\\n\"";
    }
    else {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Read     Avrg       Max      Write    Avrg      Max\\n\"";
    }

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $uuid (@uuids) {

      my $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vdisk', 'uuid' => $uuid } );

      if ( !-f $filepath ) {

        #error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }
      $itemlabel  = $nutanix_metadata->get_label( 'vdisk',   $uuid );
      $grouplabel = $nutanix_metadata->get_label( 'cluster', $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = NutanixGraph::graph_storage_aggr( 'vd', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-vg-aggr$/ || $item =~ m/^nutanix-pool-vbd(.*)-vg-aggr$/ || $item =~ m/^nutanix-vm-vbd(.*)-vg-aggr$/ ) {
    my $metric_type = 'vbd';
    if ( $item =~ m/^nutanix-disk-vbd-iops-vg-aggr$/ )    { $metric_type = 'iops'; }
    if ( $item =~ m/^nutanix-disk-vbd-latency-vg-aggr$/ ) { $metric_type = 'latency'; }
    if ( $metric_type eq 'vbd' ) {
      $cmd_params = NutanixGraph::get_params_storage();
    }
    else {
      if ( $item =~ m/^nutanix-disk-vbd-latency-vg-aggr$/ ) {
        $cmd_params = NutanixGraph::get_params_storage('latency-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage($metric_type);
      }
    }
    my $units = 'MB/s';
    if    ( $metric_type eq 'iops' )    { $units = 'iops'; }
    elsif ( $metric_type eq 'latency' ) { $units = 'millisec'; }

    if ( $metric_type eq 'latency' ) {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Latency     Avrg       Max\\n\"";
    }
    else {
      $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
      $cmd_legend0 .= " COMMENT:\\n";
      $cmd_legend0 .= " COMMENT:\"Cluster                 Storage Pool                       Read     Avrg       Max      Write    Avrg      Max\\n\"";
    }

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $uuid (@uuids) {

      my $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vgroup', 'uuid' => $uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $nutanix_metadata->get_label( 'vgroup',  $uuid );
      $grouplabel = $nutanix_metadata->get_label( 'cluster', $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = NutanixGraph::graph_storage_aggr( 'vg', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^nutanix-disk-(.*)-aggr$/ || $item =~ m/^nutanix-pool-vbd(.*)-aggr$/ || $item =~ m/^nutanix-vm-vbd(.*)-aggr$/ ) {
    my $metric_type = 'vbd';
    if ( $item =~ m/^nutanix-(pool|disk|vm)-vbd-iops-aggr$/ )       { $metric_type = 'iops'; }
    if ( $item =~ m/^nutanix-(pool|disk|vm)-vbd-latency-aggr$/ )    { $metric_type = 'latency'; }
    if ( $item =~ m/^nutanix-(pool|disk|vm)-vbd-iops-sr-aggr$/ )    { $metric_type = 'iops'; }
    if ( $item =~ m/^nutanix-(pool|disk|vm)-vbd-latency-sr-aggr$/ ) { $metric_type = 'latency'; }

    if ( $metric_type eq 'vbd' ) {
      if ( $item =~ m/vm-vbd-aggr/ ) {
        $cmd_params = NutanixGraph::get_params_storage('vm-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage();
      }
    }
    else {
      if ( $item =~ m/^nutanix-disk-vbd-latency-sr-aggr$/ || $item =~ m/^nutanix-disk-vbd-latency-aggr$/ ) {
        $cmd_params = NutanixGraph::get_params_storage('latency-total');
      }
      else {
        $cmd_params = NutanixGraph::get_params_storage($metric_type);
      }
    }

    my $units = 'MB/s';
    if    ( $metric_type eq 'iops' )    { $units = 'iops'; }
    elsif ( $metric_type eq 'latency' ) { $units = 'millisec'; }

    if ( $item =~ m/^nutanix-vm-vbd(.*)-aggr$/ ) {

      if ( $metric_type eq 'latency' ) {
        $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
        $cmd_legend0 .= " COMMENT:\\n";
        $cmd_legend0 .= " COMMENT:\"Cluster                 VM               Latency     Avrg       Max\\n\"";
      }
      else {
        $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
        $cmd_legend0 .= " COMMENT:\\n";
        $cmd_legend0 .= " COMMENT:\"Cluster                 VM               Read     Avrg       Max      Write    Avrg      Max\\n\"";
      }

    }
    else {

      if ( $metric_type eq 'latency' ) {
        $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
        $cmd_legend0 .= " COMMENT:\\n";
        $cmd_legend0 .= " COMMENT:\"Host                 Storage               Latency     Avrg       Max\\n\"";
      }
      else {
        $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
        $cmd_legend0 .= " COMMENT:\\n";
        $cmd_legend0 .= " COMMENT:\"Host                 Storage               Read     Avrg       Max      Write    Avrg      Max\\n\"";
      }

    }
    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    if ( $item =~ m/^nutanix-pool-vbd(.*)-aggr$/ || $item =~ m/^nutanix-disk-vbd(.*)-sr-aggr$/ ) {
      foreach my $host_server (@uuids) {
        my @storage_uuids;
        my @storages = @{ $nutanix_metadata->get_items( { item_type => 'disk', parent_type => 'host', parent_uuid => $host_server } ) };
        foreach my $storage (@storages) { my ( $k, $v ) = each %{$storage}; push @storage_uuids, $k; }

        foreach my $uuid (@storage_uuids) {
          $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'disk', 'uuid' => $uuid, 'parent' => $host_server } );

          if ( !-f $filepath ) {
            error( "$filepath ($uuid under $host_server) does not exist " . __FILE__ . ':' . __LINE__ );
            next;
          }
          my $rrd_update_time = ( stat($filepath) )[9];

          # avoid old lpars which do not exist in the period
          if ( $rrd_update_time < $req_time ) {
            next;
          }
          if ( $rrd_update_time > $last_update_time ) {
            $last_update_time = $rrd_update_time;
          }

          $itemlabel  = $nutanix_metadata->get_label( 'disk', $uuid );
          $grouplabel = $nutanix_metadata->get_label( 'host', $host_server );
          $itemlabel  =~ s/:/\\:/g;
          $grouplabel =~ s/:/\\:/g;
          $itemcolor  = $color[ $itemcount % $#color ];
          $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

          my $graph = NutanixGraph::graph_storage_aggr( 'host', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, 'pool' );
          $cmd_items        .= $graph->{cmd_def};
          $cmd_items        .= $graph->{cmd_cdef};
          $cmd_legend_lower .= $graph->{cmd_legend_lower};
          $cmd_legend_upper .= $graph->{cmd_legend_upper};

          $itemcount++;
        }
      }
    }
    else {
      foreach my $uuid (@uuids) {

        $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'disk', 'uuid' => $uuid } );

        if ( $item =~ m/^nutanix-vm-vbd(.*)-aggr$/ ) {
          $filepath = $nutanix_metadata->get_filepath_rrd( { 'type' => 'vm', 'uuid' => $uuid } );
        }

        if ( !-f $filepath ) {
          error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
          next;
        }

        my $rrd_update_time = ( stat($filepath) )[9];

        # avoid old lpars which do not exist in the period
        if ( $rrd_update_time < $req_time ) {
          next;
        }
        if ( $rrd_update_time > $last_update_time ) {
          $last_update_time = $rrd_update_time;
        }

        $itemlabel  = $nutanix_metadata->get_label( 'disk', $uuid );
        $grouplabel = $nutanix_metadata->get_label( 'host', $server );

        if ( $item =~ m/^nutanix-vm-vbd(.*)-aggr$/ ) {
          $itemlabel  = $nutanix_metadata->get_label( 'vm',      $uuid );
          $grouplabel = $nutanix_metadata->get_label( 'cluster', $server );
        }

        $itemlabel  =~ s/:/\\:/g;
        $grouplabel =~ s/:/\\:/g;
        $itemcolor  = $color[ $itemcount % $#color ];
        $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

        my $graph;

        if ( $item =~ m/^nutanix-vm-vbd(.*)-aggr$/ ) {
          $graph = NutanixGraph::graph_storage_aggr( 'vm', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, 'pool' );
        }
        else {
          $graph = NutanixGraph::graph_storage_aggr( 'host', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, 'pool' );
        }

        $cmd_items        .= $graph->{cmd_def};
        $cmd_items        .= $graph->{cmd_cdef};
        $cmd_legend_lower .= $graph->{cmd_legend_lower};
        $cmd_legend_upper .= $graph->{cmd_legend_upper};

        $itemcount++;
      }
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";

  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_Nutanix_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# AWS
sub graph_aws {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph AWS stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $aws_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $aws_metadata = AWSDataWrapperOOP->new( { acl_check => $aws_acl } );
  my $skip_acl     = ($aws_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = AWSGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = AWSGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = AWSGraph::get_params_storage();
    $label_context = 'Data';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = AWSGraph::get_params_lan();
    $label_context = 'LAN';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = AWSGraph::get_params_storage('iops');
    $label_context = 'IOPS';
  }

  my ( $graph_info, $rrd );
  if ( $item =~ m/^aws-ec2-cpu/ ) {
    $label_context = 'EC ' . $label_context;
    if ( $item =~ m/^aws-ec2-cpu-percent$/ ) {
      $graph_info = AWSGraph::graph_cpu( 'ec2', $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^aws-ec2-cpu-cores$/ ) {
      $graph_info = AWSGraph::graph_cpu( 'ec2', $server, 'cores', $skip_acl );
    }
    $rrd    = $aws_metadata->get_filepath_rrd( { type => 'ec2', uuid => $lpar } );
    $header = AWSGraph::get_header( 'ec2', $server, $label_context );
  }
  elsif ( $item =~ m/^aws-ec2/ ) {
    $label_context = 'EC2 ' . $label_context;
    if ( $item =~ m/^aws-ec2-data$/ ) {
      $graph_info = AWSGraph::graph_storage( 'ec2', $lpar, 'data', $skip_acl );
    }
    elsif ( $item =~ m/^aws-ec2-iops$/ ) {
      $graph_info = AWSGraph::graph_storage( 'ec2', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^aws-ec2-net$/ ) {
      $graph_info = AWSGraph::graph_lan( 'ec2', $lpar, 'lan', $skip_acl );
    }
    $rrd    = $aws_metadata->get_filepath_rrd( { type => 'ec2', uuid => $lpar } );
    $header = AWSGraph::get_header( 'ec2', $lpar, $label_context );
  }
  elsif ( $item =~ m/^aws-ebs/ ) {
    $label_context = 'EBS ' . $label_context;
    if ( $item =~ m/^aws-ebs-data$/ ) {
      $graph_info = AWSGraph::graph_storage( 'volume', $lpar, 'data', $skip_acl );
    }
    elsif ( $item =~ m/^aws-ebs-iops$/ ) {
      $graph_info = AWSGraph::graph_storage( 'volume', $lpar, 'iops', $skip_acl );
    }
    $rrd    = $aws_metadata->get_filepath_rrd( { type => 'volume', uuid => $lpar } );
    $header = AWSGraph::get_header( 'volume', $lpar, $label_context );
  }
  elsif ( $item =~ m/^aws-rds/ ) {
    $label_context = 'RDS ' . $label_context;
    if ( $item =~ m/^aws-rds-data$/ ) {
      $graph_info = AWSGraph::graph_storage( 'rds', $lpar, 'data', $skip_acl );
    }
    elsif ( $item =~ m/^aws-rds-iops$/ ) {
      $graph_info = AWSGraph::graph_storage( 'rds', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^aws-rds-net$/ ) {
      $graph_info = AWSGraph::graph_lan( 'rds', $lpar, 'lan', $skip_acl );
    }
    elsif ( $item =~ m/^aws-rds-latency$/ ) {
      $graph_info = AWSGraph::graph_storage( 'rds', $lpar, 'latency', $skip_acl );
    }
    elsif ( $item =~ m/^aws-rds-cpu-percent$/ ) {
      $graph_info = AWSGraph::graph_cpu( 'rds', $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^aws-rds-db-connection$/ ) {
      $graph_info = AWSGraph::graph_custom( 'rds', $server, 'db_connection', 'Count', '0', 'Connected', $skip_acl );
    }
    elsif ( $item =~ m/^aws-rds-mem-free$/ ) {
      $graph_info = AWSGraph::graph_custom( 'rds', $server, 'mem_free', 'Memory', '1', 'Free', $skip_acl );
    }
    elsif ( $item =~ m/^aws-rds-disk-free$/ ) {
      $graph_info = AWSGraph::graph_custom( 'rds', $server, 'disk_free', 'Storage', '1', 'Free', $skip_acl );
    }
    $rrd    = $aws_metadata->get_filepath_rrd( { type => 'rds', uuid => $lpar } );
    $header = AWSGraph::get_header( 'rds', $lpar, $label_context );
  }
  elsif ( $item =~ m/^aws-api/ ) {
    $label_context = 'API ' . $label_context;
    if ( $item =~ m/^aws-api-count$/ ) {
      $graph_info = AWSGraph::graph_custom( 'api', $server, 'count', 'Count', '0', 'API Request', $skip_acl );
    }
    elsif ( $item =~ m/^aws-api-five$/ ) {
      $graph_info = AWSGraph::graph_custom( 'api', $server, '5xx_error', 'Count', '0', '5xx Error', $skip_acl );
    }
    elsif ( $item =~ m/^aws-api-four$/ ) {
      $graph_info = AWSGraph::graph_custom( 'api', $server, '4xx_error', 'Count', '0', '4xx Error', $skip_acl );
    }
    elsif ( $item =~ m/^aws-api-latency$/ ) {
      $graph_info = AWSGraph::graph_custom( 'api', $server, 'latency', 'ms', '0', 'Latency', $skip_acl );
    }
    elsif ( $item =~ m/^aws-api-integration-latency$/ ) {
      $graph_info = AWSGraph::graph_custom( 'api', $server, 'integration_latency', 'ms', '0', 'Latency', $skip_acl );
    }

    $rrd    = $aws_metadata->get_filepath_rrd( { type => 'api', uuid => $lpar } );
    $header = AWSGraph::get_header( 'api', $lpar, $label_context );
  }
  elsif ( $item =~ m/^aws-lambda/ ) {
    $label_context = 'Lambda ' . $label_context;
    if ( $item =~ m/^aws-lambda-invocations$/ ) {
      $graph_info = AWSGraph::graph_custom( 'lambda', $server, 'invocations', 'Count', '0', 'Invocation', $skip_acl );
    }
    elsif ( $item =~ m/^aws-lambda-errors$/ ) {
      $graph_info = AWSGraph::graph_custom( 'lambda', $server, 'errors', 'Count', '0', 'Error', $skip_acl );
    }
    elsif ( $item =~ m/^aws-lambda-duration$/ ) {
      $graph_info = AWSGraph::graph_custom( 'lambda', $server, 'duration', 'ms', '0', 'Duration', $skip_acl );
    }
    elsif ( $item =~ m/^aws-lambda-throttles$/ ) {
      $graph_info = AWSGraph::graph_custom( 'lambda', $server, 'throttles', 'Count', '0', 'Throttles', $skip_acl );
    }
    elsif ( $item =~ m/^aws-lambda-concurrent-executions$/ ) {
      $graph_info = AWSGraph::graph_custom( 'lambda', $server, 'concurrent', 'Count', '0', 'Concurrent Executions', $skip_acl );
    }

    $rrd    = $aws_metadata->get_filepath_rrd( { type => 'lambda', uuid => $lpar } );
    $header = AWSGraph::get_header( 'lambda', $lpar, $label_context );

  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_aws : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_aws_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph AWS aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $aws_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $aws_metadata = AWSDataWrapperOOP->new( { acl_check => $aws_acl } );
  my $skip_acl     = ($aws_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = AWSGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = AWSGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = AWSGraph::get_params_storage('iops');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = AWSGraph::get_params_storage();
    $label_context = 'Data';
  }
  elsif ( $item =~ m/lan/ ) {
    $cmd_params    = AWSGraph::get_params_lan();
    $label_context = 'LAN aggregated';
  }
  elsif ( $item =~ m/running/ ) {
    $cmd_params    = AWSGraph::get_params_custom("instances");
    $label_context = 'running instances';
  }
  elsif ( $item =~ m/stopped/ ) {
    $cmd_params    = AWSGraph::get_params_custom("instances");
    $label_context = 'stopped instances';
  }

  my @uuids;
  if ( $item =~ m/^aws-ec2-(.*)-aggr$/ ) {
    $label_context = 'EC ' . $label_context . ' aggregated';
    my @ec2s = @{ $aws_metadata->get_items( { item_type => 'ec2', parent_type => 'region', parent_id => $server } ) };
    my @sorting;
    foreach my $ec2 (@ec2s) {
      my ( $k, $v ) = each %{$ec2};
      my $filepath = $aws_metadata->get_filepath_rrd( { type => 'ec2', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = AWSGraph::get_header( 'region', $server, $label_context );
  }
  elsif ( $item =~ m/^aws-region-(.*)-aggr$/ ) {
    $label_context = 'EBS ' . $label_context . ' aggregated';
    my @regions = @{ $aws_metadata->get_items( { item_type => 'region' } ) };
    my @sorting;
    foreach my $region (@regions) {
      my ( $k, $v ) = each %{$region};
      my $filepath = $aws_metadata->get_filepath_rrd( { type => 'region', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    if ( $item =~ m/stopped/ ) {
      $header = "Stopped instances";
    }
    else {
      $header = "Running instances";
    }
  }
  elsif ( $item =~ m/^aws-ebs-(.*)-aggr$/ ) {
    $label_context = 'EBS ' . $label_context . ' aggregated';
    my @ebs = @{ $aws_metadata->get_items( { item_type => 'volume', parent_type => 'region', parent_id => $server } ) };
    my @sorting;
    foreach my $volume (@ebs) {
      my ( $k, $v ) = each %{$volume};
      my $filepath = $aws_metadata->get_filepath_rrd( { type => 'volume', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = AWSGraph::get_header( 'region', $server, $label_context );
  }
  elsif ( $item =~ m/^aws-rds-(.*)-aggr$/ ) {
    $label_context = 'RDS ' . $label_context . ' aggregated';
    my @rds = @{ $aws_metadata->get_items( { item_type => 'rds', parent_type => 'region', parent_id => $server } ) };
    my @sorting;
    foreach my $db (@rds) {
      my ( $k, $v ) = each %{$db};
      my $filepath = $aws_metadata->get_filepath_rrd( { type => 'rds', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = AWSGraph::get_header( 'region', $server, $label_context );
  }
  elsif ( $item =~ m/^aws-api-(.*)-aggr$/ ) {
    $label_context = 'API ' . $label_context . ' aggregated';
    my @api = @{ $aws_metadata->get_items( { item_type => 'api', parent_type => 'region', parent_id => $server } ) };
    my @sorting;
    foreach my $ap (@api) {
      my ( $k, $v ) = each %{$ap};
      my $filepath = $aws_metadata->get_filepath_rrd( { type => 'api', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = AWSGraph::get_header( 'region', $server, $label_context );
  }
  elsif ( $item =~ m/^aws-lambda-(.*)-aggr$/ ) {
    $label_context = 'Lambda ' . $label_context . ' aggregated';
    my @lambdas = @{ $aws_metadata->get_items( { item_type => 'lambda', parent_type => 'region', parent_id => $server } ) };
    my @sorting;
    foreach my $lambda (@lambdas) {
      my ( $k, $v ) = each %{$lambda};
      my $filepath = $aws_metadata->get_filepath_rrd( { type => 'lambda', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = AWSGraph::get_header( 'region', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  if ( $item =~ m/^aws-(ec2|rds)-cpu-(percent|cores)-aggr$/ ) {
    my $metric_type = 'percent';
    if ( $item =~ m/cpu-cores/ ) { $metric_type = 'cores'; }
    $cmd_params = AWSGraph::get_params_cpu($metric_type);

    my $domain_type = ( $item =~ m/^aws-(ec2)/ ) ? "region" : "region";
    my $group_type  = ( $item =~ m/^aws-ec2/ )   ? "ec2"    : "region";
    if ( $item =~ m/rds/ ) { $domain_type = "rds"; $group_type = "rds"; }
    my $legend_helper0 = ( $group_type eq 'ec2' ) ? "ec2"   : "region";
    my $legend_helper1 = ( $domain_type eq 'vm' ) ? "ec2  " : "region";
    $cmd_legend0 = " COMMENT:\"[%]\"";
    if ( $metric_type eq 'cores' ) { $cmd_legend0 = " COMMENT:\"[cores]\""; }
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    my $labels = $aws_metadata->get_labels();

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/rds/ ) {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'rds', uuid => $this_uuid } );
      }
      else {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'ec2', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      if ( $item =~ m/rds/ ) {
        $itemlabel = $labels->{rds}{$this_uuid};
      }
      else {
        $itemlabel = $labels->{ec2}{$this_uuid};
      }
      $grouplabel = $server;

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = AWSGraph::graph_cpu_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

  }
  elsif ( $item =~ m/running/ || $item =~ m/stopped/ ) {
    $cmd_params = AWSGraph::get_params_custom("Instances in [Count]");

    my $inst_item = "running";
    if ( $item =~ m/stopped/ ) {
      $inst_item = "stopped";
    }

    $cmd_legend0 = " COMMENT:\"[Count]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"C     Region                                         Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    my $labels = $aws_metadata->get_labels();

    foreach my $host_interface (@uuids) {

      $filepath = $aws_metadata->get_filepath_rrd( { type => 'region', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $host_interface;
      $grouplabel = $host_interface;

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph = AWSGraph::graph_instances_aggr( 'ec2', $inst_item, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, 'region' );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    #error("$cmd_items");

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^aws-(rds)-(db-connection|mem-free|disk-free)-aggr$/ || $item =~ /^aws-api/ || $item =~ /^aws-lambda/ ) {
    my $metric_type = 'db_connection';
    my $par         = "Connections in [Count]";
    if ( $item =~ m/mem-free/ )            { $metric_type = 'mem_free';            $par = "Memory in [GB]"; }
    if ( $item =~ m/disk-free/ )           { $metric_type = 'disk_free';           $par = "Storage in [GB]"; }
    if ( $item =~ m/count/ )               { $metric_type = 'count';               $par = "Requests in [Count]"; }
    if ( $item =~ m/latency/ )             { $metric_type = 'latency';             $par = "Latency in [ms]"; }
    if ( $item =~ m/integration_latency/ ) { $metric_type = 'integration_latency'; $par = "Latency in [ms]"; }
    if ( $item =~ m/five/ )                { $metric_type = '5xx_error';           $par = "Erros in [Count]"; }
    if ( $item =~ m/four/ )                { $metric_type = '4xx_error';           $par = "Erros in [Count]"; }

    if ( $item =~ m/lambda-invocations/ )           { $metric_type = 'invocations'; $par = "Invocations in [Count]"; }
    if ( $item =~ m/lambda-errors/ )                { $metric_type = 'errors';      $par = "Erros in [Count]"; }
    if ( $item =~ m/lambda-duration/ )              { $metric_type = 'duration';    $par = "Durations in [ms]"; }
    if ( $item =~ m/lambda-throttles/ )             { $metric_type = 'throttles';   $par = "Throttles in [Count]"; }
    if ( $item =~ m/lambda-concurrent-executions/ ) { $metric_type = 'concurrent';  $par = "Concurrent Ex. in [Count]"; }

    $cmd_params = AWSGraph::get_params_custom($par);

    my ( $domain_type, $group_type );
    if ( $item =~ m/rds/ )    { $domain_type = "rds";    $group_type = "rds"; }
    if ( $item =~ m/api/ )    { $domain_type = "api";    $group_type = "api"; }
    if ( $item =~ m/lambda/ ) { $domain_type = "lambda"; $group_type = "lambda"; }
    my $legend_helper0 = ( $group_type eq 'ec2' ) ? "ec2"   : "region";
    my $legend_helper1 = ( $domain_type eq 'vm' ) ? "ec2  " : "region";
    $cmd_legend0 = " COMMENT:\"[%]\"";
    if ( $metric_type eq 'cores' ) { $cmd_legend0 = " COMMENT:\"[cores]\""; }
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    my $labels = $aws_metadata->get_labels();

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/rds/ ) {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'rds', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/api/ ) {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'api', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/lambda/ ) {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'lambda', uuid => $this_uuid } );
      }
      else {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'ec2', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}{$this_uuid};
      $grouplabel = $server;

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];
      my $i = 1;
      if ( $item =~ m/db/ || $item =~ m/api/ || $item =~ m/lambda/ ) {
        $i = 0;
      }
      my $graph = AWSGraph::graph_custom_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $i );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

  }
  elsif ( $item =~ m/^aws-ec2-net-aggr$/ || $item =~ m/^aws-rds-net-aggr$/ ) {
    $cmd_params = AWSGraph::get_params_lan();

    $cmd_legend0 = " COMMENT:\"[MB/s]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"Host                 Interface             Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    my $labels = $aws_metadata->get_labels();

    foreach my $host_interface (@uuids) {

      if ( $item =~ m/^aws-rds-net-aggr$/ ) {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'rds', uuid => $host_interface } );
      }
      else {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'ec2', uuid => $host_interface } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{ec2}{$host_interface};
      $grouplabel = $server;

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph;

      if ( $item =~ m/^aws-rds-net-aggr$/ ) {
        $graph = AWSGraph::graph_lan_aggr( 'rds', $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
      }
      else {
        $graph = AWSGraph::graph_lan_aggr( 'ec2', $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
      }

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^aws-ec2-data-aggr$/ || $item =~ m/^aws-ec2-iops-aggr$/ || $item =~ m/^aws-ebs-data-aggr$/ || $item =~ m/^aws-ebs-iops-aggr$/ || $item =~ m/^aws-rds-data-aggr$/ || $item =~ m/^aws-rds-iops-aggr$/ || $item =~ m/^aws-rds-latency-aggr$/ ) {
    my $metric_type = 'data';
    if ( $item =~ m/^aws-ec2-iops-aggr$/ || $item =~ m/^aws-ebs-iops-aggr$/ || $item =~ m/^aws-rds-iops-aggr$/ ) { $metric_type = 'iops'; }
    if ( $item =~ m/^aws-rds-latency-aggr$/ ) { $metric_type = 'latency'; }
    if ( $metric_type eq 'data' ) {
      $cmd_params = AWSGraph::get_params_storage();
    }
    else {
      $cmd_params = NutanixGraph::get_params_storage($metric_type);
    }

    my $units = 'MiB/s';
    if ( $metric_type eq 'iops' ) { $units = 'iops'; }

    $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"Region                 EC2                       Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    my $labels = $aws_metadata->get_labels();

    foreach my $host_interface (@uuids) {

      my $filepath;
      if ( $item =~ m/ebs/ ) {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'volume', uuid => $host_interface } );
      }
      elsif ( $item =~ m/rds/ ) {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'rds', uuid => $host_interface } );
      }
      else {
        $filepath = $aws_metadata->get_filepath_rrd( { type => 'ec2', uuid => $host_interface } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      if ( $item =~ m/ebs/ ) {
        $itemlabel = $labels->{volume}{$host_interface};
      }
      elsif ( $item =~ m/rds/ ) {
        $itemlabel = $labels->{rds}{$host_interface};
      }
      else {
        $itemlabel = $labels->{ec2}{$host_interface};
      }
      $grouplabel = $server;

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph;
      if ( $item =~ m/ebs/ ) {
        $graph = AWSGraph::graph_storage_aggr( 'ebs', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
      }
      elsif ( $item =~ m/rds/ ) {
        $graph = AWSGraph::graph_storage_aggr( 'rds', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
      }
      else {
        $graph = AWSGraph::graph_storage_aggr( 'ec2', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
      }

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_AWS_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# GCloud
sub graph_gcloud {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph GCloud stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $gcloud_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $gcloud_metadata = GCloudDataWrapperOOP->new( { conf_agent => 1, acl_check => $gcloud_acl } );
  my $skip_acl        = ($gcloud_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';

  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = GCloudGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = GCloudGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/data/ && $item !~ m/database/ ) {
    $cmd_params    = GCloudGraph::get_params_storage();
    $label_context = 'Data';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = GCloudGraph::get_params_lan();
    $label_context = 'LAN';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = GCloudGraph::get_params_storage('iops');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = GCloudGraph::get_params_memory();
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/proc/ ) {
    $cmd_params    = GCloudGraph::get_params_proc();
    $label_context = 'Processes';
  }
  elsif ( $item =~ m/storage/ ) {
    $cmd_params    = GCloudGraph::get_params_custom('Storage in [GiB]');
    $label_context = 'Processes';
  }
  else {
    $cmd_params    = GCloudGraph::get_params_custom(' ');
    $label_context = ' ';
  }

  my ( $graph_info, $rrd );
  if ( $item =~ m/^gcloud-compute-cpu/ ) {
    $label_context = 'Compute Engine ' . $label_context;
    if ( $item =~ m/^gcloud-compute-cpu-percent$/ ) {
      $graph_info = GCloudGraph::graph_cpu( 'compute', $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-compute-cpu-cores$/ ) {
      $graph_info = GCloudGraph::graph_cpu( 'compute', $server, 'cores', $skip_acl );
    }
    $rrd    = $gcloud_metadata->get_filepath_rrd( { type => 'compute', uuid => $server } );
    $header = GCloudGraph::get_header( 'compute', $server, $label_context );
  }
  elsif ( $item =~ m/^gcloud-compute/ ) {
    $label_context = 'Compute Engine ' . $label_context;
    if ( $item =~ m/^gcloud-compute-data$/ ) {
      $graph_info = GCloudGraph::graph_storage( 'compute', $lpar, 'data', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-compute-iops$/ ) {
      $graph_info = GCloudGraph::graph_storage( 'compute', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-compute-net$/ ) {
      $graph_info = GCloudGraph::graph_lan( 'compute', $lpar, 'lan', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-compute-mem$/ ) {
      $graph_info = GCloudGraph::graph_memory( 'compute', $lpar, 'mem', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-compute-proc$/ ) {
      $graph_info = GCloudGraph::graph_processes( 'compute', $lpar, 'proc', $skip_acl );
    }
    $rrd    = $gcloud_metadata->get_filepath_rrd( { type => 'compute', uuid => $lpar } );
    $header = GCloudGraph::get_header( 'compute', $lpar, $label_context );
  }
  elsif ( $item =~ m/^gcloud-database/ ) {
    $label_context = 'Google SQL ' . $label_context;

    if ( $item =~ m/^gcloud-database-cpu-percent$/ ) {
      $graph_info = GCloudGraph::graph_cpu( 'database', $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-iops$/ ) {
      $graph_info = GCloudGraph::graph_storage( 'database', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-net$/ ) {
      $graph_info = GCloudGraph::graph_lan( 'database', $lpar, 'lan', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-mem$/ ) {
      $graph_info = GCloudGraph::graph_memory( 'database', $lpar, 'mem', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-storage$/ ) {
      $graph_info = GCloudGraph::graph_storage_db( 'database', $lpar, 'storage', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-connections$/ ) {
      $graph_info = GCloudGraph::graph_custom( 'database', $lpar, 'connections', 'Count', '0', 'Connected', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-queries$/ ) {
      $graph_info = GCloudGraph::graph_custom( 'database', $lpar, 'queries', 'Count', '0', 'Queries', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-questions$/ ) {
      $graph_info = GCloudGraph::graph_custom( 'database', $lpar, 'questions', 'Count', '0', 'Questions', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-innodb-data$/ ) {
      $graph_info = GCloudGraph::graph_custom( 'database', $lpar, 'innodb_data_fsyncs', 'Count', '0', 'fsync() calls', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-innodb-log$/ ) {
      $graph_info = GCloudGraph::graph_custom( 'database', $lpar, 'innodb_os_fsyncs', 'Count', '0', 'fsync() log', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-innodb-buffer$/ ) {
      $graph_info = GCloudGraph::graph_custom_2( 'database', $lpar, 'innodb_buffer_free', 'innodb_buffer_total', 'Buffer free', 'Buffer used', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-innodb-pages$/ ) {
      $graph_info = GCloudGraph::graph_pages( 'database', $lpar, 'pages', $skip_acl );
    }
    elsif ( $item =~ m/^gcloud-database-transactions$/ ) {
      $graph_info = GCloudGraph::graph_custom( 'database', $lpar, 'transaction_count', 'Count', '0', 'Transactions', $skip_acl );
    }

    #error(Dumper($graph_info));

    $rrd    = $gcloud_metadata->get_filepath_rrd( { type => 'database', uuid => $lpar } );
    $header = GCloudGraph::get_header( 'database', $lpar, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_gcloud : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_gcloud_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph GCloud aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $gcloud_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $gcloud_metadata = GCloudDataWrapperOOP->new( { conf_agent => 1, acl_check => $gcloud_acl } );
  my $skip_acl        = ($gcloud_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = GCloudGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = GCloudGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = GCloudGraph::get_params_storage('iops');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = GCloudGraph::get_params_storage();
    $label_context = 'Data';
  }
  elsif ( $item =~ m/lan/ ) {
    $cmd_params    = GCloudGraph::get_params_lan();
    $label_context = 'LAN aggregated';
  }
  elsif ( $item =~ m/running/ ) {
    $cmd_params    = GCloudGraph::get_params_custom("test");
    $label_context = 'running instances';
  }
  elsif ( $item =~ m/stopped/ ) {
    $cmd_params    = GCloudGraph::get_params_custom("test");
    $label_context = 'stopped instances';
  }

  my @uuids;
  if ( $item =~ m/^gcloud-compute-(.*)-aggr$/ && $item !~ m/^gcloud-compute-(running|stopped)/ ) {
    $label_context = 'Compute Engine ' . $label_context . ' aggregated ';
    my @computes = @{ $gcloud_metadata->get_items( { item_type => 'compute', parent_type => 'region', parent_id => $server } ) };
    my @sorting;
    foreach my $compute (@computes) {
      my ( $k, $v ) = each %{$compute};
      my $filepath = $gcloud_metadata->get_filepath_rrd( { type => 'compute', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = GCloudGraph::get_header( 'region', $server, $label_context );
  }
  elsif ( $item =~ m/^gcloud-compute-(running|stopped)/ ) {
    $label_context = 'Compute Engine ' . $label_context . ' aggregated ';
    my @regions = @{ $gcloud_metadata->get_items( { item_type => 'region' } ) };
    my @sorting;
    foreach my $region (@regions) {
      my ( $k, $v ) = each %{$region};
      my $filepath = $gcloud_metadata->get_filepath_rrd( { type => 'region', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    if ( $item =~ m/^gcloud-compute-stopped/ ) {
      $header = "Stopped instances";
    }
    else {
      $header = "Running instances";
    }
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  if ( $item =~ m/^gcloud-(compute)-cpu-(percent|cores)-aggr$/ ) {
    my $metric_type = 'percent';
    if ( $item =~ m/cpu-cores/ ) { $metric_type = 'cores'; }
    $cmd_params = GCloudGraph::get_params_cpu($metric_type);

    my $domain_type = ( $item =~ m/^gcloud-(compute)/ ) ? "compute" : "region";
    my $group_type  = ( $item =~ m/^gcloud-compute/ )   ? "compute" : "region";

    my $legend_helper0 = ( $group_type eq 'compute' ) ? "compute"   : "region";
    my $legend_helper1 = ( $domain_type eq 'vm' )     ? "compute  " : "region";
    $cmd_legend0 = " COMMENT:\"[%]\"";
    if ( $metric_type eq 'cores' ) { $cmd_legend0 = " COMMENT:\"[cores]\""; }
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $gcloud_metadata->get_filepath_rrd( { type => 'compute', uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}

      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $gcloud_metadata->get_label( $domain_type, $this_uuid );
      $grouplabel = $gcloud_metadata->get_label( $group_type,  $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = GCloudGraph::graph_cpu_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }
  }
  elsif ( $item =~ m/^gcloud-compute-data-aggr$/ || $item =~ m/^gcloud-compute-iops-aggr$/ ) {
    my $metric_type = 'data';
    if ( $item =~ m/^gcloud-compute-iops-aggr$/ ) { $metric_type = 'iops'; }
    if ( $metric_type eq 'data' ) {
      $cmd_params = GCloudGraph::get_params_storage();
    }
    else {
      $cmd_params = GCloudGraph::get_params_storage($metric_type);
    }

    my $units = 'MiB/s';
    if ( $metric_type eq 'iops' ) { $units = 'iops'; }

    $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"Region                 EC2                       Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

    my $itemcount = 0;
    foreach my $host_interface (@uuids) {

      my $filepath;
      $filepath = $gcloud_metadata->get_filepath_rrd( { type => 'compute', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}

      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $gcloud_metadata->get_label( 'compute', $host_interface );
      $grouplabel = $gcloud_metadata->get_label( 'region',  $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph;
      $graph = GCloudGraph::graph_storage_aggr( 'compute', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^gcloud-compute-net-aggr$/ ) {
    $cmd_params = GCloudGraph::get_params_lan();

    $cmd_legend0 = " COMMENT:\"[MB/s]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"Host                 Interface             Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $host_interface (@uuids) {

      $filepath = $gcloud_metadata->get_filepath_rrd( { type => 'compute', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}

      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }
      $itemlabel  = $gcloud_metadata->get_label( 'compute', $host_interface );
      $grouplabel = $gcloud_metadata->get_label( 'region',  $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph;

      $graph = GCloudGraph::graph_lan_aggr( 'compute', $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^gcloud-compute-mem-free-aggr$/ || $item =~ m/^gcloud-compute-mem-used-aggr$/ ) {
    $cmd_params = GCloudGraph::get_params_memory();

    my $mem_item = "free";
    if ( $item =~ m/^gcloud-compute-mem-used-aggr$/ ) {
      $mem_item = "used";
    }

    $cmd_legend0 = " COMMENT:\"[GB]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"Host                 Interface             Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    my $config_vm_agent = $gcloud_metadata->get_conf_section('spec-compute');

    foreach my $host_interface (@uuids) {

      my $agent = $config_vm_agent->{$host_interface}{agent};

      if ( defined $agent && $agent eq "0" ) {
        next;
      }

      $filepath = $gcloud_metadata->get_filepath_rrd( { type => 'compute', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }
      $itemlabel  = $gcloud_metadata->get_label( 'compute', $host_interface );
      $grouplabel = $gcloud_metadata->get_label( 'region',  $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph;
      $graph = GCloudGraph::graph_memory_aggr( 'compute', $mem_item, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, 'region' );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    if ( $itemcount eq "0" ) {
      error("no VM in this region contains Google Cloud Agent!");
    }

    #error("test: $cmd_items");

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^gcloud-compute-running/ || $item =~ m/^gcloud-compute-stopped/ ) {
    $cmd_params = GCloudGraph::get_params_custom("Instances in [Count]");

    my $inst_item = "running";
    if ( $item =~ m/^gcloud-compute-stopped/ ) {
      $inst_item = "stopped";
    }

    $cmd_legend0 = " COMMENT:\"[Count]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"C     Region                                         Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $host_interface (@uuids) {

      $filepath = $gcloud_metadata->get_filepath_rrd( { type => 'region', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $gcloud_metadata->get_label( 'region', $host_interface );
      $grouplabel = $gcloud_metadata->get_label( 'region', $host_interface );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph = GCloudGraph::graph_instances_aggr( 'compute', $inst_item, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, 'region' );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    #error("$cmd_items");

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_GCloud_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# Azure
sub graph_azure {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Azure stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $azure_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $azure_metadata = AzureDataWrapperOOP->new( { acl_check => $azure_acl } );
  my $skip_acl       = ($azure_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = AzureGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = AzureGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = AzureGraph::get_params_storage();
    $label_context = 'Data';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = AzureGraph::get_params_lan();
    $label_context = 'LAN';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = AzureGraph::get_params_storage('iops');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = AzureGraph::get_params_memory();
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/cpu-time/ ) {
    $cmd_params    = AzureGraph::get_params_custom('CPU Time in [s]');
    $label_context = 'CPU Time';
  }
  elsif ( $item =~ m/http/ ) {
    $cmd_params    = AzureGraph::get_params_custom('HTTP codes in [count]');
    $label_context = 'HTTP codes';
  }
  elsif ( $item =~ m/response/ ) {
    $cmd_params    = AzureGraph::get_params_custom('Response time in [s]');
    $label_context = 'Response time';
  }
  elsif ( $item =~ m/connections/ ) {
    $cmd_params    = AzureGraph::get_params_custom('Connections in [count]');
    $label_context = 'Connections';
  }

  my $config_vm = $azure_metadata->get_conf_section('spec-vm');
  my $agent     = $config_vm->{$lpar}{agent};

  my ( $graph_info, $rrd );
  if ( $item =~ m/^azure-vm-cpu/ ) {
    $label_context = 'Virtual Machine ' . $label_context;
    if ( $item =~ m/^azure-vm-cpu-percent$/ ) {
      $graph_info = AzureGraph::graph_cpu( 'vm', $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^azure-vm-cpu-cores$/ ) {
      $graph_info = AzureGraph::graph_cpu( 'vm', $server, 'cores', $skip_acl );
    }
    $rrd    = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $server } );
    $header = AzureGraph::get_header( 'vm', $server, $label_context );
  }
  elsif ( $item =~ m/^azure-vm/ ) {
    $label_context = 'Virtual Machine ' . $label_context;
    if ( $item =~ m/^azure-vm-data$/ ) {
      $graph_info = AzureGraph::graph_storage( 'vm', $lpar, 'data', $skip_acl );
    }
    elsif ( $item =~ m/^azure-vm-iops$/ ) {
      $graph_info = AzureGraph::graph_storage( 'vm', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^azure-vm-net$/ ) {
      $graph_info = AzureGraph::graph_lan( 'vm', $lpar, 'lan', $skip_acl );
    }
    elsif ( $item =~ m/^azure-vm-mem$/ ) {
      if ( $agent eq "1" ) {
        $graph_info = AzureGraph::graph_memory( 'vm', $lpar, 'memory', $skip_acl );
      }
    }
    $rrd    = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $lpar } );
    $header = AzureGraph::get_header( 'vm', $lpar, $label_context );
  }
  elsif ( $item =~ m/^azure-app/ ) {
    $label_context = 'App Service ' . $label_context;

    if ( $item =~ m/^azure-app-data$/ ) {
      $graph_info = AzureGraph::graph_storage( 'appService', $lpar, 'data', $skip_acl );
    }
    elsif ( $item =~ m/^azure-app-iops$/ ) {
      $graph_info = AzureGraph::graph_storage( 'appService', $lpar, 'iops', $skip_acl );
    }
    elsif ( $item =~ m/^azure-app-net$/ ) {
      $graph_info = AzureGraph::graph_lan( 'appService', $lpar, 'lan', $skip_acl );
    }
    elsif ( $item =~ m/^azure-app-http$/ ) {
      $graph_info = AzureGraph::graph_http( $lpar, $skip_acl );
    }
    elsif ( $item =~ m/^azure-app-cpu-time$/ ) {
      $graph_info = AzureGraph::graph_cpu_time( $lpar, $skip_acl );
    }
    elsif ( $item =~ m/^azure-app-response$/ ) {
      $graph_info = AzureGraph::graph_response( $lpar, $skip_acl );
    }
    elsif ( $item =~ m/^azure-app-connections$/ ) {
      $graph_info = AzureGraph::graph_connection( $lpar, $skip_acl );
    }

    $rrd    = $azure_metadata->get_filepath_rrd( { type => 'app', uuid => $lpar } );
    $header = AzureGraph::get_header( 'appService', $lpar, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_azure : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_azure_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Azure aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $azure_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $azure_metadata = AzureDataWrapperOOP->new( { acl_check => $azure_acl } );
  my $skip_acl       = ($azure_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = AzureGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = AzureGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = AzureGraph::get_params_storage('iops');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = AzureGraph::get_params_storage();
    $label_context = 'Data';
  }
  elsif ( $item =~ m/lan/ ) {
    $cmd_params    = AzureGraph::get_params_lan();
    $label_context = 'LAN aggregated';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = AzureGraph::get_params_memory();
    $label_context = 'Memory aggregated';
  }
  elsif ( $item =~ m/running/ ) {
    $cmd_params    = AzureGraph::get_params_custom("instances");
    $label_context = 'running instances';
  }
  elsif ( $item =~ m/stopped/ ) {
    $cmd_params    = AzureGraph::get_params_custom("instances");
    $label_context = 'stopped instances';
  }

  my @uuids;
  if ( $item =~ m/^azure-vm-(.*)-aggr$/ ) {
    $label_context = 'Virtual Machine ' . $label_context . ' aggregated ';
    my @vms = @{ $azure_metadata->get_items( { item_type => 'vm', parent_type => 'location', parent_id => $server } ) };
    my @sorting;
    foreach my $vm (@vms) {
      my ( $k, $v ) = each %{$vm};
      my $filepath = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = AzureGraph::get_header( 'location', $server, $label_context );
  }
  elsif ( $item =~ m/^azure-vm-(.*)-aggr-res$/ ) {
    $label_context = 'Virtual Machine ' . $label_context . ' aggregated ';
    my @vms = @{ $azure_metadata->get_items( { item_type => 'vm', parent_type => 'resource', parent_id => $server } ) };
    my @sorting;
    foreach my $vm (@vms) {
      my ( $k, $v ) = each %{$vm};
      my $filepath = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = AzureGraph::get_header( 'resource', $server, $label_context );
  }
  elsif ( $item =~ m/^azure-region-(.*)-aggr$/ ) {
    $label_context = 'Region ' . $label_context . ' aggregated';
    my @regions = @{ $azure_metadata->get_items( { item_type => 'location' } ) };
    my @sorting;
    foreach my $region (@regions) {
      my ( $k, $v ) = each %{$region};
      my $filepath = $azure_metadata->get_filepath_rrd( { type => 'region', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    if ( $item =~ m/stopped/ ) {
      $header = "Stopped instances";
    }
    else {
      $header = "Running instances";
    }
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  if ( $item =~ m/^azure-(vm)-cpu-(percent|cores)-aggr$/ || $item =~ m/^azure-(vm)-cpu-(percent|cores)-aggr-res$/ ) {
    my $metric_type = 'percent';
    if ( $item =~ m/cpu-cores/ ) { $metric_type = 'cores'; }
    $cmd_params = AzureGraph::get_params_cpu($metric_type);

    my $domain_type = ( $item =~ m/^azure-(vm)/ )                           ? "vm"       : "location";
    my $group_type  = ( $item =~ m/^azure-(vm)-cpu-(percent|cores)-aggr$/ ) ? "location" : "resource";

    my $legend_helper0 = ( $group_type eq 'vm' )  ? "vm"   : "location";
    my $legend_helper1 = ( $domain_type eq 'vm' ) ? "vm  " : "location";
    $cmd_legend0 = " COMMENT:\"[%]\"";
    if ( $metric_type eq 'cores' ) { $cmd_legend0 = " COMMENT:\"[cores]\""; }
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}

      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $azure_metadata->get_label( $domain_type, $this_uuid );
      $grouplabel = $azure_metadata->get_label( $group_type,  $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = AzureGraph::graph_cpu_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }
  }
  elsif ( $item =~ m/running/ || $item =~ m/stopped/ ) {
    $cmd_params = AzureGraph::get_params_custom("Instances in [Count]");

    my $inst_item = "running";
    if ( $item =~ m/stopped/ ) {
      $inst_item = "stopped";
    }

    $cmd_legend0 = " COMMENT:\"[Count]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"C     Region                                         Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $host_interface (@uuids) {

      $filepath = $azure_metadata->get_filepath_rrd( { type => 'region', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $azure_metadata->get_label( 'region', $host_interface );
      $grouplabel = $azure_metadata->get_label( 'region', $host_interface );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph = AzureGraph::graph_instances_aggr( 'instance', $inst_item, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, 'region' );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    #error("$cmd_items");

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^azure-vm-data-aggr$/ || $item =~ m/^azure-vm-iops-aggr$/ || $item =~ m/^azure-vm-iops-aggr-res$/ || $item =~ m/^azure-vm-data-aggr-res$/ ) {
    my $metric_type = 'data';
    if ( $item =~ m/^azure-vm-iops-aggr$/ || $item =~ m/^azure-vm-iops-aggr-res$/ ) { $metric_type = 'iops'; }
    if ( $metric_type eq 'data' ) {
      $cmd_params = AzureGraph::get_params_storage();
    }
    else {
      $cmd_params = AzureGraph::get_params_storage($metric_type);
    }

    my $group_type = ( $item =~ m/-aggr$/ ) ? "location" : "resource";

    my $units = 'MiB/s';
    if ( $metric_type eq 'iops' ) { $units = 'iops'; }

    $cmd_legend0 = " COMMENT:\"[$units]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"Region                 EC2                       Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );

    my $itemcount = 0;
    foreach my $host_interface (@uuids) {

      my $filepath;
      $filepath = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist" . __FILE__ . ':' . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}

      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $azure_metadata->get_label( 'vm',       $host_interface );
      $grouplabel = $azure_metadata->get_label( 'location', $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph;
      $graph = AzureGraph::graph_storage_aggr( 'vm', $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^azure-vm-net-aggr$/ || $item =~ m/^azure-vm-net-aggr-res$/ ) {
    $cmd_params = AzureGraph::get_params_lan();

    $cmd_legend0 = " COMMENT:\"[MB/s]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"Host                 Interface             Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $group_type = ( $item =~ m/-aggr$/ ) ? "location" : "resource";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $host_interface (@uuids) {

      $filepath = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}

      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }
      $itemlabel  = $azure_metadata->get_label( 'vm',       $host_interface );
      $grouplabel = $azure_metadata->get_label( 'location', $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph;

      $graph = AzureGraph::graph_lan_aggr( 'vm', $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^azure-vm-mem-free-aggr$/ || $item =~ m/^azure-vm-mem-used-aggr$/ || $item =~ m/^azure-vm-mem-free-aggr-res$/ || $item =~ m/^azure-vm-mem-used-aggr-res$/ ) {
    $cmd_params = AzureGraph::get_params_memory();

    my $mem_item = "free";
    if ( $item =~ m/^azure-vm-mem-used-aggr$/ || $item =~ m/^azure-vm-mem-used-aggr-res$/ ) {
      $mem_item = "used";
    }

    my $group_type = ( $item =~ m/-aggr$/ ) ? "location" : "resource";

    $cmd_legend0 = " COMMENT:\"[GB]\\n\"";
    $cmd_legend0 .= " COMMENT:\\n";

    $cmd_legend0 .= " COMMENT:\"Host                 Interface             Read     Avrg       Max      Write    Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    my $config_vm_agent = $azure_metadata->get_conf_section('spec-vm');

    foreach my $host_interface (@uuids) {

      my $agent = $config_vm_agent->{$host_interface}{agent};

      if ( $agent eq "0" ) {
        next;
      }

      $filepath = $azure_metadata->get_filepath_rrd( { type => 'vm', uuid => $host_interface } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}

      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }
      $itemlabel  = $azure_metadata->get_label( 'vm',       $host_interface );
      $grouplabel = $azure_metadata->get_label( 'location', $server );

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];
      my $graph;
      $graph = AzureGraph::graph_memory_aggr( 'vm', $mem_item, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    if ( $itemcount eq "0" ) {
      error("no VM in this location contains Azure Agent!");
    }

    #error("test: $cmd_items");

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_Azure_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# Kubernetes
sub graph_kubernetes {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Kubernetes stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $kubernetes_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $kubernetes_metadata = KubernetesDataWrapperOOP->new( { acl_check => $kubernetes_acl } );
  my $skip_acl            = ($kubernetes_acl) ? 0 : 1;

  my $ban_exponent = 0;
  my $cmd_params   = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = KubernetesGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu/ ) {
    $cmd_params    = KubernetesGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = KubernetesGraph::get_params_memory();
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/pods/ ) {
    $cmd_params    = KubernetesGraph::get_params_custom('Number of Pods');
    $label_context = 'Pods';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = KubernetesGraph::get_params_cadvisor('Read - Bytes/sec - Write');
    $label_context = 'Data';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = KubernetesGraph::get_params_cadvisor('Read - IOPS - Write');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/latency/ ) {
    $cmd_params    = KubernetesGraph::get_params_cadvisor( 'Read - ms - Write', 0 );
    $label_context = 'Latency';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = KubernetesGraph::get_params_cadvisor('Read - Bytes/sec - Write');
    $label_context = 'Net';
  }

  my ( $graph_info, $rrd );
  if ( $item =~ m/^kubernetes-node/ ) {
    $label_context = 'Node ' . $label_context;
    if ( $item =~ m/^kubernetes-node-memory$/ ) {
      $graph_info = KubernetesGraph::graph_memory_node( $server, $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-node-cpu-percent$/ ) {
      $graph_info = KubernetesGraph::graph_cpu_node( $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-node-cpu$/ ) {
      $graph_info = KubernetesGraph::graph_cpu_node( $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-node-pods$/ ) {
      $graph_info = KubernetesGraph::graph_pods( $server, $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-node-data$/ ) {
      $graph_info   = KubernetesGraph::graph_cadvisor( 'node', 'data', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^kubernetes-node-iops$/ ) {
      $graph_info   = KubernetesGraph::graph_cadvisor( 'node', 'iops', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^kubernetes-node-latency$/ ) {
      $graph_info = KubernetesGraph::graph_cadvisor( 'node', 'latency', $server, $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-node-net$/ ) {
      $graph_info   = KubernetesGraph::graph_cadvisor( 'node', 'net', $server, $skip_acl );
      $ban_exponent = 1;
    }

    $rrd    = $kubernetes_metadata->get_filepath_rrd( { type => 'node', uuid => $server } );
    $header = KubernetesGraph::get_header( 'node', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-container/ ) {
    $label_context = 'Container ' . $label_context;
    if ( $item =~ m/^kubernetes-container-memory$/ ) {
      $graph_info = KubernetesGraph::graph_memory( 'container', $server, $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-container-cpu$/ ) {
      $graph_info = KubernetesGraph::graph_cpu( 'container', $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-container-data$/ ) {
      $graph_info   = KubernetesGraph::graph_cadvisor( 'container', 'data', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^kubernetes-container-iops$/ ) {
      $graph_info   = KubernetesGraph::graph_cadvisor( 'container', 'iops', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^kubernetes-container-latency$/ ) {
      $graph_info = KubernetesGraph::graph_cadvisor( 'container', 'latency', $server, $skip_acl );
    }

    $rrd    = $kubernetes_metadata->get_filepath_rrd( { type => 'container', uuid => $server } );
    $header = KubernetesGraph::get_header( 'container', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-pod/ ) {
    $label_context = 'Pod ' . $label_context;
    if ( $item =~ m/^kubernetes-pod-memory$/ ) {
      $graph_info = KubernetesGraph::graph_memory( 'pod', $server, $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-pod-cpu$/ ) {
      $graph_info = KubernetesGraph::graph_cpu( 'pod', $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-pod-net$/ ) {
      $graph_info = KubernetesGraph::graph_cadvisor( 'pod', 'net', $server, $skip_acl );
    }
    $rrd    = $kubernetes_metadata->get_filepath_rrd( { type => 'pod', uuid => $server } );
    $header = KubernetesGraph::get_header( 'pod', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-namespace/ ) {
    $label_context = 'Namespace ' . $label_context;
    if ( $item =~ m/^kubernetes-namespace-memory$/ ) {
      $graph_info = KubernetesGraph::graph_memory( 'namespace', $server, $skip_acl );
    }
    elsif ( $item =~ m/^kubernetes-namespace-cpu$/ ) {
      $graph_info = KubernetesGraph::graph_cpu( 'namespace', $server, 'cores', $skip_acl );
    }
    $rrd    = $kubernetes_metadata->get_filepath_rrd( { type => 'namespace', uuid => $server } );
    $header = KubernetesGraph::get_header( 'namespace', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( !defined $ban_exponent || $ban_exponent == 0 ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_kubernetes : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_kubernetes_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $exponent   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Kubernetes aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $kubernetes_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $kubernetes_metadata = KubernetesDataWrapperOOP->new( { acl_check => $kubernetes_acl } );
  my $skip_acl            = ($kubernetes_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu/ ) {
    $cmd_params    = KubernetesGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = KubernetesGraph::get_params_memory();
    $label_context = 'Memory aggregated';
  }

  my @uuids;
  if ( $item =~ m/^kubernetes-pod-container-(.*)-aggr$/ ) {
    $label_context = 'Containers of Pod ' . $label_context . ' aggregated ';
    my @containers = @{ $kubernetes_metadata->get_items( { item_type => 'container', parent_type => 'pod', parent_id => $server } ) };
    my @sorting;
    foreach my $container (@containers) {
      my ( $k, $v ) = each %{$container};
      my $filepath = $kubernetes_metadata->get_filepath_rrd( { type => 'container', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = KubernetesGraph::get_header( 'pod', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-pod-net-aggr$/ ) {
    $label_context = 'Network ' . $label_context . ' aggregated ';
    my @networks = @{ $kubernetes_metadata->get_items( { item_type => 'network', parent_type => 'pod', parent_id => $server } ) };
    my @sorting;
    foreach my $network (@networks) {
      my ( $k, $v ) = each %{$network};
      my $filepath = $kubernetes_metadata->get_filepath_rrd( { type => 'network', uuid => $k, parent => $server } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = KubernetesGraph::get_header( 'pod', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-pod-(.*)-aggr$/ ) {
    $label_context = 'Pod ' . $label_context . ' aggregated ';
    my @pods = @{ $kubernetes_metadata->get_items( { item_type => 'pod', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $pod (@pods) {
      my ( $k, $v ) = each %{$pod};
      my $filepath = $kubernetes_metadata->get_filepath_rrd( { type => 'pod', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = KubernetesGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-namespace-(.*)-aggr$/ ) {
    $label_context = 'Namespace ' . $label_context . ' aggregated ';
    my @namespaces = @{ $kubernetes_metadata->get_items( { item_type => 'namespace', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $namespace (@namespaces) {
      my ( $k, $v ) = each %{$namespace};
      my $filepath = $kubernetes_metadata->get_filepath_rrd( { type => 'namespace', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = KubernetesGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-node-(.*)-aggr$/ ) {
    $label_context = 'Node ' . $label_context . ' aggregated ';
    my @nodes = @{ $kubernetes_metadata->get_items( { item_type => 'node', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $node (@nodes) {
      my ( $k, $v ) = each %{$node};
      my $filepath = $kubernetes_metadata->get_filepath_rrd( { type => 'node', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = KubernetesGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^kubernetes-container-(.*)-aggr$/ ) {
    $label_context = 'Containers in Pods ' . $label_context . ' aggregated ';
    my @containers = @{ $kubernetes_metadata->get_items( { item_type => 'container', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $container (@containers) {
      my ( $k, $v ) = each %{$container};
      my $filepath = $kubernetes_metadata->get_filepath_rrd( { type => 'container', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = KubernetesGraph::get_header( 'cluster', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  my $labels = $kubernetes_metadata->get_labels();

  if ( $item =~ m/^kubernetes-(pod-container|pod|container|node|namespace)-(cpu|cpu-percent)-aggr$/ ) {
    my $metric_type = 'cpu';
    if ( $item =~ m/cpu-percent/ ) {
      $cmd_params = KubernetesGraph::get_params_cpu('percent');
    }
    else {
      $cmd_params = KubernetesGraph::get_params_cpu('cores');
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/pod-container/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }
    elsif ( $item =~ m/pod/ ) {
      $group_type  = "cluster";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/container/ ) {
      $group_type  = "cluster";
      $domain_type = "container";
    }
    elsif ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/namespace/ ) {
      $group_type  = "cluster";
      $domain_type = "namespace";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $kubernetes_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $kubernetes_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $kubernetes_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph;
      if ( $item =~ m/cpu-percent/ ) {
        $graph = KubernetesGraph::graph_cpu_percent_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      }
      else {
        $graph = KubernetesGraph::graph_cpu_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      }
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^kubernetes-(pod-container|pod|container|node|namespace)-memory-aggr$/ ) {
    $cmd_params = KubernetesGraph::get_params_memory();
    my $metric_type = "memory";

    my ( $group_type, $domain_type );
    if ( $item =~ m/pod-container/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }
    elsif ( $item =~ m/pod/ ) {
      $group_type  = "cluster";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/container/ ) {
      $group_type  = "cluster";
      $domain_type = "container";
    }
    elsif ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/namespace/ ) {
      $group_type  = "cluster";
      $domain_type = "namespace";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $kubernetes_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $kubernetes_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $kubernetes_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = KubernetesGraph::graph_memory_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^kubernetes-(node)-pods-aggr$/ ) {
    $cmd_params = KubernetesGraph::get_params_custom('Number of Pods');
    my $metric_type = "pods";

    my ( $group_type, $domain_type );

    $group_type  = "cluster";
    $domain_type = "node";

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $kubernetes_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $kubernetes_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $kubernetes_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = KubernetesGraph::graph_pods_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;

    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^kubernetes-(pod-container|node|container)-(data|iops|latency|net)-aggr$/ || $item =~ m/^kubernetes-pod-(net|network)-aggr$/ ) {
    my $metric_type = "data";

    my ( $group_type, $domain_type );
    if ( $item =~ m/kubernetes-pod-network/ ) {
      $group_type  = "cluster";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/kubernetes-pod-net/ ) {
      $group_type  = "pod";
      $domain_type = "interface";
    }
    elsif ( $item =~ m/pod-container/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }
    elsif ( $item =~ m/container/ ) {
      $group_type  = "cluster";
      $domain_type = "container";
    }
    elsif ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/pod/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }

    if ( $item =~ m/data/ ) {
      $metric_type = "data";
      $exponent    = 1;
      $cmd_params  = KubernetesGraph::get_params_cadvisor('Read - Data - Write');
    }
    elsif ( $item =~ m/iops/ ) {
      $metric_type = "iops";
      $exponent    = 1;
      $cmd_params  = KubernetesGraph::get_params_cadvisor('Read - IOPS - Write');
    }
    elsif ( $item =~ m/latency/ ) {
      $metric_type = "latency";
      $cmd_params  = KubernetesGraph::get_params_cadvisor('Read - ms - Write');
    }
    elsif ( $item =~ m/network/ ) {
      $metric_type = "network";
      $exponent    = 1;
      $cmd_params  = KubernetesGraph::get_params_cadvisor('Read - Net - Write');
    }
    elsif ( $item =~ m/net/ ) {
      $metric_type = "net";
      $exponent    = 1;
      $cmd_params  = KubernetesGraph::get_params_cadvisor('Read - Net - Write');
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $kubernetes_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  $kubernetes_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel $kubernetes_metadata->get_label( $group_type, $server );

      if ( $item =~ m/pod-net-aggr/ ) {
        $itemlabel  = $this_uuid;
        $grouplabel = $labels->{$group_type}->{$server};
      }
      else {
        $itemlabel  = $labels->{$domain_type}->{$this_uuid};
        $grouplabel = $labels->{$group_type}->{$server};
      }

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = KubernetesGraph::graph_cadvisor_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );
      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      #error(Dumper($graph));

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( $exponent eq "0" ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_kubernetes_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_openshift_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $exponent   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Openshift aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $openshift_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $openshift_metadata = OpenshiftDataWrapperOOP->new( { acl_check => $openshift_acl } );
  my $skip_acl           = ($openshift_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu/ ) {
    $cmd_params    = OpenshiftGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = OpenshiftGraph::get_params_memory();
    $label_context = 'Memory aggregated';
  }

  my @uuids;
  if ( $item =~ m/^openshift-pod-container-(.*)-aggr$/ ) {
    $label_context = 'Containers of Pod ' . $label_context . ' aggregated ';
    my @containers = @{ $openshift_metadata->get_items( { item_type => 'container', parent_type => 'pod', parent_id => $server } ) };
    my @sorting;
    foreach my $container (@containers) {
      my ( $k, $v ) = each %{$container};
      my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'container', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = OpenshiftGraph::get_header( 'pod', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-namespace-(.*)-aggr$/ ) {
    $label_context = 'Namespace ' . $label_context . ' aggregated ';
    my @namespaces = @{ $openshift_metadata->get_items( { item_type => 'namespace', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $namespace (@namespaces) {
      my ( $k, $v ) = each %{$namespace};
      my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'namespace', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = OpenshiftGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-pod-net-aggr$/ ) {
    $label_context = 'Network ' . $label_context . ' aggregated ';
    my @networks = @{ $openshift_metadata->get_items( { item_type => 'network', parent_type => 'pod', parent_id => $server } ) };
    my @sorting;
    foreach my $network (@networks) {
      my ( $k, $v ) = each %{$network};
      my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'network', parent => $server, uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = OpenshiftGraph::get_header( 'pod', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-project-pod-(.*)-aggr$/ ) {
    $label_context = 'Pod ' . $label_context . ' aggregated ';
    my @pods = @{ $openshift_metadata->get_items( { item_type => 'pod', parent_type => 'project', parent_id => $server } ) };
    my @sorting;
    foreach my $pod (@pods) {
      my ( $k, $v ) = each %{$pod};
      my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'pod', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = OpenshiftGraph::get_header( 'project', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-project-container-(.*)-aggr$/ ) {
    $label_context = 'Pod ' . $label_context . ' aggregated ';
    my @pods = @{ $openshift_metadata->get_items( { item_type => 'pod', parent_type => 'project', parent_id => $server } ) };
    foreach my $pod (@pods) {
      my ( $pod_uuid, $pod_label ) = each %{$pod};
      my @containers = @{ $openshift_metadata->get_items( { item_type => 'container', parent_type => 'pod', parent_id => $pod_uuid } ) };
      my @sorting;
      foreach my $container (@containers) {
        my ( $k, $v ) = each %{$container};
        my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'container', uuid => $k } );
        unless ( -f $filepath ) { next; }
        push @sorting, $k;
      }
      my @sorting_sorted = sort @sorting;
      push @uuids, @sorting_sorted;
    }

    $header = OpenshiftGraph::get_header( 'project', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-pod-(.*)-aggr$/ ) {
    $label_context = 'Pod ' . $label_context . ' aggregated ';
    my @pods = @{ $openshift_metadata->get_items( { item_type => 'pod', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $pod (@pods) {
      my ( $k, $v ) = each %{$pod};
      my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'pod', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = OpenshiftGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-node-(.*)-aggr$/ ) {
    $label_context = 'Node ' . $label_context . ' aggregated ';
    my @nodes = @{ $openshift_metadata->get_items( { item_type => 'node', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $node (@nodes) {
      my ( $k, $v ) = each %{$node};
      my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'node', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = OpenshiftGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-container-(.*)-aggr$/ ) {
    $label_context = 'Containers in Pods ' . $label_context . ' aggregated ';
    my @containers = @{ $openshift_metadata->get_items( { item_type => 'container', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $container (@containers) {
      my ( $k, $v ) = each %{$container};
      my $filepath = $openshift_metadata->get_filepath_rrd( { type => 'container', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = OpenshiftGraph::get_header( 'cluster', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  my $labels = $openshift_metadata->get_labels();

  if ( $item =~ m/^openshift-(pod-container|pod|container|node|project-pod|project-container|namespace)-(cpu|cpu-percent)-aggr$/ ) {
    my $metric_type = 'cpu';
    if ( $item =~ m/cpu-percent/ ) {
      $cmd_params = OpenshiftGraph::get_params_cpu('percent');
    }
    else {
      $cmd_params = OpenshiftGraph::get_params_cpu('cores');
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/pod-container/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }
    elsif ( $item =~ m/project-pod/ ) {
      $group_type  = "project";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/project-container/ ) {
      $group_type  = "project";
      $domain_type = "container";
    }
    elsif ( $item =~ m/pod/ ) {
      $group_type  = "cluster";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/container/ ) {
      $group_type  = "cluster";
      $domain_type = "container";
    }
    elsif ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/namespace/ ) {
      $group_type  = "cluster";
      $domain_type = "namespace";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $openshift_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $openshift_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $openshift_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph;
      if ( $item =~ m/cpu-percent/ ) {
        $graph = OpenshiftGraph::graph_cpu_percent_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      }
      else {
        $graph = OpenshiftGraph::graph_cpu_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      }
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^openshift-(pod-container|project-pod|project-container|pod|container|node|namespace)-memory-aggr$/ ) {
    $cmd_params = OpenshiftGraph::get_params_memory();
    my $metric_type = "memory";

    my ( $group_type, $domain_type );
    if ( $item =~ m/pod-container/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }
    elsif ( $item =~ m/project-pod/ ) {
      $group_type  = "project";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/project-container/ ) {
      $group_type  = "project";
      $domain_type = "container";
    }
    elsif ( $item =~ m/pod/ ) {
      $group_type  = "cluster";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/container/ ) {
      $group_type  = "cluster";
      $domain_type = "container";
    }
    elsif ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/namespace/ ) {
      $group_type  = "cluster";
      $domain_type = "namespace";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $openshift_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $openshift_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $openshift_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;

      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = OpenshiftGraph::graph_memory_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^openshift-(node)-pods-aggr$/ ) {
    $cmd_params = OpenshiftGraph::get_params_custom('Number of Pods');
    my $metric_type = "pods";

    my ( $group_type, $domain_type );

    $group_type  = "cluster";
    $domain_type = "node";

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $openshift_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $openshift_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $openshift_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = OpenshiftGraph::graph_pods_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;

    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^openshift-(pod-container|project-container|project-pod|node|pod|container)-(data|iops|latency|net)-aggr$/ || $item =~ m/^openshift-(pod|project-pod)-(net|network)-aggr$/ ) {
    my $metric_type = "data";

    my ( $group_type, $domain_type );
    if ( $item =~ m/openshift-pod-network/ ) {
      $group_type  = "cluster";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/openshift-pod-net/ ) {
      $group_type  = "pod";
      $domain_type = "interface";
    }
    elsif ( $item =~ m/pod-container/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }
    elsif ( $item =~ m/project-container/ ) {
      $group_type  = "project";
      $domain_type = "container";
    }
    elsif ( $item =~ m/project-pod/ ) {
      $group_type  = "project";
      $domain_type = "pod";
    }
    elsif ( $item =~ m/container/ ) {
      $group_type  = "cluster";
      $domain_type = "container";
    }
    elsif ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/pod/ ) {
      $group_type  = "pod";
      $domain_type = "container";
    }

    if ( $item =~ m/data/ ) {
      $metric_type = "data";
      $exponent    = 1;
      $cmd_params  = OpenshiftGraph::get_params_cadvisor('Read - Data - Write');
    }
    elsif ( $item =~ m/iops/ ) {
      $metric_type = "iops";
      $exponent    = 1;
      $cmd_params  = OpenshiftGraph::get_params_cadvisor('Read - IOPS - Write');
    }
    elsif ( $item =~ m/latency/ ) {
      $metric_type = "latency";
      $cmd_params  = OpenshiftGraph::get_params_cadvisor('Read - ms - Write');
    }
    elsif ( $item =~ m/network/ ) {
      $metric_type = "network";
      $exponent    = 1;
      $cmd_params  = OpenshiftGraph::get_params_cadvisor('Read - Net - Write');
    }
    elsif ( $item =~ m/net/ ) {
      $metric_type = "net";
      $exponent    = 1;
      $cmd_params  = OpenshiftGraph::get_params_cadvisor('Read - Net - Write');
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $openshift_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $openshift_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $openshift_metadata->get_label( $group_type, $server );

      if ( $item =~ m/net-aggr/ ) {
        $itemlabel  = ( defined $labels->{$domain_type}->{$this_uuid} ) ? $labels->{$domain_type}->{$this_uuid} : $this_uuid;
        $grouplabel = $openshift_metadata->get_label( $group_type, $server );
      }
      else {
        $itemlabel  = $labels->{$domain_type}->{$this_uuid};
        $grouplabel = $labels->{$group_type}->{$server};
      }

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = OpenshiftGraph::graph_cadvisor_aggr( $domain_type, $metric_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );
      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      #error(Dumper($graph));

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( $exponent eq "0" ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_openshift_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# Openshift
sub graph_openshift {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Openshift stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $openshift_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $openshift_metadata = OpenshiftDataWrapperOOP->new( { acl_check => $openshift_acl } );
  my $skip_acl           = ($openshift_acl) ? 0 : 1;

  my $ban_exponent = 0;
  my $cmd_params   = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = OpenshiftGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/cpu/ ) {
    $cmd_params    = OpenshiftGraph::get_params_cpu('cores');
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = OpenshiftGraph::get_params_memory();
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/pods/ ) {
    $cmd_params    = OpenshiftGraph::get_params_custom('Number of Pods');
    $label_context = 'Pods';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = OpenshiftGraph::get_params_cadvisor('Read - Bytes/sec - Write');
    $label_context = 'Data';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = OpenshiftGraph::get_params_cadvisor('Read - IOPS - Write');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/latency/ ) {
    $cmd_params    = OpenshiftGraph::get_params_cadvisor( 'Read - ms - Write', 0 );
    $label_context = 'Latency';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = OpenshiftGraph::get_params_cadvisor('Read - Bytes/sec - Write');
    $label_context = 'Net';
  }
  my ( $graph_info, $rrd );
  if ( $item =~ m/^openshift-node/ ) {
    $label_context = 'Node ' . $label_context;
    if ( $item =~ m/^openshift-node-memory$/ ) {
      $graph_info = OpenshiftGraph::graph_memory_node( $server, $skip_acl );
    }
    elsif ( $item =~ m/^openshift-node-cpu-percent$/ ) {
      $graph_info = OpenshiftGraph::graph_cpu_node( $server, 'percent', $skip_acl );
    }
    elsif ( $item =~ m/^openshift-node-cpu$/ ) {
      $graph_info = OpenshiftGraph::graph_cpu_node( $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^openshift-node-pods$/ ) {
      $graph_info = OpenshiftGraph::graph_pods( $server, $skip_acl );
    }
    elsif ( $item =~ m/^openshift-node-data$/ ) {
      $graph_info   = OpenshiftGraph::graph_cadvisor( 'node', 'data', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^openshift-node-iops$/ ) {
      $graph_info   = OpenshiftGraph::graph_cadvisor( 'node', 'iops', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^openshift-node-latency$/ ) {
      $graph_info = OpenshiftGraph::graph_cadvisor( 'node', 'latency', $server, $skip_acl );
    }
    elsif ( $item =~ m/^openshift-node-net$/ ) {
      $graph_info   = OpenshiftGraph::graph_cadvisor( 'node', 'net', $server, $skip_acl );
      $ban_exponent = 1;
    }

    $rrd    = $openshift_metadata->get_filepath_rrd( { type => 'node', uuid => $server } );
    $header = OpenshiftGraph::get_header( 'node', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-container/ ) {
    $label_context = 'Container ' . $label_context;
    if ( $item =~ m/^openshift-container-memory$/ ) {
      $graph_info = OpenshiftGraph::graph_memory( 'container', $server, $skip_acl );
    }
    elsif ( $item =~ m/^openshift-container-cpu$/ ) {
      $graph_info = OpenshiftGraph::graph_cpu( 'container', $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^openshift-container-data$/ ) {
      $graph_info   = OpenshiftGraph::graph_cadvisor( 'container', 'data', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^openshift-container-iops$/ ) {
      $graph_info   = OpenshiftGraph::graph_cadvisor( 'container', 'iops', $server, $skip_acl );
      $ban_exponent = 1;
    }
    elsif ( $item =~ m/^openshift-container-latency$/ ) {
      $graph_info = OpenshiftGraph::graph_cadvisor( 'container', 'latency', $server, $skip_acl );
    }

    $rrd    = $openshift_metadata->get_filepath_rrd( { type => 'container', uuid => $server } );
    $header = OpenshiftGraph::get_header( 'container', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-pod/ ) {
    $label_context = 'Pod ' . $label_context;
    if ( $item =~ m/^openshift-pod-memory$/ ) {
      $graph_info = OpenshiftGraph::graph_memory( 'pod', $server, $skip_acl );
    }
    elsif ( $item =~ m/^openshift-pod-cpu$/ ) {
      $graph_info = OpenshiftGraph::graph_cpu( 'pod', $server, 'cores', $skip_acl );
    }
    elsif ( $item =~ m/^openshift-pod-net$/ ) {
      $graph_info   = OpenshiftGraph::graph_cadvisor( 'pod', 'net', $server, $skip_acl );
      $ban_exponent = 1;
    }
    $rrd    = $openshift_metadata->get_filepath_rrd( { type => 'pod', uuid => $server } );
    $header = OpenshiftGraph::get_header( 'pod', $server, $label_context );
  }
  elsif ( $item =~ m/^openshift-namespace/ ) {
    $label_context = 'Namespace ' . $label_context;
    if ( $item =~ m/^openshift-namespace-memory$/ ) {
      $graph_info = OpenshiftGraph::graph_memory( 'namespace', $server, $skip_acl );
    }
    elsif ( $item =~ m/^openshift-namespace-cpu$/ ) {
      $graph_info = OpenshiftGraph::graph_cpu( 'namespace', $server, 'cores', $skip_acl );
    }
    $rrd    = $openshift_metadata->get_filepath_rrd( { type => 'namespace', uuid => $server } );
    $header = OpenshiftGraph::get_header( 'namespace', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( !defined $ban_exponent || $ban_exponent == 0 ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_openshift : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

# Cloudstack
sub graph_cloudstack {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Cloudstack stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $cloudstack_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $cloudstack_metadata = CloudstackDataWrapperOOP->new( { acl_check => $cloudstack_acl } );
  my $skip_acl            = ($cloudstack_acl) ? 0 : 1;

  my $ban_exponent = 0;
  my $cmd_params   = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = CloudstackGraph::get_params_cpu('percent');
    $label_context = 'CPU %';
  }
  elsif ( $item =~ m/size/ || $item =~ m/allocated/ ) {
    $cmd_params = CloudstackGraph::get_params_custom('Capacity in [GiB]');
  }
  elsif ( $item =~ m/cpu-cores/ ) {
    $cmd_params = CloudstackGraph::get_params_custom('CPU load in [cores]');
  }
  elsif ( $item =~ m/cpu/ ) {
    if ( $item =~ m/instance/ ) {
      $cmd_params = CloudstackGraph::get_params_custom('CPU load in [MHz]');
    }
    else {
      $cmd_params = CloudstackGraph::get_params_custom('CPU load in [GHz]');
    }
    $label_context = 'CPU cores';
  }
  elsif ( $item =~ m/mem/ ) {
    if ( $item =~ m/instance/ ) {
      $cmd_params = CloudstackGraph::get_params_memory('instance');
    }
    else {
      $cmd_params = CloudstackGraph::get_params_memory();
    }
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = CloudstackGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Data';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = CloudstackGraph::get_params_custom('Read - IOPS - Write');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/latency/ ) {
    $cmd_params    = CloudstackGraph::get_params_custom( 'Read - ms - Write', 0 );
    $label_context = 'Latency';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = CloudstackGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Net';
  }
  my ( $graph_info, $rrd );
  if ( $item =~ m/^cloudstack-host/ ) {
    $label_context = 'Host ' . $label_context;
    if ( $item =~ m/^cloudstack-host-cpu$/ ) {
      $graph_info = CloudstackGraph::graph_cpu_host( $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-host-memory$/ ) {
      $graph_info = CloudstackGraph::graph_memory( 'host', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-host-net$/ ) {
      $graph_info = CloudstackGraph::graph_net( 'host', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-host-cpu-cores$/ ) {
      $graph_info = CloudstackGraph::graph_cpu_cores_host( $server, $skip_acl );
    }

    $rrd    = $cloudstack_metadata->get_filepath_rrd( { type => 'host', uuid => $server } );
    $header = CloudstackGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^cloudstack-instance/ ) {
    $label_context = 'Instance ' . $label_context;
    if ( $item =~ m/^cloudstack-instance-memory$/ ) {
      $graph_info = CloudstackGraph::graph_memory( 'instance', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-instance-cpu$/ ) {
      $graph_info = CloudstackGraph::graph_cpu_instance( $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-instance-iops$/ ) {
      $graph_info = CloudstackGraph::graph_iops( 'instance', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-instance-data$/ ) {
      $graph_info = CloudstackGraph::graph_data( 'instance', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-instance-net$/ ) {
      $graph_info = CloudstackGraph::graph_net( 'instance', $server, $skip_acl );
    }

    $rrd    = $cloudstack_metadata->get_filepath_rrd( { type => 'instance', uuid => $server } );
    $header = CloudstackGraph::get_header( 'instance', $server, $label_context );
  }
  elsif ( $item =~ m/^cloudstack-volume/ ) {
    $label_context = 'Volume ' . $label_context;
    if ( $item =~ m/^cloudstack-volume-data$/ ) {
      $graph_info = CloudstackGraph::graph_data( 'volume', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-volume-iops$/ ) {
      $graph_info = CloudstackGraph::graph_iops( 'volume', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-volume-size$/ ) {
      $graph_info = CloudstackGraph::graph_size( 'volume', $server, $skip_acl );
    }

    $rrd    = $cloudstack_metadata->get_filepath_rrd( { type => 'volume', uuid => $server } );
    $header = CloudstackGraph::get_header( 'volume', $server, $label_context );
  }
  elsif ( $item =~ m/^cloudstack-primaryStorage/ ) {
    $label_context = 'Primary Storage ' . $label_context;
    if ( $item =~ m/^cloudstack-primaryStorage-size$/ ) {
      $graph_info = CloudstackGraph::graph_size( 'primaryStorage', $server, $skip_acl );
    }
    elsif ( $item =~ m/^cloudstack-primaryStorage-allocated$/ ) {
      $graph_info = CloudstackGraph::graph_size_allocated( $server, $skip_acl );
    }

    $rrd    = $cloudstack_metadata->get_filepath_rrd( { type => 'primaryStorage', uuid => $server } );
    $header = CloudstackGraph::get_header( 'primaryStorage', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( !defined $ban_exponent || $ban_exponent == 0 ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;

  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_cloudstack : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_cloudstack_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $exponent   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Cloudstack aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $cloudstack_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $cloudstack_metadata = CloudstackDataWrapperOOP->new( { acl_check => $cloudstack_acl } );
  my $skip_acl            = ($cloudstack_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu-cores/ ) {
    $cmd_params = CloudstackGraph::get_params_custom('CPU load in [cores]');
  }
  elsif ( $item =~ m/cpu/ ) {
    if ( $item =~ m/instance/ ) {
      $cmd_params = CloudstackGraph::get_params_custom('CPU load in [MHz]');
    }
    else {
      $cmd_params = CloudstackGraph::get_params_custom('CPU load in [GHz]');
    }
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params = CloudstackGraph::get_params_custom('Memory in [GB]');
  }

  my @uuids;
  if ( $item =~ m/^cloudstack-host-(.*)-aggr$/ ) {
    $label_context = 'Host ' . $label_context . ' aggregated ';
    my @hosts = @{ $cloudstack_metadata->get_items( { item_type => 'host', parent_type => 'cloud', parent_id => $server } ) };
    my @sorting;
    foreach my $host (@hosts) {
      my ( $k, $v ) = each %{$host};
      my $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'host', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = CloudstackGraph::get_header( 'cloud', $server, $label_context );
  }
  elsif ( $item =~ m/^cloudstack-instance-(.*)-aggr$/ ) {
    $label_context = 'Instance ' . $label_context . ' aggregated ';
    my @instances = @{ $cloudstack_metadata->get_items( { item_type => 'instance', parent_type => 'cloud', parent_id => $server } ) };
    my @sorting;
    foreach my $instance (@instances) {
      my ( $k, $v ) = each %{$instance};
      my $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'instance', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = CloudstackGraph::get_header( 'cloud', $server, $label_context );
  }
  elsif ( $item =~ m/^cloudstack-volume-(.*)-aggr$/ ) {
    $label_context = 'Volume ' . $label_context . ' aggregated ';
    my @volumes = @{ $cloudstack_metadata->get_items( { item_type => 'volume', parent_type => 'cloud', parent_id => $server } ) };
    my @sorting;
    foreach my $volume (@volumes) {
      my ( $k, $v ) = each %{$volume};
      my $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'volume', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = CloudstackGraph::get_header( 'cloud', $server, $label_context );
  }
  elsif ( $item =~ m/^cloudstack-primaryStorage-(.*)-aggr$/ ) {
    $label_context = 'Primary Storage ' . $label_context . ' aggregated ';
    my @storages = @{ $cloudstack_metadata->get_items( { item_type => 'primaryStorage', parent_type => 'cloud', parent_id => $server } ) };
    my @sorting;
    foreach my $storage (@storages) {
      my ( $k, $v ) = each %{$storage};
      my $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'primaryStorage', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = CloudstackGraph::get_header( 'cloud', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  my $labels = $cloudstack_metadata->get_labels();

  if ( $item =~ m/^cloudstack-(host|instance)-(cpu|cpu-cores)-aggr$/ ) {
    if ( $item =~ m/cpu-cores/ ) {
      $cmd_params = CloudstackGraph::get_params_custom('CPU load in [cores]');
    }
    else {
      $cmd_params = CloudstackGraph::get_params_custom('CPU load in [GHz]');
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cloud";
      $domain_type = "host";
    }
    else {
      $group_type  = "cloud";
      $domain_type = "instance";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[GHz]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/host/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'host', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/instance/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'instance', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $cloudstack_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $cloudstack_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph;
      if ( $item =~ m/cpu-cores/ ) {
        $graph = CloudstackGraph::graph_cpu_cores_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      }
      else {
        $graph = CloudstackGraph::graph_cpu_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );
      }

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^cloudstack-(host|instance)-memory-(used|free)-aggr$/ ) {

    if ( $item =~ m/free/ ) {
      $cmd_params = CloudstackGraph::get_params_memory();
    }
    else {
      $cmd_params = CloudstackGraph::get_params_memory();
    }

    my ( $group_type, $domain_type, $mem_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cloud";
      $domain_type = "host";
    }
    else {
      $group_type  = "cloud";
      $domain_type = "instance";
    }

    if ( $item =~ m/free/ ) {
      $mem_type = "free";
    }
    else {
      $mem_type = "used";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[GiB]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/host/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'host', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/instance/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'instance', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $cloudstack_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $cloudstack_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = CloudstackGraph::graph_memory_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $mem_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^cloudstack-(host|instance)-net-aggr$/ ) {

    $cmd_params = CloudstackGraph::get_params_lan();

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cloud";
      $domain_type = "host";
    }
    else {
      $group_type  = "cloud";
      $domain_type = "instance";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[MiB/s]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/host/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'host', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/instance/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'instance', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $cloudstack_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $cloudstack_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = CloudstackGraph::graph_net_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend       .= $graph->{cmd_legend};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^cloudstack-(host|instance|volume)-data-aggr$/ ) {

    $cmd_params = CloudstackGraph::get_params_storage();

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cloud";
      $domain_type = "host";
    }
    elsif ( $item =~ m/volume/ ) {
      $group_type  = "cloud";
      $domain_type = "volume";
    }
    else {
      $group_type  = "cloud";
      $domain_type = "instance";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[MiB/s]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/host/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'host', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/instance/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'instance', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/volume/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'volume', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $cloudstack_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $cloudstack_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = CloudstackGraph::graph_data_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );

      $cmd_items .= $graph->{cmd_def};
      $cmd_items .= $graph->{cmd_cdef};

      #$cmd_legend .= $graph->{cmd_legend};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^cloudstack-(host|instance|volume)-iops-aggr$/ ) {

    $cmd_params = CloudstackGraph::get_params_storage('iops');

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cloud";
      $domain_type = "host";
    }
    elsif ( $item =~ m/volume/ ) {
      $group_type  = "cloud";
      $domain_type = "volume";
    }
    else {
      $group_type  = "cloud";
      $domain_type = "instance";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[IOPS]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/host/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'host', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/instance/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'instance', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/volume/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'volume', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $cloudstack_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $cloudstack_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = CloudstackGraph::graph_iops_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );

      $cmd_items .= $graph->{cmd_def};
      $cmd_items .= $graph->{cmd_cdef};

      #$cmd_legend .= $graph->{cmd_legend};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^cloudstack-(volume|primaryStorage)-size-(used|free|allocated|unallocated)-aggr$/ ) {

    my ( $group_type, $domain_type, $mem_type );
    if ( $item =~ m/volume/ ) {
      $group_type  = "cloud";
      $domain_type = "volume";
    }
    elsif ( $item =~ m/primaryStorage/ ) {
      $group_type  = "cloud";
      $domain_type = "primaryStorage";
    }

    if ( $item =~ m/free/ ) {
      $mem_type   = "free";
      $cmd_params = CloudstackGraph::get_params_custom('Free capacity in GiB');
    }
    elsif ( $item =~ m/used/ ) {
      $mem_type   = "used";
      $cmd_params = CloudstackGraph::get_params_custom('Used capacity in GiB');
    }
    elsif ( $item =~ m/unallocated/ ) {
      $mem_type   = "unallocated";
      $cmd_params = CloudstackGraph::get_params_custom('Unallocated capacity in GiB');
    }
    elsif ( $item =~ m/allocated/ ) {
      $mem_type   = "allocated";
      $cmd_params = CloudstackGraph::get_params_custom('Allocated capacity in GiB');
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[GiB]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      if ( $item =~ m/volume/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'volume', uuid => $this_uuid } );
      }
      elsif ( $item =~ m/primaryStorage/ ) {
        $filepath = $cloudstack_metadata->get_filepath_rrd( { type => 'primaryStorage', uuid => $this_uuid } );
      }

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      #$itemlabel  = $cloudstack_metadata->get_label( $domain_type, $this_uuid );
      #$grouplabel = $cloudstack_metadata->get_label( $group_type, $server );

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = CloudstackGraph::graph_size_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $mem_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( $exponent eq "0" ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_cloudstack_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# Proxmox
sub graph_proxmox {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Proxmox stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $proxmox_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $proxmox_metadata = ProxmoxDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, acl_check => $proxmox_acl } );
  my $skip_acl         = ($proxmox_acl) ? 0 : 1;

  my $ban_exponent = 0;
  my $cmd_params   = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('CPU load in [%]');
    $label_context = 'CPU%';
  }
  elsif ( $item =~ m/cpu/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('CPU load in [cores]');
    $label_context = 'CPU';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = ProxmoxGraph::get_params_memory();
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/size/ || $item =~ m/disk/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('Capacity in [GiB]');
    $label_context = 'Capacity';
  }
  elsif ( $item =~ m/swap/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('Swap in [GiB]');
    $label_context = 'Swap';
  }
  elsif ( $item =~ m/io/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('IO delay in [%]');
    $label_context = 'IO delay';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Data';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('Read - IOPS - Write');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/latency/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom( 'Read - ms - Write', 0 );
    $label_context = 'Latency';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = ProxmoxGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Net';
  }
  my ( $graph_info, $rrd );
  if ( $item =~ m/^proxmox-node/ ) {
    $label_context = 'Node ' . $label_context;
    if ( $item =~ m/^proxmox-node-cpu$/ ) {
      $graph_info = ProxmoxGraph::graph_cpu( $server, 'node', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-node-cpu-percent$/ ) {
      $graph_info = ProxmoxGraph::graph_cpu_percent( $server, 'node', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-node-memory$/ ) {
      $graph_info = ProxmoxGraph::graph_memory( $server, 'node', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-node-net$/ ) {
      $graph_info = ProxmoxGraph::graph_net( $server, 'node', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-node-swap$/ ) {
      $graph_info = ProxmoxGraph::graph_swap( $server, 'node', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-node-io$/ ) {
      $graph_info = ProxmoxGraph::graph_iowait( $server, 'node', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-node-disk$/ ) {
      $graph_info = ProxmoxGraph::graph_size( $server, 'node', $skip_acl );
    }

    $rrd    = $proxmox_metadata->get_filepath_rrd( { type => 'node', uuid => $server } );
    $header = ProxmoxGraph::get_header( 'node', $server, $label_context );
  }
  elsif ( $item =~ m/^proxmox-vm/ ) {
    $label_context = 'VM ' . $label_context;
    if ( $item =~ m/^proxmox-vm-cpu$/ ) {
      $graph_info = ProxmoxGraph::graph_cpu( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-vm-cpu-percent$/ ) {
      $graph_info = ProxmoxGraph::graph_cpu_percent( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-vm-memory$/ ) {
      $graph_info = ProxmoxGraph::graph_memory( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-vm-net$/ ) {
      $graph_info = ProxmoxGraph::graph_net( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-vm-data$/ ) {
      $graph_info = ProxmoxGraph::graph_data( $server, 'vm', $skip_acl );
    }

    $rrd    = $proxmox_metadata->get_filepath_rrd( { type => 'vm', uuid => $server } );
    $header = ProxmoxGraph::get_header( 'vm', $server, $label_context );
  }
  elsif ( $item =~ m/^proxmox-lxc/ ) {
    $label_context = 'LXC ' . $label_context;
    if ( $item =~ m/^proxmox-lxc-cpu$/ ) {
      $graph_info = ProxmoxGraph::graph_cpu( $server, 'lxc', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-lxc-cpu-percent$/ ) {
      $graph_info = ProxmoxGraph::graph_cpu_percent( $server, 'lxc', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-lxc-memory$/ ) {
      $graph_info = ProxmoxGraph::graph_memory( $server, 'lxc', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-lxc-net$/ ) {
      $graph_info = ProxmoxGraph::graph_net( $server, 'lxc', $skip_acl );
    }
    elsif ( $item =~ m/^proxmox-lxc-data$/ ) {
      $graph_info = ProxmoxGraph::graph_data( $server, 'lxc', $skip_acl );
    }

    $rrd    = $proxmox_metadata->get_filepath_rrd( { type => 'lxc', uuid => $server } );
    $header = ProxmoxGraph::get_header( 'lxc', $server, $label_context );
  }
  elsif ( $item =~ m/^proxmox-storage/ ) {
    $label_context = 'Storage ' . $label_context;
    if ( $item =~ m/^proxmox-storage-size$/ ) {
      $graph_info = ProxmoxGraph::graph_size( $server, 'storage', $skip_acl );
    }

    $rrd    = $proxmox_metadata->get_filepath_rrd( { type => 'storage', uuid => $server } );
    $header = ProxmoxGraph::get_header( 'storage', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( !defined $ban_exponent || $ban_exponent == 0 ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_proxmox : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

# Docker
sub graph_docker {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Docker stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $docker_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $docker_metadata = DockerDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, acl_check => $docker_acl } );
  my $skip_acl        = ($docker_acl) ? 0 : 1;

  my $ban_exponent = 0;
  my $cmd_params   = my $label_context = my $header = '';
  if ( $item =~ m/cpu-cores/ ) {
    $cmd_params    = DockerGraph::get_params_cpu('cores');
    $label_context = 'Cores';
  }
  elsif ( $item =~ m/cpu/ ) {
    $cmd_params    = DockerGraph::get_params_cpu('percent');
    $label_context = 'CPU%';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = DockerGraph::get_params_custom( 'Memory in [GiB]', '0.01' );
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/size/ ) {
    $cmd_params    = DockerGraph::get_params_custom( 'Capacity in [GiB]', '0.01' );
    $label_context = 'Capacity';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = DockerGraph::get_params_custom( 'Read - MB/sec - Write', '0.01' );
    $label_context = 'Data';
  }
  elsif ( $item =~ m/iops/ ) {
    $cmd_params    = DockerGraph::get_params_custom( 'Read - IOPS - Write', '1' );
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = DockerGraph::get_params_custom( 'Read - MB/sec - Write', '0.01' );
    $label_context = 'Net';
  }

  my ( $graph_info, $rrd );
  if ( $item =~ m/^docker-container/ ) {
    $label_context = 'Container ' . $label_context;
    if ( $item =~ m/^docker-container-cpu$/ ) {
      $graph_info = DockerGraph::graph_cpu( $server, $skip_acl );
    }
    if ( $item =~ m/^docker-container-cpu-real$/ ) {
      $graph_info = DockerGraph::graph_cpu_real( $server, $skip_acl );
    }
    elsif ( $item =~ m/^docker-container-cpu-cores$/ ) {
      $graph_info = DockerGraph::graph_cpu_cores( $server, $skip_acl );
    }
    elsif ( $item =~ m/^docker-container-memory$/ ) {
      $graph_info = DockerGraph::graph_memory( $server, $skip_acl );
    }
    elsif ( $item =~ m/^docker-container-data$/ ) {
      $graph_info = DockerGraph::graph_data( $server, $skip_acl );
    }
    elsif ( $item =~ m/^docker-container-net$/ ) {
      $graph_info = DockerGraph::graph_net( $server, $skip_acl );
    }
    elsif ( $item =~ m/^docker-container-io$/ ) {
      $graph_info = DockerGraph::graph_io( $server, $skip_acl );
    }
    elsif ( $item =~ m/^docker-container-size$/ ) {
      $graph_info = DockerGraph::graph_size( $server, 'container', $skip_acl );
    }
    elsif ( $item =~ m/^docker-container-size-rw$/ ) {
      $graph_info = DockerGraph::graph_size_rw( $server, $skip_acl );
    }

    $rrd    = $docker_metadata->get_filepath_rrd( { type => 'container', uuid => $server } );
    $header = DockerGraph::get_header( 'container', $server, $label_context );
  }
  elsif ( $item =~ m/^docker-volume/ ) {
    $label_context = 'Volume ' . $label_context;
    if ( $item =~ m/^docker-volume-size$/ ) {
      $graph_info = DockerGraph::graph_size( $server, 'volume', $skip_acl );
    }

    $rrd    = $docker_metadata->get_filepath_rrd( { type => 'volume', uuid => $server } );
    $header = DockerGraph::get_header( 'volume', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( !defined $ban_exponent || $ban_exponent == 0 ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_docker : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_docker_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $exponent   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Docker aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $docker_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $docker_metadata = DockerDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, acl_check => $docker_acl } );
  my $skip_acl        = ($docker_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu/ ) {
    $cmd_params = DockerGraph::get_params_cpu('percent');
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params = DockerGraph::get_params_custom('Memory in [GB]');
  }

  my @uuids;
  if ( $item =~ m/^docker-(total-container|container)-(.*)-aggr$/ ) {
    $label_context = 'Container ' . $label_context . ' aggregated ';
    my @containers = ( $item =~ m/total/ ) ? @{ $docker_metadata->get_items( { item_type => 'container' } ) } : @{ $docker_metadata->get_items( { item_type => 'container', parent_type => 'host', parent_id => $server } ) };
    my @sorting;
    foreach my $container (@containers) {
      my ( $k, $v ) = each %{$container};
      my $filepath = $docker_metadata->get_filepath_rrd( { type => 'container', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = DockerGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^docker-(total-volume|volume)-(.*)-aggr$/ ) {
    $label_context = 'Volume ' . $label_context . ' aggregated ';
    my @volumes = ( $item =~ m/total/ ) ? @{ $docker_metadata->get_items( { item_type => 'volume' } ) } : @{ $docker_metadata->get_items( { item_type => 'volume', parent_type => 'host', parent_id => $server } ) };
    my @sorting;
    foreach my $volume (@volumes) {
      my ( $k, $v ) = each %{$volume};
      my $filepath = $docker_metadata->get_filepath_rrd( { type => 'volume', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = DockerGraph::get_header( 'host', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  my $labels = $docker_metadata->get_labels();
  my $arch   = $docker_metadata->get_conf_section('arch');

  if ( $item =~ m/^docker-(total-container|container)-cpu-aggr$/ ) {

    $cmd_params = DockerGraph::get_params_cpu('cores');
    my $total = ( $item =~ m/total/ ) ? 1 : 0;

    my $group_type  = "host";
    my $domain_type = "container";

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $docker_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel = $labels->{$domain_type}->{$this_uuid};

      $server = 'nope';
      foreach my $host ( keys %{ $arch->{ 'host_' . $domain_type } } ) {
        for ( @{ $arch->{ 'host_' . $domain_type }->{$host} } ) {
          my $cont = $_;
          if ( $cont eq $this_uuid ) {
            $server = $host;
            last;
          }
        }
        if ( $server ne "nope" ) {
          last;
        }
      }
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = DockerGraph::graph_cpu_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $total );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^docker-(total-container|container|total-volume|volume)-(size|size-rw)-aggr$/ ) {

    $cmd_params = DockerGraph::get_params_custom( 'Size in [GiB]', '0.01' );
    my $total = ( $item =~ m/total/ ) ? 1 : 0;

    my $group_type  = "host";
    my $domain_type = ( $item =~ m/container/ ) ? "container" : "volume";

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $docker_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel = $labels->{$domain_type}->{$this_uuid};

      $server = 'nope';
      foreach my $host ( keys %{ $arch->{ 'host_' . $domain_type } } ) {
        for ( @{ $arch->{ 'host_' . $domain_type }->{$host} } ) {
          my $cont = $_;
          if ( $cont eq $this_uuid ) {
            $server = $host;
            last;
          }
        }
        if ( $server ne "nope" ) {
          last;
        }
      }
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $metric = ( $item =~ m/size-rw/ ) ? "size_rw" : "size";
      if ( $domain_type eq "container" && $metric eq "size" ) {
        $metric = "size_root_fs";
      }
      my $graph = DockerGraph::graph_size_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $metric, $total );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^docker-(total-container|container)-memory-aggr$/ ) {

    $cmd_params = DockerGraph::get_params_memory();
    my $total = ( $item =~ m/total/ ) ? 1 : 0;

    my $group_type  = "host";
    my $domain_type = "container";

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $docker_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel = $labels->{$domain_type}->{$this_uuid};

      $server = 'nope';
      foreach my $host ( keys %{ $arch->{ 'host_' . $domain_type } } ) {
        for ( @{ $arch->{ 'host_' . $domain_type }->{$host} } ) {
          my $cont = $_;
          if ( $cont eq $this_uuid ) {
            $server = $host;
            last;
          }
        }
        if ( $server ne "nope" ) {
          last;
        }
      }
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = DockerGraph::graph_memory_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $total );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^docker-(total-container|container)-(data|net|io)-aggr$/ ) {
    my $metric;
    $cmd_params = ( $item =~ m/io/ ) ? DockerGraph::get_params_custom( 'Read - IOPS - Write', '1' ) : DockerGraph::get_params_custom( 'Read - MB/sec - Write', '0.01' );
    my $total = ( $item =~ m/total/ ) ? 1 : 0;
    if ( $item =~ m/data/ ) {
      $metric = "data";
    }
    elsif ( $item =~ m/net/ ) {
      $metric = "net";
    }
    else {
      $metric = "io";
    }

    my ( $group_type, $domain_type );
    $group_type  = "host";
    $domain_type = "container";

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = ( $item =~ m/io/ ) ? " COMMENT:\"[IOPS]\"" : " COMMENT:\"[MB/sec]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $docker_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel = $labels->{$domain_type}->{$this_uuid};

      $server = 'nope';
      foreach my $host ( keys %{ $arch->{ 'host_' . $domain_type } } ) {
        for ( @{ $arch->{ 'host_' . $domain_type }->{$host} } ) {
          my $cont = $_;
          if ( $cont eq $this_uuid ) {
            $server = $host;
            last;
          }
        }
        if ( $server ne "nope" ) {
          last;
        }
      }
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = DockerGraph::graph_read_write_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( $exponent eq "0" ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_docker_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_proxmox_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $exponent   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Proxmox aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $proxmox_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $proxmox_metadata = ProxmoxDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, acl_check => $proxmox_acl } );
  my $skip_acl         = ($proxmox_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu/ ) {
    $cmd_params = ProxmoxGraph::get_params_custom('CPU load in [cores]');
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params = ProxmoxGraph::get_params_custom('Memory in [GB]');
  }

  my @uuids;
  if ( $item =~ m/^proxmox-node-(.*)-aggr$/ ) {
    $label_context = 'Node ' . $label_context . ' aggregated ';
    my @nodes = @{ $proxmox_metadata->get_items( { item_type => 'node', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $node (@nodes) {
      my ( $k, $v ) = each %{$node};
      my $filepath = $proxmox_metadata->get_filepath_rrd( { type => 'node', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = ProxmoxGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^proxmox-vm-(.*)-aggr$/ ) {
    $label_context = 'VM ' . $label_context . ' aggregated ';
    my @vms = @{ $proxmox_metadata->get_items( { item_type => 'vm', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $vm (@vms) {
      my ( $k, $v ) = each %{$vm};
      my $filepath = $proxmox_metadata->get_filepath_rrd( { type => 'vm', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = ProxmoxGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^proxmox-lxc-(.*)-aggr$/ ) {
    $label_context = 'LXC ' . $label_context . ' aggregated ';
    my @lxcs = @{ $proxmox_metadata->get_items( { item_type => 'lxc', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $lxc (@lxcs) {
      my ( $k, $v ) = each %{$lxc};
      my $filepath = $proxmox_metadata->get_filepath_rrd( { type => 'lxc', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = ProxmoxGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^proxmox-storage-(.*)-aggr$/ ) {
    $label_context = 'Storage ' . $label_context . ' aggregated ';
    my @storages = @{ $proxmox_metadata->get_items( { item_type => 'storage', parent_type => 'cluster', parent_id => $server } ) };
    my @sorting;
    foreach my $storage (@storages) {
      my ( $k, $v ) = each %{$storage};
      my $filepath = $proxmox_metadata->get_filepath_rrd( { type => 'storage', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = ProxmoxGraph::get_header( 'cluster', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  my $labels = $proxmox_metadata->get_labels();

  if ( $item =~ m/^proxmox-(node|vm|lxc)-(cpu)-aggr$/ ) {

    $cmd_params = ProxmoxGraph::get_params_cpu('cores');

    my ( $group_type, $domain_type );
    if ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/lxc/ ) {
      $group_type  = "cluster";
      $domain_type = "lxc";
    }
    else {
      $group_type  = "cluster";
      $domain_type = "vm";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[cores]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = ProxmoxGraph::graph_cpu_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^proxmox-(node|vm|lxc)-(cpu-percent)-aggr$/ ) {

    $cmd_params = ProxmoxGraph::get_params_cpu();

    my ( $group_type, $domain_type );
    if ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/lxc/ ) {
      $group_type  = "cluster";
      $domain_type = "lxc";
    }
    else {
      $group_type  = "cluster";
      $domain_type = "vm";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[%]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = ProxmoxGraph::graph_cpu_percent_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^proxmox-(node|vm|lxc)-memory-(used|free)-aggr$/ ) {

    $cmd_params = ProxmoxGraph::get_params_memory();

    my ( $group_type, $domain_type, $mem_type );
    if ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/lxc/ ) {
      $group_type  = "cluster";
      $domain_type = "lxc";
    }
    else {
      $group_type  = "cluster";
      $domain_type = "vm";
    }

    if ( $item =~ m/free/ ) {
      $mem_type = "free";
    }
    else {
      $mem_type = "used";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[GiB]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = ProxmoxGraph::graph_memory_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $mem_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^proxmox-(node|vm|lxc)-net-aggr$/ ) {

    $cmd_params = ProxmoxGraph::get_params_lan();

    my ( $group_type, $domain_type );
    if ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/lxc/ ) {
      $group_type  = "cluster";
      $domain_type = "lxc";
    }
    else {
      $group_type  = "cluster";
      $domain_type = "vm";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[MiB/s]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = ProxmoxGraph::graph_net_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend       .= defined $graph->{cmd_legend} ? $graph->{cmd_legend} : '';
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^proxmox-(vm|lxc)-data-aggr$/ ) {

    $cmd_params = ProxmoxGraph::get_params_storage();

    my ( $group_type, $domain_type );
    if ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/lxc/ ) {
      $group_type  = "cluster";
      $domain_type = "lxc";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[MiB/s]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = ProxmoxGraph::graph_data_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type );

      $cmd_items .= $graph->{cmd_def};
      $cmd_items .= $graph->{cmd_cdef};

      #$cmd_legend .= $graph->{cmd_legend};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^proxmox-(node|storage)-(size|disk)-(used|free)-aggr$/ ) {

    my ( $group_type, $domain_type, $mem_type );
    if ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }
    elsif ( $item =~ m/storage/ ) {
      $group_type  = "cluster";
      $domain_type = "storage";
    }

    if ( $item =~ m/free/ ) {
      $mem_type   = "free";
      $cmd_params = ProxmoxGraph::get_params_custom('Free capacity in GiB');
    }
    elsif ( $item =~ m/used/ ) {
      $mem_type   = "used";
      $cmd_params = ProxmoxGraph::get_params_custom('Used capacity in GiB');
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[GiB]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = ProxmoxGraph::graph_size_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $mem_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^proxmox-(node)-(swap)-(used|free)-aggr$/ ) {

    my ( $group_type, $domain_type, $mem_type );
    if ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }

    if ( $item =~ m/free/ ) {
      $mem_type   = "free";
      $cmd_params = ProxmoxGraph::get_params_custom('Free swap in GiB');
    }
    elsif ( $item =~ m/used/ ) {
      $mem_type   = "used";
      $cmd_params = ProxmoxGraph::get_params_custom('Used swap in GiB');
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[GiB]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = ProxmoxGraph::graph_swap_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $mem_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^proxmox-(node)-(io)-aggr$/ ) {

    my ( $group_type, $domain_type, $mem_type );
    if ( $item =~ m/node/ ) {
      $group_type  = "cluster";
      $domain_type = "node";
    }

    $cmd_params = ProxmoxGraph::get_params_custom('IO delay in %');

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[%]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $proxmox_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = ProxmoxGraph::graph_io_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( $exponent eq "0" ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_proxmox_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

# FusionCompute
sub graph_fusioncompute {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t2          = "COMMENT:\\n";
  my $req_time    = 0;
  my $act_time    = localtime();
  my $act_time_u  = time();
  my $upper_limit = "0.1";
  my $cmd         = "";
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph FusionCompute stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # TODO convert to the new url format (see Menu.pm)

  my $fusioncompute_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $fusioncompute_metadata = FusionComputeDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, acl_check => $fusioncompute_acl } );
  my $skip_acl               = ($fusioncompute_acl) ? 0 : 1;

  my $ban_exponent = 0;
  my $cmd_params   = my $label_context = my $header = '';
  if ( $item =~ m/cpu-percent/ ) {
    $cmd_params    = FusionComputeGraph::get_params_cpu('percent');
    $label_context = 'CPU%';
  }
  elsif ( $item =~ m/cpu/ ) {
    $cmd_params    = FusionComputeGraph::get_params_cpu('cores');
    $label_context = 'CPU';
  }
  elsif ( $item =~ m/mem-percent/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom( 'Memory usage in [%]', 100 );
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Memory in [GB]');
    $label_context = 'Memory';
  }
  elsif ( $item =~ m/disk-usage/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom( 'Disk usage in [%]', 100 );
    $label_context = 'Disk';
  }
  elsif ( $item =~ m/sectors/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Disk sectors';
  }
  elsif ( $item =~ m/capacity/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Capacity in [TB]');
    $label_context = 'Capacity';
  }
  elsif ( $item =~ m/data/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Data';
  }
  elsif ( $item =~ m/packet/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Read - Number - Write');
    $label_context = 'Packet';
  }
  elsif ( $item =~ m/net-usage/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom( 'Net usage in [%]', 100 );
    $label_context = 'Net usage';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Net';
  }
  elsif ( $item =~ m/iops/ || $item =~ m/disk-req/ || $item =~ m/ios/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Read - IOPS - Write');
    $label_context = 'IOPS';
  }
  elsif ( $item =~ m/latency/ || $item =~ m/ticks/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Read - ms - Write');
    $label_context = 'Latency';
  }
  elsif ( $item =~ m/net/ ) {
    $cmd_params    = FusionComputeGraph::get_params_custom('Read - MB/sec - Write');
    $label_context = 'Net';
  }
  my ( $graph_info, $rrd );
  if ( $item =~ m/^fusioncompute-vm/ ) {
    $label_context = 'VM ' . $label_context;
    if ( $item =~ m/^fusioncompute-vm-cpu-percent$/ ) {
      $graph_info = FusionComputeGraph::graph_cpu_percent( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-cpu$/ ) {
      $graph_info = FusionComputeGraph::graph_cpu( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-mem-percent$/ ) {
      $graph_info = FusionComputeGraph::graph_memory_percent( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-mem$/ ) {
      $graph_info = FusionComputeGraph::graph_memory( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-data$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'vm', 'data', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-disk-req$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'vm', 'disk_req', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-disk-ios$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'vm', 'disk_ios', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-disk-ticks$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'vm', 'disk_ticks', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-disk-sectors$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'vm', 'disk_sectors', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-disk-usage$/ ) {
      $graph_info = FusionComputeGraph::graph_disk_percent( $server, 'vm', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-net$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'vm', 'net', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-vm-net-packet-drop$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'vm', 'net_packet_drop', $skip_acl );
    }

    $rrd    = $fusioncompute_metadata->get_filepath_rrd( { type => 'vm', uuid => $server } );
    $header = FusionComputeGraph::get_header( 'vm', $server, $label_context );
  }
  elsif ( $item =~ m/^fusioncompute-host/ ) {
    $label_context = 'Host ' . $label_context;
    if ( $item =~ m/^fusioncompute-host-cpu-percent$/ ) {
      $graph_info = FusionComputeGraph::graph_cpu_percent( $server, 'host', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-cpu$/ ) {
      $graph_info = FusionComputeGraph::graph_cpu( $server, 'host', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-mem-percent$/ ) {
      $graph_info = FusionComputeGraph::graph_memory_percent( $server, 'host', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-mem$/ ) {
      $graph_info = FusionComputeGraph::graph_memory( $server, 'host', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-data$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'host', 'data', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-iops$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'host', 'disk_ios', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-net$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'host', 'net', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-net-usage$/ ) {
      $graph_info = FusionComputeGraph::graph_net_percent( $server, 'host', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-disk-usage$/ ) {
      $graph_info = FusionComputeGraph::graph_disk_percent( $server, 'host', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-packets-drop$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'host', 'net_packet_drop', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-host-packets$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'host', 'net_packet', $skip_acl );
    }

    $rrd    = $fusioncompute_metadata->get_filepath_rrd( { type => 'host', uuid => $server } );
    $header = FusionComputeGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^fusioncompute-cluster/ ) {
    $label_context = 'Cluster ' . $label_context;
    if ( $item =~ m/^fusioncompute-cluster-cpu-percent$/ ) {
      $graph_info = FusionComputeGraph::graph_cpu_percent( $server, 'cluster', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-cluster-mem-percent$/ ) {
      $graph_info = FusionComputeGraph::graph_memory_percent( $server, 'cluster', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-cluster-data$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'cluster', 'data', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-cluster-disk-usage$/ ) {
      $graph_info = FusionComputeGraph::graph_disk_percent( $server, 'cluster', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-cluster-net$/ ) {
      $graph_info = FusionComputeGraph::graph_read_write( $server, 'cluster', 'net', $skip_acl );
    }
    elsif ( $item =~ m/^fusioncompute-cluster-net-usage$/ ) {
      $graph_info = FusionComputeGraph::graph_net_percent( $server, 'cluster', $skip_acl );
    }

    $rrd    = $fusioncompute_metadata->get_filepath_rrd( { type => 'cluster', uuid => $server } );
    $header = FusionComputeGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^fusioncompute-datastore/ ) {
    $label_context = 'Datastore ' . $label_context;
    if ( $item =~ m/^fusioncompute-datastore-capacity$/ ) {
      $graph_info = FusionComputeGraph::graph_capacity( $server, 'datastore', $skip_acl );
    }

    $rrd    = $fusioncompute_metadata->get_filepath_rrd( { type => 'datastore', uuid => $server } );
    $header = FusionComputeGraph::get_header( 'datastore', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time = "last $text";

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }
  my ( $cmd_def, $cmd_cdef, $cmd_legend );
  $cmd_def    = $graph_info->{cmd_def};
  $cmd_cdef   = $graph_info->{cmd_cdef};
  $cmd_legend = $graph_info->{cmd_legend};
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( !defined $ban_exponent || $ban_exponent == 0 ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;
  $cmd .= " HRULE:0#000000";

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_fusioncompute : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_fusioncompute_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t2         = "COMMENT:\\n";
  my $lpar_orig  = $lpar;
  my $req_time   = 0;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $exponent   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph FusionCompute aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ':' . __LINE__ );
    return 0;
  }

  my $fusioncompute_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $fusioncompute_metadata = FusionComputeDataWrapperOOP->new( { conf_labels => 1, conf_arch => 1, acl_check => $fusioncompute_acl } );
  my $skip_acl               = ($fusioncompute_acl) ? 0 : 1;

  my $cmd_params = my $label_context = my $header = '';
  if ( $item =~ m/cpu/ ) {
    $cmd_params = FusionComputeGraph::get_params_custom('CPU usage in [%]');
  }
  elsif ( $item =~ m/mem/ ) {
    $cmd_params = FusionComputeGraph::get_params_custom('Memory uage in [%]');
  }

  my @uuids;
  if ( $item =~ m/^fusioncompute-host-vm-(.*)-aggr$/ ) {
    $label_context = 'Host ' . $label_context . ' aggregated ';
    my @vms = @{ $fusioncompute_metadata->get_items( { item_type => 'vm', parent_type => 'host', parent_uuid => $server } ) };
    my @sorting;
    foreach my $vm (@vms) {
      my ( $k, $v ) = each %{$vm};
      my $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => 'vm', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = FusionComputeGraph::get_header( 'host', $server, $label_context );
  }
  elsif ( $item =~ m/^fusioncompute-host-(.*)-aggr$/ ) {
    $label_context = 'Host ' . $label_context . ' aggregated ';
    my @hosts = @{ $fusioncompute_metadata->get_items( { item_type => 'host', parent_type => 'cluster', parent_uuid => $server } ) };
    my @sorting;
    foreach my $host (@hosts) {
      my ( $k, $v ) = each %{$host};
      my $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => 'host', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = FusionComputeGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^fusioncompute-vm-(.*)-aggr$/ ) {
    $label_context = 'VM ' . $label_context . ' aggregated ';
    my @vms = @{ $fusioncompute_metadata->get_items( { item_type => 'vm', parent_type => 'cluster', parent_uuid => $server } ) };
    my @sorting;
    foreach my $vm (@vms) {
      my ( $k, $v ) = each %{$vm};
      my $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => 'vm', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = FusionComputeGraph::get_header( 'cluster', $server, $label_context );
  }
  elsif ( $item =~ m/^fusioncompute-cluster-(.*)-aggr$/ ) {
    $label_context = 'Cluster ' . $label_context . ' aggregated ';
    my @clusters = @{ $fusioncompute_metadata->get_items( { item_type => 'cluster', parent_type => 'site', parent_uuid => $server } ) };
    my @sorting;
    foreach my $cluster (@clusters) {
      my ( $k, $v ) = each %{$cluster};
      my $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => 'cluster', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = FusionComputeGraph::get_header( 'site', $server, $label_context );
  }
  elsif ( $item =~ m/^fusioncompute-datastore-(.*)-aggr$/ ) {
    $label_context = 'Datastore ' . $label_context . ' aggregated ';
    my @datastores = @{ $fusioncompute_metadata->get_items( { item_type => 'datastore', parent_type => 'site', parent_uuid => $server } ) };
    my @sorting;
    foreach my $datastore (@datastores) {
      my ( $k, $v ) = each %{$datastore};
      my $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => 'datastore', uuid => $k } );
      unless ( -f $filepath ) { next; }
      push @sorting, $k;
    }
    my @sorting_sorted = sort @sorting;
    push @uuids, @sorting_sorted;

    $header = FusionComputeGraph::get_header( 'site', $server, $label_context );
  }
  else {
    error( "Unknown item $item. " . __FILE__ . ':' . __LINE__ );
    return 0;
  }
  $header .= ' : ';
  my $time       = "last $text";
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";                # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my $last_update_time = 0;    # for the "updated" label under graph legends
  $cmd_params = my $cmd_items = my $cmd_legend0 = my $cmd_legend = my $cmd_legend2 = "";

  my $labels = $fusioncompute_metadata->get_labels();

  if ( $item =~ m/^fusioncompute-(host|vm|cluster|host-vm)-(cpu-percent|mem-percent|disk-usage)-aggr$/ ) {
    my $metric;
    if ( $item =~ m/cpu/ ) {
      $cmd_params = FusionComputeGraph::get_params_custom( 'CPU usage in [%]', 100 );
      $metric     = "cpu_usage";
    }
    elsif ( $item =~ m/disk-usage/ ) {
      $cmd_params = FusionComputeGraph::get_params_custom( 'Disk usage in [%]', 100 );
      $metric     = "disk_usage";
      if ( $item =~ m/(host|cluster)/ ) {
        $metric = "logic_disk_usage";
      }
    }
    else {
      $cmd_params = FusionComputeGraph::get_params_custom( 'Memory usage in [%]', 100 );
      $metric     = "mem_usage";
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/host-vm/ ) {
      $group_type  = "host";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/cluster/ ) {
      $group_type  = "site";
      $domain_type = "cluster";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[%]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = FusionComputeGraph::graph_percent_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(host|vm|host-vm)-(cpu)-aggr$/ ) {

    $cmd_params = FusionComputeGraph::get_params_custom('CPU usage in [cores]');

    my ( $group_type, $domain_type );
    if ( $item =~ m/host-vm/ ) {
      $group_type  = "host";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/cluster/ ) {
      $group_type  = "site";
      $domain_type = "cluster";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[%]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = FusionComputeGraph::graph_cpu_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $item );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    if ( $item =~ m/host-vm/ ) {
      my $host_filepath = $fusioncompute_metadata->get_filepath_rrd( { type => 'host', uuid => $server } );
      $cmd_items  .= " DEF:cpu_cores_host=\"$host_filepath\":cpu_cores_wr:AVERAGE";
      $cmd_legend .= " LINE2:cpu_cores_host#000000:\" Total\"";
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(datastore)-(free|used)-aggr$/ ) {

    $cmd_params = FusionComputeGraph::get_params_custom('Capacity in [TB]');

    my $metric = "used";
    if ( $item =~ m/free/ ) {
      $metric = "free";
    }

    my ( $group_type, $domain_type );
    $group_type  = "site";
    $domain_type = "datastore";

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[TB]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = FusionComputeGraph::graph_capacity_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(host|vm|host-vm)-(mem-free|mem-used)-aggr$/ ) {

    my $metric;
    if ( $item =~ m/mem-free/ ) {
      $metric = "free";
    }
    else {
      $metric = "used";
    }

    $cmd_params = FusionComputeGraph::get_params_custom('Memory in [GB]');

    my ( $group_type, $domain_type );
    if ( $item =~ m/host-vm/ ) {
      $group_type  = "host";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/cluster/ ) {
      $group_type  = "site";
      $domain_type = "cluster";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[%]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor = $color[ $itemcount % $#color ];

      my $graph = FusionComputeGraph::graph_memory_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items  .= $graph->{cmd_def};
      $cmd_items  .= $graph->{cmd_cdef};
      $cmd_legend .= $graph->{cmd_legend};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(host|cluster)-(net-usage)-aggr$/ ) {
    my $metric;
    $cmd_params = FusionComputeGraph::get_params_custom('Read - % - Write');
    $metric     = "net_usage";

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/cluster/ ) {
      $group_type  = "site";
      $domain_type = "cluster";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[%]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = FusionComputeGraph::graph_read_write_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(host|vm|cluster)-(data|net|disk-sectors)-aggr$/ ) {
    my $metric;
    $cmd_params = FusionComputeGraph::get_params_custom('Read - MB/sec - Write');
    if ( $item =~ m/data/ ) {
      $metric = "data";
    }
    elsif ( $item =~ m/sectors/ ) {
      $metric = "sectors";
    }
    else {
      $metric = "net";
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }
    elsif ( $item =~ m/cluster/ ) {
      $group_type  = "site";
      $domain_type = "cluster";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[MB/sec]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = FusionComputeGraph::graph_read_write_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(host|vm)-(disk-req|disk-ios|iops)-aggr$/ ) {
    my $metric;
    $cmd_params = FusionComputeGraph::get_params_custom('Read - IOPS - Write');
    if ( $item =~ m/disk_req/ ) {
      $metric = "disk_req";
    }
    else {
      $metric = "disk_ios";
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[IOPS]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = FusionComputeGraph::graph_iops_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(vm)-(disk-ticks)-aggr$/ ) {
    my $metric;
    $cmd_params = FusionComputeGraph::get_params_custom('Read - ms - Write');
    if ( $item =~ m/disk_ticks/ ) {
      $metric = "disk_ticks";
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[IOPS]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = FusionComputeGraph::graph_latency_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }
  elsif ( $item =~ m/^fusioncompute-(vm|host)-(net-packet-drop|packets|packets-drop)-aggr$/ ) {
    my $metric;
    $cmd_params = FusionComputeGraph::get_params_custom('Read - number - Write');
    if ( $item =~ m/net-packet-drop/ || $item =~ m/packets-drop/ ) {
      $metric = "packet_drop";
    }
    elsif ( $item =~ m/packets/ ) {
      $metric = "packets";
    }

    my ( $group_type, $domain_type );
    if ( $item =~ m/host/ ) {
      $group_type  = "cluster";
      $domain_type = "host";
    }
    elsif ( $item =~ m/vm/ ) {
      $group_type  = "cluster";
      $domain_type = "vm";
    }

    my $legend_helper0 = $group_type;
    my $legend_helper1 = $domain_type;
    $cmd_legend0 = " COMMENT:\"[IOPS]\"";
    $cmd_legend0 .= " COMMENT:\\n";
    $cmd_legend0 .= " COMMENT:\"${legend_helper0}                        ${legend_helper1}                      Avrg      Max\\n\"";

    my $cmd_legend_lower = my $cmd_legend_upper = '';
    my ( $graph_info, $filepath, $itemcolor, $itemcolor2, $itemlabel, $grouplabel );
    my $itemcount = 0;

    foreach my $this_uuid (@uuids) {

      $filepath = $fusioncompute_metadata->get_filepath_rrd( { type => $domain_type, uuid => $this_uuid } );

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ':' . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      #if ( $rrd_update_time < $req_time ) {
      #  next;
      #}
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $itemlabel  = $labels->{$domain_type}->{$this_uuid};
      $grouplabel = $labels->{$group_type}->{$server};

      $itemlabel  =~ s/:/\\:/g;
      $grouplabel =~ s/:/\\:/g;
      $itemcolor  = $color[ $itemcount % $#color ];
      $itemcolor2 = $color[ ( $itemcount + $#color / 2 ) % $#color ];

      my $graph = FusionComputeGraph::graph_number_aggr( $domain_type, $filepath, $itemcount, $itemcolor, $itemcolor2, $itemlabel, $grouplabel, $group_type, $metric, $item );

      $cmd_items        .= $graph->{cmd_def};
      $cmd_items        .= $graph->{cmd_cdef};
      $cmd_legend_lower .= $graph->{cmd_legend_lower};
      $cmd_legend_upper .= $graph->{cmd_legend_upper};

      $itemcount++;
    }

    $cmd_legend  .= $cmd_legend_lower;
    $cmd_legend2 .= $cmd_legend_upper;

  }

  # remove vertical label from Dashboard
  if ( $detail == 2 ) {
    $cmd_params =~ s/ --vertical-label=\".+?\"/ /;
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";

  if ( $exponent eq "0" ) {
    $cmd .= " --units-exponent=1.00";
  }
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    #$cmd .= " $vertical_label";
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_legend0;
  $cmd .= $cmd_items;
  $cmd .= $cmd_legend;
  $cmd .= $cmd_legend2;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_fusioncompute_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_these_rrd_files {
  my $host           = shift;
  my $server         = shift;
  my $lpar           = shift;
  my $type           = shift;
  my $name_out       = shift;
  my $type_sam       = shift;
  my $detail         = shift;
  my $graph_hours    = shift;
  my $entitle        = shift;
  my $start_unix     = shift;
  my $end_unix       = shift;
  my $item           = shift;
  my $adapter_suffix = shift;
  my $files          = shift;
  my $t2             = "COMMENT:\\n";
  my $step_new       = $step;
  my $last           = "COMMENT: ";
  my $act_time       = localtime();
  my $act_time_u     = time();
  my $req_time       = 0;
  my $cmd            = "";
  my $xgrid          = xgrid_set( $type, $detail );
  my $text           = text_set($type);

  if ( !defined $files ) {
    error( "Graph error : graph_sriovagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_lparagg: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }
  my $lan_san;
  my $data_packets;

  $lan_san = "LAN" if ( $item =~ m/lan/ );
  $lan_san = "HEA" if ( $item =~ m/hea/ );
  $lan_san = "SAN" if ( $item =~ m/san/ );
  $lan_san = "SAS" if ( $item =~ m/sas/ );
  $lan_san = "SRI" if ( $item =~ m/sri/ );

  $data_packets = "data"    if ( $item =~ m/data/ );
  $data_packets = "packets" if ( $item =~ m/io/ );

  $item =~ s/_data//;
  $item =~ s/_io//;

  #print STDERR "lan_san: $lan_san\tdata_packets:$data_packets\n";

  if ( !defined $lan_san || !defined $data_packets || $lan_san eq "" || $data_packets eq "" ) {
    error("Not defined item or lpar parameter parsing to graph_power_adapters_agg2 subroutine\n");
    return (0);
  }

  my $head = $lan_san;
  if ( $head eq "SRI" ) {
    $head = "SR-IOV";
  }
  my $header = "$head aggregated : $host last $text";
  if ( $detail == 1 ) {
    $header = "$head aggregated : $host : last $text";
  }
  elsif ( $detail == 2 ) {
    $header = "$head aggregated : $text";
  }

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  elsif ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  elsif ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;    # set here too
    $end_time   = $end_unix;
    $xgrid      = "";             # just a trick
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $header = "$head aggregated: $host : $start_human - $end_human";
  }

  my $rrd_type = $adapter_suffix;

  #opendir( DIR, "$wrkdir/$server/$host/adapters" ) || error( "can't opendir $wrkdir/$server/$host/adapters: $! :" . __FILE__ . ":" . __LINE__ ) && return 0;
  #my @files_unsorted = grep( /$rrd_type/, readdir(DIR) );
  #my @files = sort { lc $a cmp lc $b } @files_unsorted;
  if ( !($files) ) {
    return;
  }

  #closedir(DIR);

  if ( $graph_hours > 0 ) {

    # alerting
    $start_time = "now-" . $graph_hours . "h";
    if ( $graph_hours < 12 ) {
      $xgrid = "--x-grid=MINUTE:60:HOUR:1:HOUR:1:0:%H";
    }
    else {
      if ( $graph_hours > 24 ) {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:4:0:%H";
      }
      else {
        $xgrid = "--x-grid=MINUTE:60:HOUR:2:HOUR:2:0:%H";
      }
    }
  }
  my $vertical_label;
  if ( $data_packets eq "data" ) {
    $vertical_label = "--vertical-label=\"Read - Bytes/sec - Write\"";
  }
  elsif ( $data_packets eq "packets" ) {
    if ( $lan_san eq "LAN" || $lan_san eq "HEA" || $lan_san eq "SRI" ) {
      $vertical_label = "--vertical-label=\"Read - Packets/sec - Write\"";
    }
    else {
      $vertical_label = "--vertical-label=\"Read - IOPS - Write\"";
    }
  }

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }
  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 1 ) {
    $cmd .= " COMMENT:\"Int                             READ    Avg       Max           WRITE   Avg      Max\\l\"";
  }

  my $file        = "";
  my $i           = 0;
  my $gtype       = "AREA";
  my $color_index = 0;
  my $cmdx        = "";
  my $write_var   = $lan_san ? "sbyte" : "wbyte";
  my $sriov_aliases;
  if ( -f "$basedir/data/$server/$host/sriov_aliases.json" ) {
    $sriov_aliases = read_json("$basedir/data/$server/$host/sriov_aliases.json");
  }
  foreach my $menu_item ( sort keys %{$files} ) {

    foreach $file ( @{ $files->{$menu_item} } ) {
      chomp($file);
      if ( !( $lpar =~ $menu_item ) ) {
        next;
      }
      my $file_pth = "$wrkdir/$server/*/adapters/$file";
      my ( $result_cmd, $read, $write, $io_read, $io_write ) = LPM_easy( "AVERAGE", $file_pth, $i, "0", "read", "write", "io_read", "io_write" );
      $cmd .= $result_cmd;
      my $file_orig = $file;

      $lpar = $file;
      $lpar =~ s/\.$rrd_type//;    # remove rrd suffix

      my $lpar_space_proc = $lpar;
      my $lpar_space      = $lpar;

      # add spaces to lpar name to have 12 chars total (for formating graph legend)
      $lpar_space =~ s/\&\&1/\//g;
      $lpar_space .= " " x ( 12 - length($lpar_space) ) if ( length($lpar_space) < 12 );

      $lpar_space      =~ s/:/\\:/g;    # anti ':'
      $lpar_space_proc =~ s/:/\\:/g;
      $lpar_space_proc =~ s/%/%%/g;     # anti '%
      $lpar_space_proc =~ s/\.$//g;
      my $adapter_legend_png;
      if ( defined $sriov_aliases->{$lpar} ) {
        $adapter_legend_png = "$lpar ($sriov_aliases->{$lpar})";
      }
      else {
        $adapter_legend_png = "$lpar";
      }
      while ( length($adapter_legend_png) < 30 ) {
        $adapter_legend_png = "$adapter_legend_png ";
      }

      my $wrkdir_server_host_file = "$wrkdir/$server/$host/adapters/$file";
      $wrkdir_server_host_file =~ s/:/\\:/g;
      my $wrkdir_server_host_file_legend = $lpar_space_proc;

      $wrkdir_server_host_file_legend =~ s/%/%%/g;

      #print STDERR "$delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $item\n";
      if ( $data_packets eq "data" ) {

        #$cmd .= " DEF:read${i}=\"$wrkdir_server_host_file\":read:AVERAGE"; #05/06/2018 saving in kB insted of B
        #$cmd .= " DEF:write${i}=\"$wrkdir_server_host_file\":write:AVERAGE";
        $cmd .= " CDEF:write_B${i}=$write,1024,*";
        $cmd .= " CDEF:read_B${i}=$read,1024,*";

        $cmd .= " CDEF:write_kB${i}=$write,1,*";
        $cmd .= " CDEF:read_kB${i}=$read,1,*";

        $cmd .= " CDEF:write_MB${i}=write_kB${i},1024,/";
        $cmd .= " CDEF:read_MB${i}=read_kB${i},1024,/";

        $cmd .= " CDEF:write_B_neg${i}=write_B${i},-1,*";
        $cmd .= " CDEF:read_B_neg${i}=read_B${i},-1,*";

        $cmd .= " COMMENT:\"$adapter_legend_png\"";
        $cmd .= " $gtype:read_B_neg${i}$color[$color_index]:\" \"";
        $cmd .= " GPRINT:read_MB${i}:AVERAGE:\" %5.2lf \"";
        $cmd .= " GPRINT:read_MB${i}:MAX:\" %5.2lf        \"";
        $cmd .= " PRINT:read_MB${i}:AVERAGE:\"%5.2lf $delimiter $item $delimiter $lpar_space_proc $delimiter $lpar $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:read_MB${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";

        $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

        $cmdx .= " $gtype:write_B${i}$color[$color_index]: ";
        $gtype = "STACK";
        $cmd .= " $gtype:0$color[$color_index]:\" \"";
        $cmd .= " GPRINT:write_MB${i}:AVERAGE:\" %5.2lf \"";
        $cmd .= " GPRINT:write_MB${i}:MAX:\" %5.2lf \"";
        $cmd .= " PRINT:write_MB${i}:AVERAGE:\"%5.2lf $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:write_MB${i}:MAX:\" %5.2lf $delimiter $wrkdir_server_host_file_legend\"";
        $cmd .= " $t2";
      }
      elsif ( $data_packets eq "packets" && ( $lan_san eq "LAN" || $lan_san eq "SRI" || $lan_san eq "HEA" ) ) {

        #      $cmd .= " DEF:read_io${i}=\"$wrkdir_server_host_file\":io_read:AVERAGE";
        #      $cmd .= " DEF:write_io${i}=\"$wrkdir_server_host_file\":io_write:AVERAGE";
        $cmd .= " CDEF:write_packets${i}=$io_write,1,/";
        $cmd .= " CDEF:read_packets${i}=$io_read,1,/";
        $cmd .= " CDEF:write_packets_neg${i}=write_packets${i},-1,*";
        $cmd .= " CDEF:read_packets_neg${i}=read_packets${i},-1,*";

        $cmd .= " COMMENT:\"$adapter_legend_png\"";
        $cmd .= " $gtype:read_packets_neg${i}$color[$color_index]:\" \"";
        $cmd .= " GPRINT:read_packets${i}:AVERAGE:\" %.0lf \"";
        $cmd .= " GPRINT:read_packets${i}:MAX:\" %.0lf        \"";
        $cmd .= " PRINT:read_packets${i}:AVERAGE:\"%.0lf $delimiter $item $delimiter $lpar_space_proc $delimiter $lpar $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:read_packets${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";

        $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

        $cmdx .= " $gtype:write_packets${i}$color[$color_index]: ";
        $gtype = "STACK";
        $cmd .= " $gtype:0$color[$color_index]:\" \"";
        $cmd .= " GPRINT:write_packets${i}:AVERAGE:\" %.0lf \"";
        $cmd .= " GPRINT:write_packets${i}:MAX:\" %.0lf \"";
        $cmd .= " PRINT:write_packets${i}:AVERAGE:\"%.0lf $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:write_packets${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";
        $cmd .= " $t2";
      }
      elsif ( $data_packets eq "packets" && $lan_san eq "SAN" ) {

        #      $cmd .= " DEF:read_io${i}=\"$wrkdir_server_host_file\":io_read:AVERAGE";
        #      $cmd .= " DEF:write_io${i}=\"$wrkdir_server_host_file\":io_write:AVERAGE";
        #$cmd .= " CDEF:write_iops${i}=write_io${i},$hmc_iops_divide,/";
        #$cmd .= " CDEF:read_iops${i}=read_io${i},$hmc_iops_divide,/";
        $cmd .= " CDEF:write_iops${i}=$io_write${i},1,/";
        $cmd .= " CDEF:read_iops${i}=$io_read${i},1,/";
        $cmd .= " CDEF:write_iops_neg${i}=write_iops${i},-1,*";
        $cmd .= " CDEF:read_iops_neg${i}=read_iops${i},-1,*";

        $cmd .= " COMMENT:\"$adapter_legend_png\"";
        $cmd .= " $gtype:read_iops_neg${i}$color[$color_index]:\" \"";
        $cmd .= " GPRINT:read_iops${i}:AVERAGE:\" %.0lf \"";
        $cmd .= " GPRINT:read_iops${i}:MAX:\" %.0lf        \"";
        $cmd .= " PRINT:read_iops${i}:AVERAGE:\"%.0lf $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:read_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";

        $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

        $cmdx .= " $gtype:write_iops${i}$color[$color_index]: ";
        $gtype = "STACK";
        $cmd .= " $gtype:0$color[$color_index]:\" \"";
        $cmd .= " GPRINT:write_iops${i}:AVERAGE:\" %.0lf \"";
        $cmd .= " GPRINT:write_iops${i}:MAX:\" %.0lf \"";
        $cmd .= " PRINT:write_iops${i}:AVERAGE:\"%.0lf $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:write_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";
        $cmd .= " $t2";
      }
      elsif ( $data_packets eq "packets" && $lan_san eq "SAS" ) {
        $cmd .= " DEF:read_io${i}=\"$wrkdir_server_host_file\":io_read:AVERAGE";
        $cmd .= " DEF:write_io${i}=\"$wrkdir_server_host_file\":io_write:AVERAGE";
        $cmd .= " CDEF:write_iops${i}=write_io${i},$hmc_iops_divide,/";
        $cmd .= " CDEF:read_iops${i}=read_io${i},$hmc_iops_divide,/";
        $cmd .= " CDEF:write_iops_neg${i}=write_iops${i},-1,*";
        $cmd .= " CDEF:read_iops_neg${i}=read_iops${i},-1,*";

        $cmd .= " COMMENT:\"$adapter_legend_png\"";
        $cmd .= " $gtype:read_iops_neg${i}$color[$color_index]:\" \"";
        $cmd .= " GPRINT:read_iops${i}:AVERAGE:\" %.0lf \"";
        $cmd .= " GPRINT:read_iops${i}:MAX:\" %.0lf        \"";
        $cmd .= " PRINT:read_iops${i}:AVERAGE:\"%.0lf $delimiter $item $delimiter $lpar_space_proc $delimiter $color[$color_index] $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:read_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";

        $color_index = ( $color_index + 1 ) % ( $color_max + 1 );

        $cmdx .= " $gtype:write_iops${i}$color[$color_index]: ";
        $gtype = "STACK";
        $cmd .= " $gtype:0$color[$color_index]:\" \"";
        $cmd .= " GPRINT:write_iops${i}:AVERAGE:\" %.0lf \"";
        $cmd .= " GPRINT:write_iops${i}:MAX:\" %.0lf \"";
        $cmd .= " PRINT:write_iops${i}:AVERAGE:\"%.0lf $delimiter $color[$color_index]\"";
        $cmd .= " PRINT:write_iops${i}:MAX:\" %.0lf $delimiter $wrkdir_server_host_file_legend\"";
        $cmd .= " $t2";
      }
      $color_index = ( $color_index + 1 ) % ( $color_max + 1 );
      $i++;
      $cmd .= " COMMENT:\"\\l\"";
    }
  }

  $cmd .= " $cmdx";
  $cmd .= " HRULE:0#000000";
  $cmd =~ s/COMMENT: //g;    # a trick, there was a problem with aggregated and "COMMENT: "
  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param( $ret, "", "", $data_packets );
  return 0;
}

sub write_json {
  my $path   = shift;
  my $config = shift;                      # hash holding configuration
                                           # my $json = JSON->new->utf8;    # this will produce compressed JSON - shorter, better for machine reading
  my $json   = JSON->new->utf8->pretty;    # this will produce human readable files
  if ( !defined $config || $config eq "" ) {

    #print "Data missing in write_json, nothing to write\n";
    return -1;
  }

  # write to JSON file
  if ( open( CFG, ">$path" ) ) {
    eval { print CFG $json->encode($config); };
    if (@_) {
      error("Can't open $path and write config:$config");
    }
    close CFG;
  }
  else {
    # error handling
  }
  return 1;
}

sub read_json {
  my $src = shift;
  if ( !defined $src || $src eq "" ) {
    error( "Path to json file(\"$src\") not defined, can't read it at " . __FILE__ . ":" . __LINE__ . "\n" );
    return -1;
  }
  my $read;
  my $rawcfg;    # helper for file reading
                 # read from JSON file
  if ( open( CFG, "$src" ) ) {
    local $/ = undef;    # required for re-read of encode_json pretty output
    $rawcfg = <CFG>;
    if ($rawcfg) {
      $read = decode_json($rawcfg);
    }
    close CFG;
  }
  else {
    error("cannot open json file \"$src\" in read_json function, probably doesn't exist\n");

    # error handling
  }
  return $read;
}

# hyperv cluster servers graph
#

sub frame_multi {    #$host, $server, $lpar, $time, $name_out, $type_sam, $detail, $graph_hours, $entitle, $start_unix, $end_unix
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT:\" \"";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT:\" \"";
  my $act_time_u  = time();
  my $req_time    = 0;

  my $head = "Servers aggregated";

  # working for items: hyp_clustser, hyp_clustsercpu, hyp_clustsermem, hyp_clustservms
  $head = "VMs aggregated" if $item eq "hyp_clustservms";
  $head = "CPU usage"      if $item eq "hyp_clustsercpu";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  elsif ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  elsif ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  my $vertical_label = "--vertical-label=\"CPU cores\"";
  if ( $item eq "hyp_clustsermem" ) {
    $vertical_label = "--vertical-label=\"Memory in GiBytes\"";
    $head           = "Memory usage";
  }

  my $header = "$head : last $text";

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
    $header         = "$head :$text";
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;           # set here too
    $end_time   = $end_unix;
    unless ( $detail == 10 ) {
      $xgrid = "";                       # just a trick
    }
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);

    # $header = "$head aggregated: $host : $start_human - $end_human";
    $header = "$head : $host : $start_human - $end_human";
  }

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST:\" %4.0lf\"";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  # print STDERR "19179 \$item $item \$type $type \$detail $detail \$xgrid $xgrid \$start_unix $start_unix \$end_unix $end_unix\n";
  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph frame_multi: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  # print STDERR "19152 $host $server $lpar\n";
  my $delim = $host;
  $delim =~ s/^cluster_//;

  my $file_html_nodes = "$wrkdir/$server/$host/node_list.html";

  #$file_html_nodes =~ s/%3A/:/g;    # host can have port vmware:444"
  my @managednamelist = ();

  # print STDERR "detail-graphs-cgi.pl 19158 $file_html_nodes\n";
  if ( -f "$file_html_nodes" ) {
    open( FH, "< $file_html_nodes" );
    while ( my $line = <FH> ) {

      # print STDERR "19164 \$delim $delim \$line $line\n";
      push @managednamelist, $line if $line =~ /$delim/;    # take just server lines
    }
    close(FH);
  }
  else {
    error( "Multi graph rrdtool error, cannot read nodes from file $file_html_nodes : " . __FILE__ . ":" . __LINE__ );
    exit;
  }

  my $file = "";
  my $i    = 0;
  my $cmd  = "";
  my $cmdq = "";
  my $j    = 0;
  my $managed_ok;
  my $managedname_exl = "";
  my $managedname     = "";
  my @m_excl          = "";
  my $ind             = 0;

  # my @managednamelist = ();
  my $DEBUG = 1;
  my $cluster;
  if ( $item eq "hyp_clustsercpu" || $item eq "hyp_clustsermem" ) {
    $no_legend  = "--interlaced";
    $rrd_legend = "orig";
  }

  # print STDERR "19226 creating cluster servers graph : $host:$type:@managednamelist \$no_legend $no_legend \$rrd_legend $rrd_legend\n" ;

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 && $detail != 10 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " $vertical_label";

  #$cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";

  #                            $cmd .= " --alt-autoscale-max";
  #$cmd .= " --upper-limit=0.1";
  #$cmd .= " --units-exponent=1.00";
  $cmd .= " $xgrid";

  if ( $item ne "hyp_clustsermem" && $item ne "hyp_clustservms" ) {
    $cmd .= " COMMENT:\\\"Utilization in CPU cores\\:               average   maximum\\l\\\"";
  }
  if ( $item eq "hyp_clustservms" ) {
    $cmd .= " COMMENT:\\\"Utilization in CPU cores                       \\l\\\"";
    $cmd .= " COMMENT:\\\"  Server                            VM                                     avrg     max\\l\\\"";
  }

  my $gtype      = "AREA";
  my $color_indx = 0;

  my $lpar_color_index = -1;
  my $line_indx        = 0;     # place enter every 3rd line
  my $files_index      = -1;    # for vmware it is color index

  foreach my $line (@managednamelist) {

    # <TR> <TD><B>MSNET-HVCL</B></TD> <TD align="center">ad.xorux.com</TD> <TD align="center">HVNODE01</TD> <TD align="center">UnDeFiNeD</TD> <TD align="center">UnDeFiNeD</TD></TR>
    chomp($line);
    my @atoms = split( "<\/TD>", $line );
    ( undef, my $domain ) = split( ">", $atoms[1] );
    ( undef, my $server ) = split( ">", $atoms[2] );

    # print STDERR "19235 \$domain $domain \$server $server\n";

    if ( $line =~ /No results were found/ ) {
      print STDERR "hyperv cluster servers : $host does not contain any managed system\n" if $DEBUG;
      return 0;
    }

    $managedname = $line;

    $managed_ok = 1;

    #if ( $managed_systems_exclude ne '' ) {
    #  @m_excl = split( /:/, $managed_systems_exclude );
    #  foreach $managedname_exl (@m_excl) {
    #    chomp($managedname_exl);
    #    if ( $managedname =~ m/^$managedname_exl$/ ) {
    #      $managed_ok = 0;
    #    }
    #  } ## end foreach $managedname_exl (@m_excl)
    #} ## end if ( $managed_systems_exclude...)
    if ( $managed_ok == 0 ) {
      next;
    }

    $file = "pool.rrm";

    my $wrkdir_managedname_host_file = "$wrkdir/windows/domain_$domain/$server/$file";

    #print STDERR "19286  creating CMD for $wrkdir_managedname_host_file\n";

    if ( -f "$wrkdir_managedname_host_file" ) {

      # avoid old servers which do not exist in the period
      my $rrd_upd_time = ( stat("$wrkdir_managedname_host_file") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
    }
    else {
      # avoid non-existing managed systems (with no utilization data on)
      next;
    }

    my $rrd                    = $wrkdir_managedname_host_file;
    my $managedname_space      = $server;
    my $managedname_space_proc = $server;
    $managedname_space_proc =~ s/:/\\:/g;
    $managedname_space_proc =~ s/%/%%/g;    # anti '%

    for ( my $k = length($server); $k < 35; $k++ ) {
      $managedname_space .= " ";
    }
    $managedname_space = substr( $managedname_space, 0, 34 );    # not longer

    $managedname_space =~ s/:/\\:/g;                             # anti ':'

    # print STDERR "2 creating CMD for $wrkdir_managedname_host_file\n" if $DEBUG ;

    $wrkdir_managedname_host_file =~ s/:/\\:/g;
    my $wrkdir_managedname_host_file_legend = $wrkdir_managedname_host_file;
    $wrkdir_managedname_host_file_legend =~ s/%/%%/g;

    if ( $item eq "hyp_clustservms" ) {
      my $hosting_file = "$wrkdir/windows/domain_$domain/$server/VM_hosting.vmh";
      my @vm_hosting   = ();
      if ( -f "$hosting_file" ) {
        open( FHC, "< $hosting_file" ) || error( "cannot open file : $hosting_file " . __FILE__ . ":" . __LINE__ ) && return 0;
        @vm_hosting = <FHC>;
        close(FHC);
      }

      #prepare VM file names
      my @files = @vm_hosting;

      # print STDERR "19356 $wrkdir/$server/$host/VM_hosting.vmh \@files @files\n";

      # my $ind = 0;
      foreach my $file (@files) {
        $files_index++;
        $files_index = $files_index % $color_max;

        chomp $file;
        my $file_orig = $file;
        $file =~ s/:.*/\.rrm/;

        # print STDERR "19359 \$hyperv $hyperv $wrkdir / $host / $server / $file \$domain $domain i $wrkdir/windows/$domain/hyperv_VMs/$file\n";
        next if !-f "$wrkdir/windows/domain_$domain/hyperv_VMs/$file";

        # avoid old lpars which do not exist in the period
        my $rrd_upd_time = ( stat("$wrkdir/windows/domain_$domain/hyperv_VMs/$file") )[9];
        next if ( $rrd_upd_time < $req_time );

        my $wrkdir_server_host_file = "$wrkdir/windows/domain_$domain/hyperv_VMs/$file";

        my $wrkdir_server_host_file_legend = "toto je legenda";

        $lpar = $file;
        $lpar =~ s/\.rrm$//;
        my $lpar_orig = human_vmware_name( $lpar, "", "domain_$domain" );

        # my $lpar_orig = human_vmware_name( $lpar, "", $managedname, $host );
        $lpar = substr( $lpar_orig, 0, 35 );

        my $lpar_space      = $lpar;
        my $lpar_space_proc = $lpar_orig;

        if ( $lpar eq '' ) {
          next;    # avoid .rrm --> just to be sure :)
        }

        # add spaces to lpar name to have 35 chars total (for formating graph legend)
        $lpar_space =~ s/\&\&1/\//g;
        for ( my $k = length($lpar_space); $k < 35; $k++ ) {
          $lpar_space .= " ";
        }
        $lpar_space = $managedname_space . $lpar_space;

        # analyse $file_orig
        # 502a854c-d67c-5015-8f48-f161d122eae0:start=1440417087:end=1440418087:start=144419087:end=1440420087:start=1440421087..."
        # for graphing -> there are $start_time and $end_time, both unix
        my @st_end = split( "start", $file_orig );

        if ( scalar @st_end < 2 ) {    # some trash -> ignore
          next;
        }
        if ( ( scalar @st_end == 2 && $st_end[1] !~ 'end' ) || ( ( scalar @st_end > 2 ) && ( $st_end[-1] !~ /end/ ) ) ) {    # one start, no end -> no problem || no end in last atom
          $cmd .= " DEF:utiltot_mhzt_perc${ind}=\"$wrkdir_server_host_file\":PercentTotalRunTime:AVERAGE";
          $cmd .= " DEF:utiltot_mhzt_time${ind}=\"$wrkdir_server_host_file\":Timestamp_PerfTime:AVERAGE";
          $cmd .= " DEF:utiltot_mhzt_freq${ind}=\"$wrkdir_server_host_file\":Frequency_PerfTime:AVERAGE";
          $cmd .= " DEF:utiltot_mhzt_vcpu${ind}=\"$wrkdir_server_host_file\":vCPU:AVERAGE";
          $cmd .= " CDEF:utiltot_mhzt${ind}=utiltot_mhzt_perc${ind},utiltot_mhzt_time${ind},/,utiltot_mhzt_freq${ind},*,100000,/,100,/,utiltot_mhzt_vcpu${ind},*";    #orig was 25
          $cmd .= " CDEF:utiltot${ind}=utiltot_mhzt${ind}";

          # print STDERR "19383 \$cmd $cmd\n";
        }
        else {
          next;                                                                                                                                                       # do not take here stopped VMs
        }

        my $index_to_display = $color_indx;
        if ( $lpar_color_index > -1 ) {
          $index_to_display = $lpar_color_index;
        }

        $cmd .= " $gtype:utiltot${ind}$color[$index_to_display]:\"$lpar_space\"";

        $cmd .= " GPRINT:utiltot${ind}:AVERAGE:\"%5.1lf \"";
        $cmd .= " GPRINT:utiltot${ind}:MAX:\" %5.1lf \\l\"";
        my $my_item = "hyp_clustservms";
        $cmd .= " PRINT:utiltot${ind}:AVERAGE:\"%5.1lf $delimiter $my_item $delimiter $managedname_space $delimiter $lpar_space_proc $delimiter $color[$index_to_display] $delimiter $host\"";
        $cmd .= " PRINT:utiltot${ind}:AVERAGE:\"%5.1lf $delimiter $color[$index_to_display] $delimiter $wrkdir_server_host_file\"";
        $cmd .= " PRINT:utiltot${ind}:MAX:\" %5.1lf $delimiter $wrkdir_server_host_file_legend\"";

        #$cmd .= " GPRINT:utiltot${i}:MAX:\" %5.2lf \\l\"";
        # --> it does not work ideally with newer RRDTOOL (1.2.30 --> it needs to be separated by cariage return here)

        $color_indx = ( $color_indx + 1 ) % ( $color_max + 1 );

        #    $col_indx++;
        $gtype = "STACK";

        $ind++;
      }

      # return;
    }

    # bulid RRDTool cmd
    if ( $item eq "hyp_clustsermem" ) {
      $cmd .= " DEF:free${i}=$rrd:AvailableMBytes:AVERAGE";
      $cmd .= " DEF:tot${i}=$rrd:TotalPhysMemory:AVERAGE";
      $cmd .= " DEF:cachebytes${i}=$rrd:CacheBytes:AVERAGE";
      $cmd .= " CDEF:freeg${i}=free${i},1024,/";
      $cmd .= " CDEF:totg${i}=tot${i},1024,/,1024,/,1024,/";
      $cmd .= " CDEF:cacheg${i}=cachebytes${i},1024,/,1024,/,1024,/";
      $cmd .= " CDEF:used_comp${i}=totg${i},freeg${i},-";
      $cmd .= " CDEF:used${i}=used_comp${i},0,LE,0,used_comp${i},IF";
      $cmd .= " CDEF:freegc${i}=freeg${i},cacheg${i},-";

      if ( $i == 0 ) {
        $cmd .= " CDEF:t_cacheg${i}=cacheg${i}";
        $cmd .= " CDEF:t_used${i}=used${i}";
        $cmd .= " CDEF:t_freegc${i}=freegc${i}";
      }
      else {
        my $ci = $i - 1;
        $cmd .= " CDEF:t_cacheg${i}=cacheg${i},t_cacheg${ci},+";
        $cmd .= " CDEF:t_used${i}=used${i},t_used${ci},+";
        $cmd .= " CDEF:t_freegc${i}=freegc${i},t_freegc${ci},+";

      }
      $i++;
      if ( $color_indx > $color_max ) {
        $color_indx = 0;
      }
    }
    elsif ( $item ne "hyp_clustservms" ) {
      $cmd .= " DEF:cpu_perc${i}=\"$rrd\":PercentTotalRunTime:AVERAGE";
      $cmd .= " DEF:cpu_time${i}=\"$rrd\":Timestamp_PerfTime:AVERAGE";
      $cmd .= " DEF:cpu_freq${i}=\"$rrd\":Frequency_PerfTime:AVERAGE";

      $cmd .= " CDEF:cpuutiltot${i}=cpu_perc${i},cpu_time${i},/,cpu_freq${i},*,100000,/,100,/";    # to be in cores

      # find out max cores of the server from first line of cpu.html im comment
      my $max_cpu_cores = 0;
      if ( open( FR, "< $wrkdir/windows/domain_$domain/$server/cpu.html" ) ) {
        my $firstLine = <FR>;                                                                      # example <BR><CENTER><TABLE class="tabconfig tablesorter"><!cores:8>
        close FR;
        ( undef, my $m_cpu_cores ) = split( "cores:", $firstLine );
        if ( defined $m_cpu_cores ) {
          $m_cpu_cores =~ s/>//;
          $max_cpu_cores = $m_cpu_cores;
          chomp $max_cpu_cores;
        }
      }

      #    $cmd .= " CDEF:ncpu${i}=cpuutiltot${i},POP,$max_cpu_cores,1,/"; # trick to save number to CDEF
      $cmd .= " CDEF:ncpu${i}=cpuutiltot${i},UN,0,$max_cpu_cores,IF";    # trick to save number to CDEF

      # if it does not exist for some time period then put 0 there
      $cmd .= " CDEF:cpu${i}=ncpu${i},UN,0,ncpu${i},IF";

      $cmd .= " PRINT:cpuutiltot${i}:AVERAGE:\"%6.1lf $delimiter multihmcframe $delimiter $managedname_space_proc $delimiter $color[$color_indx]\"";
      $cmd .= " PRINT:cpuutiltot${i}:MAX:\" %6.1lf $delimiter $wrkdir_managedname_host_file_legend\"";

      if ( $item eq "hyp_clustsercpu" ) {
        if ( $i == 0 ) {
          $cmd .= " CDEF:totcpu${i}=cpuutiltot${i}";
        }
        else {
          my $ci = $i - 1;
          $cmd .= " CDEF:totcpu${i}=cpuutiltot${i},totcpu${ci},+";
        }
      }
      else {
        $cmdq .= " $gtype:cpuutiltot${i}$color[$color_indx++]:\\\"$managedname_space\\\"";
        $cmdq .= " GPRINT:cpuutiltot${i}:AVERAGE:\\\"%6.1lf \\\"";
        $cmdq .= " GPRINT:cpuutiltot${i}:MAX:\\\"%6.1lf \\l\\\"";
        $gtype = "STACK";
      }
      $i++;
      if ( $color_indx > $color_max ) {
        $color_indx = 0;
      }
    }
  }

  if ( $i > 0 && $item ne "hyp_clustservms" ) {
    if ( $item ne "hyp_clustsermem" ) {

      # add count of all CPU in pools
      for ( $j = 0; $j < $i; $j++ ) {
        if ( $j == 0 ) {
          $cmd .= " CDEF:tcpu${j}=cpu${j}";
        }
        else {
          my $k = $j - 1;
          $cmd .= " CDEF:tcpu${j}=tcpu${k},cpu${j},+";
        }
      }
      if ( $j > 0 ) {
        $j--;
      }
      my $cpu_pool_total = "CPUs total available in pools";
      for ( my $k = length($cpu_pool_total); $k < 35; $k++ ) {
        $cpu_pool_total .= " ";
      }
      $cmd .= " CDEF:tcpun${j}=tcpu${j},0,EQ,UNKN,tcpu${j},IF";
      $cmd .= " LINE2:tcpun${j}#888888:\\\"$cpu_pool_total\\\"";

      # $cmd .= " GPRINT:tcpu${j}:AVERAGE:\\\"%6.2lf \\\"";
      # excluded as it is a bit misleading there there is any even small data gap

      # edit decimals for hyperv CPU
      if ( $item eq "hyp_clustsercpu" || $item eq "hyp_clustser" ) {
        $cmd .= " GPRINT:tcpun${j}:MAX:\\\"         %6.1lf \\l\\\"";
        $cmd .= $cmdq;
        $cmd .= " PRINT:tcpun${j}:MAX:\\\"         %6.1lf MAXTCPU $delimiter\\\"";
      }
      else {
        $cmd .= " GPRINT:tcpun${j}:MAX:\\\"         %6.2lf \\l\\\"";
        $cmd .= $cmdq;
        $cmd .= " PRINT:tcpun${j}:MAX:\\\"         %6.2lf MAXTCPU $delimiter\\\"";
      }
    }
    if ( $item eq "hyp_clustsercpu" ) {

      #  $j = $i - 1;
      $cmd .= " LINE1:totcpu${j}#FF0000:\\\"Utilization                        \\\"";
      $cmd .= " GPRINT:totcpu${j}:AVERAGE:\\\"%6.1lf \\\"";
      $cmd .= " GPRINT:totcpu${j}:MAX:\\\"%6.1lf \\l\\\"";
    }
    elsif ( $item eq "hyp_clustsermem" ) {
      $j = $i - 1;
      $cmd .= " COMMENT:\\\"   [GiB]                 Avrg     Max\\l\\\"";
      $cmd .= " AREA:t_used${j}#FF4040:\\\" Used memory  \\\"";
      $cmd .= " GPRINT:t_used${j}:AVERAGE:\\\"    %6.1lf\\\"";
      $cmd .= " GPRINT:t_used${j}:MAX:\\\" %6.1lf\\l\\\"";
      $cmd .= " $t2";
      $cmd .= " STACK:t_cacheg${j}#0080FF:\\\" Cache        \\\"";
      $cmd .= " GPRINT:t_cacheg${j}:AVERAGE:\\\"    %6.1lf\\\"";
      $cmd .= " GPRINT:t_cacheg${j}:MAX:\\\" %6.1lf\\l\\\"";
      $cmd .= " $t2";
      $cmd .= " STACK:t_freegc${j}#00FF00:\\\" Free memory    \\\"";
      $cmd .= " GPRINT:t_freegc${j}:AVERAGE:\\\"  %6.1lf\\\"";
      $cmd .= " GPRINT:t_freegc${j}:MAX:\\\" %6.1lf\\l\\\"";
    }
  }
  $cmd .= " HRULE:0#000000";

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  # print STDERR "19403 \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_ovirt {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $act_time   = localtime();
  my $act_time_u = time();

  ## command options

  my $ovirt_acl = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $skip_acl  = ($ovirt_acl) ? 0 : 1;

  my $graph_info;

  if ( $item =~ m/^ovirt_(vm|host)_cpu_percent$/ ) {
    $graph_info = OVirtGraph::graph_cpu_percent( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_(vm|host)_cpu_core$/ ) {
    $graph_info = OVirtGraph::graph_cpu_cores( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_(vm|host)_mem$/ ) {
    $graph_info = OVirtGraph::graph_mem( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_host_nic_net$/ ) {
    $graph_info = OVirtGraph::graph_host_net( $server, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_disk_data$/ ) {
    $graph_info = OVirtGraph::graph_disk_data( $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_disk_latency$/ ) {
    $graph_info = OVirtGraph::graph_disk_latency( $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_disk_iops$/ ) {
    $graph_info = OVirtGraph::graph_disk_iops( $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_disk_space$/ ) {
    $graph_info = OVirtGraph::graph_disk_space( $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovirt_storage_domain_space$/ ) {
    $graph_info = OVirtGraph::graph_storage_domain_space( $lpar, $skip_acl );
  }

  my $rrd    = $graph_info->{filename};
  my $header = $detail == 2 ? $graph_info->{reduced_header} : $graph_info->{header};

  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  ## time settings

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph oVirt stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  $time = $detail == 2 ? $text : "last $text";

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= " : $time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  ## graph options

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= $graph_info->{cmd_vlabel};
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $graph_info->{cmd_params};
  $cmd .= $graph_info->{cmd_def};
  $cmd .= $graph_info->{cmd_cdef};
  $cmd .= $graph_info->{cmd_legend};

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_ovirt : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_ovirt_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $req_time   = 0;

  #print STDERR "## $host | $server | $lpar | $item\n";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph oVirt aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $ovirt_acl = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $skip_acl  = ($ovirt_acl) ? 0 : 1;

  my ( $rrd_path, @uuids, $rrd, $time, $label, $header, $rheader );
  my $graph_type;
  $time = $detail == 2 ? "$text" : "last $text";

  if ( $item =~ /^ovirt_storage_domain_aggr_(data|latency|iops)$/ ) {
    $graph_type = $1;
    @uuids      = @{ OVirtDataWrapper::get_arch( $lpar, 'storage_domain', 'disk' ) };
    $label      = OVirtDataWrapper::get_label( 'storage_domain', $lpar );
    $header =
      $graph_type eq 'latency'
      ? "Disk " . ( ucfirst $1 ) . " : $label : "
      : "Disk " . ( ucfirst $1 ) . " aggregated : $label : ";
    $rheader = ( ucfirst $1 ) . " aggr:$label:";
  }
  elsif ( $item =~ /^ovirt_vm_aggr_net$/ ) {
    $graph_type = 'vm_net';
    @uuids      = @{ OVirtDataWrapper::get_arch( $lpar, 'vm', 'nic' ) };
    $label      = OVirtDataWrapper::get_label( 'vm', $lpar );
    $header     = "VM LAN aggregated : $label : ";
    $rheader    = "LAN aggr:$label:";
  }
  elsif ( $item =~ /^ovirt_host_aggr_vm_(cpu_core|mem_used|mem_free)$/ ) {
    my $header_type = $1;

    $graph_type = "vm_$1";
    $header_type =~ s/_/ /g;
    $header_type =~ s/(cpu|mem)/uc($1)/ge;
    @uuids   = @{ OVirtDataWrapper::get_arch( $lpar, 'host', 'vm' ) };
    $label   = OVirtDataWrapper::get_label( 'host', $lpar );
    $header  = "VM $header_type aggregated : $label : ";
    $rheader = "VM $header_type aggr:$label";
  }
  elsif ( $item =~ /^ovirt_host_nic_aggr_net$/ ) {
    $graph_type = 'host_net';
    @uuids      = @{ OVirtDataWrapper::get_arch( $lpar, 'host', 'nic' ) };
    $label      = OVirtDataWrapper::get_label( 'host', $lpar );
    $header     = "Host LAN aggregated : $label : ";
    $rheader    = "LAN aggr:$label";
  }
  elsif ( $item =~ /^ovirt_storage_domains_total_aggr_(data|latency|iops)$/ ) {
    $graph_type = $1;
    @uuids      = @{ OVirtDataWrapper::get_uuids('disk') };
    $header =
      $graph_type eq 'latency'
      ? "Storage domain " . ( ucfirst $1 ) . " : "
      : "Storage domain " . ( ucfirst $1 ) . " aggregated : ";
    $rheader = ( ucfirst $1 ) . " aggr:";
  }
  elsif ( $item =~ /^ovirt_vm_aggr_(data|latency|iops)$/ ) {
    $graph_type = $1;
    @uuids      = @{ OVirtDataWrapper::get_arch( $lpar, 'vm', 'disk' ) };
    $label      = OVirtDataWrapper::get_label( 'vm', $lpar );
    $header =
      $graph_type eq 'latency'
      ? "Disk " . ( ucfirst $1 ) . " : $label : "
      : "Disk " . ( ucfirst $1 ) . " aggregated : $label : ";
    $rheader = ( ucfirst $1 ) . " aggr:$label:";
  }
  elsif ( $item =~ /^ovirt_cluster_aggr_(vm|host)_(cpu_core|cpu_percent|mem_used|mem_free|mem_used_percent)$/ ) {
    my $aggr_type = $1;
    my $metric    = $2;

    $graph_type = "$1_$2";
    @uuids      = @{ OVirtDataWrapper::get_arch( $lpar, 'cluster', $1 ) };

    my $header_type = $graph_type;
    $header_type =~ s/_/ /g;
    $header_type =~ s/(cpu|mem|vm)/uc($1)/ge;
    $metric      =~ s/(cpu|mem)/uc($1)/ge;
    $header_type = ucfirst $header_type;
    $label       = OVirtDataWrapper::get_label( 'cluster', $lpar );

    if ( $graph_type =~ /_percent$/ ) {
      $header  = "$header_type : $label : ";
      $rheader = "$metric:$label:";
    }
    else {
      $header  = "$header_type aggregated : $label : ";
      $rheader = "$metric aggr:$label:";
    }
  }
  else {
    error( "oVirt $item aggregated graph does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  $header = $detail == 2 ? $rheader : $header;

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  my $last_update_time = 0;
  my $itemcount        = 0;
  my $cmd_params       = '';
  my $vertical_label   = '';
  my $cmd_def          = '';
  my $cmd_cdef         = '';
  my $cmd_legend       = '';

  if ( $graph_type =~ /^(data|latency|iops|vm_net|host_net)$/ ) {
    my ( $filepath, $itemlabel, $obj, $color_read, $color_write );
    my $cmd_legend_upper = my $cmd_legend_lower = "";

    if ( $graph_type eq 'data' ) {
      $vertical_label = " --vertical-label=\"Read - Bytes/sec - Write\"";
      $cmd_legend     = " COMMENT:\"[MB/sec]\"";
      $obj            = "Disk";
    }
    elsif ( $graph_type eq 'latency' ) {
      $vertical_label = " --vertical-label=\"Read - millisec - Write\"";
      $cmd_legend     = " COMMENT:\"[millisec]\"";
      $obj            = "Disk";
    }
    elsif ( $graph_type eq 'iops' ) {
      $vertical_label = " --vertical-label=\"Read - IOPS - Write\"";
      $cmd_legend     = " COMMENT:\"[IOPS]\"";
      $obj            = "Disk";
    }
    elsif ( $graph_type =~ /^(vm|host)_net$/ ) {
      $vertical_label = " --vertical-label=\"Read - Bytes/sec - Write\"";
      $cmd_legend     = " COMMENT:\"[MB/sec]\"";
      $obj            = "Int ";
    }

    $cmd_legend .= " COMMENT:\\n";
    $cmd_legend .= " COMMENT:\"$obj                 Read      Avrg       Max    Write      Avrg      Max\\n\"";
    $cmd_def = $cmd_cdef = "";

    foreach my $uuid (@uuids) {
      $color_read  = $color[ $itemcount % $#color ];
      $color_write = $color[ ( $itemcount + 1 ) % $#color ];

      my $graph_entry = OVirtGraph::graph_double_sided_aggr(
        $uuid,       $lpar, $item, $itemcount,
        $color_read, $color_write
      );
      my $filepath = $graph_entry->{filepath};

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $cmd_def          .= $graph_entry->{cmd_def};
      $cmd_cdef         .= $graph_entry->{cmd_cdef};
      $cmd_legend_lower .= $graph_entry->{cmd_legend_lower};
      $cmd_legend_upper .= $graph_entry->{cmd_legend_upper};

      $itemcount += 2;
    }

    $cmd_legend .= $cmd_legend_lower;
    $cmd_legend .= $cmd_legend_upper;
  }
  elsif ( $graph_type =~ /^(vm|host)_(cpu_core|cpu_percent|mem_used|mem_free|mem_used_percent)$/ ) {
    my ( $filepath, $itemlabel, $color );
    my $obj = $1 eq 'vm' ? 'VM  ' : 'Host';

    if ( $graph_type =~ /cpu_core/ ) {
      $cmd_params = " --lower-limit=0.00";
      $cmd_params .= " --units-exponent=1.00";
      $vertical_label = " --vertical-label=\"CPU in cores\"";
      $cmd_legend     = " COMMENT:\"[cores]\"";
    }
    elsif ( $graph_type =~ /cpu_percent/ ) {
      $cmd_params = " --upper-limit=100.0";
      $cmd_params .= " --lower-limit=0.00";
      $vertical_label = " --vertical-label=\"CPU load in [%]\"";
      $cmd_legend     = " COMMENT:\"[%]\"";
    }
    elsif ( $graph_type =~ /mem_used_percent/ ) {
      $cmd_params = " --upper-limit=100.0";
      $cmd_params .= " --lower-limit=0.00";
      $vertical_label = " --vertical-label=\"Memory in [%]\"";
      $cmd_legend     = " COMMENT:\"[%]\"";
    }
    elsif ( $graph_type =~ /mem_free|mem_used/ ) {
      $cmd_params = " --lower-limit=0.00";
      $cmd_params .= " --base=1024";
      $cmd_params .= " --units-exponent=1.00";
      $vertical_label = " --vertical-label=\"Memory in GBytes\"";
      $cmd_legend     = " COMMENT:\"[GB]\"";
    }

    $cmd_legend .= " COMMENT:\\n";
    $cmd_legend .= " COMMENT:\"$obj" . ( ' ' x 27 ) . "Avrg       Max\\n\"";
    $cmd_def = $cmd_cdef = "";

    foreach my $uuid (@uuids) {
      $color = $color[ $itemcount % $#color ];

      my $graph_entry = OVirtGraph::graph_simple_aggr( $uuid, $item, $itemcount, $color, $skip_acl );
      my $filepath    = $graph_entry->{filepath};

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $cmd_def    .= $graph_entry->{cmd_def};
      $cmd_cdef   .= $graph_entry->{cmd_cdef};
      $cmd_legend .= $graph_entry->{cmd_legend};

      $itemcount++;
    }
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;

    #  print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_ovirt_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #  print STDERR "#rrrr " . Dumper($ret) ." \n";
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_oracledb {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $dashboard  = shift;
  my $act_time   = localtime();
  my $act_time_u = time();

  ## command options
  if ( $server eq "nope" ) {
    exit(0);
  }
  my $graph_info;

  my $acl_check;
  if ( defined $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' ) {
    $acl_check = $ENV{HTTP_XORUX_APP};
  }
  else {
    $acl_check = 0;
  }

  #acl_check,

  $graph_info = OracleDBGraph::signpost( $acl_check, $host, $server, $lpar, $item, \@color );
  if ( $graph_info == 0 ) {
    exit(0);
  }

  my $rrd    = $graph_info->{filename};
  my $header = "";
  if ( $dashboard and $dashboard == 1 ) {
    $header = $graph_info->{reduced_header};
  }
  else {
    $header = $detail == 2 ? $graph_info->{reduced_header} : $graph_info->{header};
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  ## time settings

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph OracleDB stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  $time = $detail == 2 ? $text : "last $text";

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= " : $time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  ## graph options

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= $graph_info->{cmd_vlabel};
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $graph_info->{cmd_params};
  $cmd .= $graph_info->{cmd_def};
  $cmd .= $graph_info->{cmd_cdef};
  $cmd .= $graph_info->{cmd_legend};

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_oracledb : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param($ret);    #oracle ret_graph_param
  return 0;
}

sub graph_oracledb_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $dashboard  = shift;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $req_time   = 0;

  #print STDERR "## $host | $server | $lpar | $item\n";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph OracleDB aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $acl_check;
  if ( defined $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' ) {
    $acl_check = $ENV{HTTP_XORUX_APP};
  }
  else {
    $acl_check = 0;
  }

  #acl_check,
  my ( $rrd_path, @uuids, $rrd, $time, $label, $header, $rheader );
  my $graph_type;
  $time = $detail == 2 ? "$text" : "last $text";

  if ( $item =~ m/^oracledb_Wait_class_Main/ ) {
    $graph_type = "ASD";
    @uuids      = @{ OracleDBDataWrapper::get_uuids( $host, $server, $lpar ) };
    $label      = "wait class";
    if ( $item =~ /AvgwtFGms/ ) {
      $header  = "Average Wait FG ms : ";
      $rheader = "$server - Average Wait FG ms : ";    #( ucfirst $1 ) . " aggr:$label:"
    }
    else {
      $header  = "Average Wait ms : ";
      $rheader = "$server - Average Wait ms : ";       #( ucfirst $1 ) . " aggr:$label:"
    }
  }
  elsif ( $item =~ m/^oracledb_Services/ ) {
    $graph_type = "ASD";
    @uuids      = @{ OracleDBDataWrapper::get_uuids( $host, $server, $lpar ) };
    $label      = "Services";
    if ( $item =~ /physW/ ) {
      $header  = "Physical write : ";
      $rheader = "$server - Physical write : ";        #( ucfirst $1 ) . " aggr:$label:"
    }
    else {
      $header  = "Physical read : ";
      $rheader = "$server - Physical read : ";         #( ucfirst $1 ) . " aggr:$label:"
    }
  }
  elsif ( $item =~ m/^oracledb_view|oracledb_Cache/ ) {
    $graph_type = "ASD";
    @uuids      = @{ OracleDBDataWrapper::get_uuids( $host, $server, $lpar ) };
    $label      = $lpar;
    $header     = "$lpar : ";
    $rheader    = "$server - $lpar : ";                                           #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/^oracledb_aggr_Session/ ) {
    $graph_type = "ASD";
    @uuids      = @{ OracleDBDataWrapper::get_uuids( $host, $server, $lpar ) };
    $label      = $lpar;
    $header     = "Session info : ";
    $rheader    = "$server - Session info : ";                                    #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/^oracledb_Disk_latency/ ) {
    $graph_type = "ASD";
    my $hdr = $item;
    $hdr =~ s/oracledb_Disk_latency//g;
    $hdr =~ s/_/ /g;
    @uuids   = @{ OracleDBDataWrapper::get_uuids( $host, $server, $lpar ) };
    $label   = $hdr;
    $header  = "$hdr: ";
    $rheader = "$server -$hdr : ";                                                #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/user_info/ ) {
    $graph_type = "ASD";
    @uuids      = @{ OracleDBDataWrapper::get_uuids( $host, $server, $lpar ) };
    $label      = "User info";
    $header     = "User info : ";
    $rheader    = "$server - User info : ";                                       #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/cursors_info/ ) {
    $graph_type = "ASD";
    @uuids      = @{ OracleDBDataWrapper::get_uuids( $host, $server, $lpar ) };
    $label      = "Cursors info";
    $header     = "Cursors info : ";
    $rheader    = "$server - Cursors info : ";                                    #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/CPU_Usage_Per_Sec/ and $host !~ m/^aggregated/ ) {
    $graph_type = "ASD";
    $label      = "CPU Core Per Sec";
    $header     = "CPU Core Per Sec : ";
    $rheader    = "Total - CPU Core Per Sec : ";                                  #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/DB_Block_Changes_Per_Sec/ and $host !~ m/^aggregated/ ) {
    $graph_type = "ASD";
    $label      = "DB Block Changes Per Sec";
    $header     = "DB Block Changes Per Sec : ";
    $rheader    = "Total - DB Block Changes Per Sec : ";                          #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/Logical_Reads_Per_Sec/ and $host !~ m/^aggregated/ ) {
    $graph_type = "ASD";
    $label      = "Logical Reads Per Sec";
    $header     = "Logical Reads Per Sec : ";
    $rheader    = "Total - Logical Reads Per Sec : ";                             #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/Host_CPU_Utilization/ and $host !~ m/^aggregated/ ) {
    $graph_type = "ASD";
    $label      = "Host CPU Utilization";
    $header     = "Host CPU Utilization : ";
    $rheader    = "Total - Host CPU Utilization : ";                              #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/used/ and $host !~ m/^aggregated/ ) {
    $graph_type = "ASD";
    $label      = "Disk space used";
    $header     = "Disk space used : ";
    $rheader    = "Total - Disk space used : ";                                   #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/free/ and $host !~ m/^aggregated/ ) {
    $graph_type = "ASD";
    $label      = "Disk space free";
    $header     = "Disk space free : ";
    $rheader    = "Total - Disk space free : ";                                   #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $item =~ m/logcap/ and $host !~ m/^aggregated/ ) {
    $graph_type = "ASD";
    $label      = "LOG space used";
    $header     = "LOG space used : ";
    $rheader    = "Total - LOG space used : ";                                    #( ucfirst $1 ) . " aggr:$label:"
  }
  elsif ( $host =~ m/^aggregated/ ) {
    my $page   = OracleDBDataWrapper::basename( $item, '__' );
    my $legend = OracleDBDataWrapper::graph_legend($page);
    $graph_type = "ASD";

    #@uuids      = @{ OracleDBDataWrapper::get_uuids($host, $server, $lpar ) };
    $label   = "Services";
    $header  = defined $legend->{header} ? "$server - $legend->{header}" . " : " : "aggr : ";
    $rheader = defined $legend->{header} ? "$server - $legend->{header}" . " : " : "aggr : ";    #( ucfirst $1 ) . " aggr:$label:"
  }
  else {
    error( "OracleDB $item aggregated graph does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }
  if ( $dashboard and $dashboard == 1 ) {
    $header = $rheader;
  }
  else {
    $header = $detail == 2 ? $rheader : $header;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  my $last_update_time = 0;
  my $itemcount        = 0;
  my $cmd_params       = '';
  my $vertical_label   = '';
  my $cmd_def          = '';
  my $cmd_cdef         = '';
  my $cmd_legend       = '';

  if ( $item =~ m/^oracledb_Wait_class_Main|oracledb_Services/ ) {    #graph_type
    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";                                                 #$1 eq 'vm' ? 'VM  ' : 'Host';

    if ( $item =~ m/^oracledb_Wait_class_Main/ ) {
      $cmd_params = " --lower-limit=0.00";
      $cmd_params .= " --units-exponent=1.00";
      $vertical_label = " --vertical-label=\" Milliseconds \"";
    }
    elsif ( $item =~ m/^oracledb_Services/ ) {
      $cmd_params = " --lower-limit=0.00";
      $cmd_params .= " --units-exponent=1.00";
      $vertical_label = " --vertical-label=\" \"";
    }

    #else{
    #    $cmd_params .= " --upper-limit=100.0";
    #    $cmd_params     = " --lower-limit=0.00";
    #    $cmd_params    .= " --units-exponent=1.00";
    #    $vertical_label = " --vertical-label=\" \"";
    #    $cmd_legend     = " COMMENT:\"[]\"";
    #  }
    #
    $cmd_legend .= " COMMENT:\\n";
    $cmd_legend .= " COMMENT:\"$obj" . ( ' ' x 27 ) . "Avrg       Max\\n\"";
    $cmd_def = $cmd_cdef = "";

    foreach my $uuid (@uuids) {
      $color = $color[ $itemcount % $#color ];

      #warn $uuid;
      my $graph_entry = OracleDBGraph::graph_aggr( $acl_check, $host, $server, $lpar, $item, $uuid, $color, $itemcount );

      my $filepath = $graph_entry->{filepath};

      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      #      # avoid old lpars which do not exist in the period
      #      if ( $rrd_update_time < $req_time ) {
      #        next;
      #      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $cmd_def    .= $graph_entry->{cmd_def};
      $cmd_cdef   .= $graph_entry->{cmd_cdef};
      $cmd_legend .= $graph_entry->{cmd_legend};

      $itemcount++;
    }
  }
  elsif ( $item =~ m/oracledb_Disk_latency/ ) {
    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $vertical_label = " --vertical-label=\" Milliseconds per wait \"";
    $cmd_legend     = " COMMENT:\"[]\"";

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    my $graph_entry;

    if ( $item =~ m/^oracledb_Disk_latency_db_file_read/ ) {
      $graph_entry    = OracleDBGraph::graph_disk_fr( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                          #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_Disk_latency_db_file_write/ ) {
      $graph_entry    = OracleDBGraph::graph_disk_fw( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                          #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_Disk_latency_log_write/ ) {
      $graph_entry    = OracleDBGraph::graph_log_w( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                          #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_Disk_latency_log_sync/ ) {
      $graph_entry    = OracleDBGraph::graph_log_sync( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                           #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};

    }
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #      if ( $rrd_update_time < $req_time ) {
    #      +  next;
    #      }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};
  }
  elsif ( $item =~ m/^oracledb_view|oracledb_aggr_Session/ ) {
    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $vertical_label = " --vertical-label=\" Milliseconds per wait \"";
    $cmd_legend     = " COMMENT:\"[]\"";

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    my $graph_entry;

    if ( $item =~ m/^oracledb_viewone_block_x-way/ ) {
      $graph_entry    = OracleDBGraph::graph_block_xway( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                             #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_viewtwo/ ) {
      $graph_entry    = OracleDBGraph::graph_views( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                             #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_viewthree/ ) {
      $graph_entry    = OracleDBGraph::graph_views( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                             #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_viewfour/ ) {
      $graph_entry    = OracleDBGraph::graph_views( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                             #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_viewfive/ ) {
      $graph_entry    = OracleDBGraph::graph_views( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                             #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_aggr_Session/ ) {
      $graph_entry    = OracleDBGraph::graph_views( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                             #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #      if ( $rrd_update_time < $req_time ) {
    #        next;
    #      }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};
  }
  elsif ( $item =~ m/^oracledb_Cache/ ) {

    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $vertical_label = " --vertical-label=\" Milliseconds per wait \"";
    $cmd_legend     = " COMMENT:\"[]\"";

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    my $graph_entry;

    if ( $item =~ m/^oracledb_Cache_Cache/ ) {
      $graph_entry    = OracleDBGraph::graph_cache( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                        #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_Cache_Blocks_recieved/ ) {
      $graph_entry    = OracleDBGraph::graph_blocksrec( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                            #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_Cache_Avg_Block_receive/ ) {
      $graph_entry    = OracleDBGraph::graph_avgblockrec( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                              #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #      if ( $rrd_update_time < $req_time ) {
    #        next;
    #      }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};
  }
  elsif ( $item =~ m/^oracledb_aggr_SQL_query_user_info|oracledb_aggr_SQL_query_cursors_info/ ) {

    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $vertical_label = " --vertical-label=\" Milliseconds \"";
    $cmd_legend     = " COMMENT:\"[]\"";

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    my $graph_entry;

    if ( $item =~ m/^oracledb_aggr_SQL_query_user_info/ ) {
      $graph_entry    = OracleDBGraph::graph_user_info( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                            #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    elsif ( $item =~ m/^oracledb_aggr_SQL_query_cursors_info/ ) {
      $graph_entry    = OracleDBGraph::graph_cursors_info( $acl_check, $host, $server, $lpar, $item, \@color );
      $vertical_label = $graph_entry->{cmd_vlabel};                                                               #" --vertical-label=\" Milliseconds \"";

      $filepath = $graph_entry->{filepath};
    }
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #      if ( $rrd_update_time < $req_time ) {
    #        next;
    #      }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};
  }
  elsif ( $item =~ m/CPU_Usage_Per_Sec_Total/
    or $item =~ m/DB_Block_Changes_Per_Sec_Total/
    or $item =~ m/Logical_Reads_Per_Sec_Total/
    or $item =~ m/Host_CPU_Utilization_Total/
    or $item =~ m/used_Total/
    or $item =~ m/free_Total/
    or $item =~ m/logcap_Total/ )
  {
    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $vertical_label = " --vertical-label=\" Core \"";
    if ( $item =~ m/CPU_Utilization/ ) {
      $cmd_params = " --upper-limit=100";
    }

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    my $graph_entry;
    $graph_entry    = OracleDBGraph::graph_total_aggr( $acl_check, $host, $server, $lpar, $item, \@color );
    $vertical_label = $graph_entry->{cmd_vlabel};                                                             #" --vertical-label=\" Milliseconds \"";

    $filepath = $graph_entry->{filepath};
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #    if ( $rrd_update_time < $req_time ) {
    #      next;
    #    }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};

  }
  elsif ( $item =~ m/_Htotal/ ) {
    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $cmd_legend = " COMMENT:\"[]\"";

    if ( $item =~ m/CPU_Utilization/ ) {
      $cmd_params = " --upper-limit=100";
    }

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    my $graph_entry;
    $graph_entry = OracleDBGraph::graph_test_total( $acl_check, $host, $server, $lpar, $item, \@color );

    $vertical_label = $graph_entry->{cmd_vlabel};    #" --vertical-label=\" Milliseconds \"";

    $filepath = $graph_entry->{filepath};
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #    if ( $rrd_update_time < $req_time ) {
    #      next;
    #    }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};

  }
  elsif ( $item =~ m/_DBTotal/ ) {
    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $cmd_legend = " COMMENT:\"[]\"";

    if ( $item =~ m/CPU_Utilization/ ) {
      $cmd_params = " --upper-limit=100";
    }

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    my $graph_entry;
    $graph_entry = OracleDBGraph::graph_db_total( $acl_check, $host, $server, $lpar, $item, \@color );

    $vertical_label = $graph_entry->{cmd_vlabel};    #" --vertical-label=\" Milliseconds \"";

    $filepath = $graph_entry->{filepath};
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #    if ( $rrd_update_time < $req_time ) {
    #      next;
    #    }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};

  }
  elsif ( $item =~ m/host_metrics/ ) {
    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $cmd_legend = " COMMENT:\"[]\"";

    my ( $filepath, $itemlabel, $color );
    my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

    my $graph_entry;
    $graph_entry = OracleDBGraph::graph_host_aggr( $acl_check, $host, $server, $lpar, $item, \@color );

    $vertical_label = $graph_entry->{cmd_vlabel};    #" --vertical-label=\" Milliseconds \"";

    $filepath = $graph_entry->{filepath};
    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #    if ( $rrd_update_time < $req_time ) {
    #      next;
    #    }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};

  }
  else {
    $cmd_params = " --lower-limit=0.00";
    $cmd_params .= " --units-exponent=1.00";
    $vertical_label = " --vertical-label=\" Milliseconds \"";
    $cmd_legend     = " COMMENT:\"[]\"";

    #$cmd_legend     = " COMMENT:\"[]\"";

    my ( $filepath, $itemlabel, $color );
    my $obj         = "Host";                                                                                   #$1 eq 'vm' ? 'VM  ' : 'Host';
    my $graph_entry = OracleDBGraph::graph_default_aggr( $acl_check, $host, $server, $lpar, $item, \@color );
    $vertical_label = $graph_entry->{cmd_vlabel};                                                               #" --vertical-label=\" Milliseconds \"";

    $filepath = $graph_entry->{filepath};

    if ( !-f $filepath ) {
      error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
    }

    my $rrd_update_time = ( stat($filepath) )[9];

    # avoid old lpars which do not exist in the period
    #    if ( $rrd_update_time < $req_time ) {
    #      next;
    #    }
    if ( $rrd_update_time > $last_update_time ) {
      $last_update_time = $rrd_update_time;
    }

    $cmd_def    .= $graph_entry->{cmd_def};
    $cmd_cdef   .= $graph_entry->{cmd_cdef};
    $cmd_legend .= $graph_entry->{cmd_legend};
  }

  # }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";

  #  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;

  # a trick for aggredgated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;
    print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_oracledb_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #print STDERR "#rrrr " . Dumper($ret) ." upd.lab:$updated_label \n";
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_dbs_legend {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $dashboard  = shift;
  my $act_time   = localtime();
  my $act_time_u = time();

  my $graph_info;
  my $dunno = $host;

  my $acl_check;
  if ( defined $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' ) {
    $acl_check = $ENV{HTTP_XORUX_APP};
  }
  else {
    $acl_check = 0;
  }

  #$acl_check,

  if ( $item =~ /^sqlserver/ ) {
    $host       = SQLServerDataWrapper::get_alias($server);
    $server     = SQLServerDataWrapper::get_dbname($server);
    $graph_info = SQLServerGraph::signpost( $acl_check, $server, $host, $lpar, $item, \@color, $dunno );
  }
  elsif ( $item =~ /^postgres/ ) {
    $host       = PostgresDataWrapper::get_alias($server);
    $server     = PostgresDataWrapper::get_dbname($server);
    $graph_info = PostgresGraph::signpost( $acl_check, $server, $host, $lpar, $item, \@color, $dunno );
  }
  elsif ( $item =~ /^db2/ ) {
    $host       = Db2DataWrapper::get_alias($server);
    $server     = Db2DataWrapper::get_dbname($server);
    $graph_info = Db2Graph::signpost( $acl_check, $server, $host, $lpar, $item, \@color, $dunno );
  }

  if ( $graph_info == 0 ) {
    exit(0);
  }

  my $rrd    = $graph_info->{filename};
  my $header = "";
  if ( $dashboard and $dashboard == 1 ) {
    $header = $graph_info->{reduced_header};
  }
  else {
    $header = $detail == 2 ? $graph_info->{reduced_header} : $graph_info->{header};
  }
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  ## time settings

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph_dbs_legends stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  $time = $detail == 2 ? $text : "last $text";

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= " : $time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  ## graph options

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= $graph_info->{cmd_vlabel};
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $graph_info->{cmd_params};
  $cmd .= $graph_info->{cmd_def};
  $cmd .= $graph_info->{cmd_cdef};
  $cmd .= $graph_info->{cmd_legend};

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }
  
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_dbs_legend: $item : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_powercmc_totals {

  #graph_powercmc_totals($host, $server, $lpar, $time, $name_out, $type_sam, $detail, $start_unix, $end_unix );
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $dashboard  = shift;

  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $req_time   = 0;

  #warn "graph_powercmc_totals:: host $host server $server lpar $lpar type $type  name_out $name_out  type_sam $type_sam  detail $detail start_unix $start_unix end_unix $end_unix dashboard $dashboard act_time $act_time  act_time_u $act_time_u cmd  $cmd req_time $req_time   = 0;";

  # TIME
  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  # GRAPH TIME TYPE
  # my %type_time_hash = (
  #   "d" => 86400,
  #   "w" => 604800,
  #   "m" => 2764800
  # );

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  #$start_unix = $req_time;
  #$end_unix = $act_time_u;
  #  $req_time = $act_time_u - $type_time_hash{"$type"};

  #-------------------------------
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Power CMC aggregated stats: $type $text $lpar " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  #-------------------------------

  my ( $rrd_path, @uuids, $rrd, $time, $label, $header, $rheader );
  my $graph_type;

  #---------------------------------------------------------------
  $time = $detail == 2 ? "$text" : "last $text";

  $graph_type = "ASD";
  $label      = "wait class";

  # powercmc HERE
  my $_page  = PowercmcDataWrapper::basename( $item, '__' );
  my $legend = ();    # Db2DataWrapper::graph_legend($_page);
  
  #warn "_page: $_page";
  #  my %lpar_header = (
  #    "_cmc_system" => ,
  #    "_cmc_pools_c" => ,
  #    "_cmc_pools" => "
  #
  #  );

  #$legend->{header} = "$lpar";
  $legend = PowercmcGraph::graph_legend($_page);

  # !!! Separate in links/legends...
  if ($_page eq "cmc_system" && $item =~ 'pool'){
    $legend->{header} = "Pool CPU";
  } 
  $header  = "$legend->{header}: ";
  $rheader = "$server - $legend->{header} : ";    #( ucfirst $1 ) . " aggr:$label:"

  if ( $dashboard and $dashboard == 1 ) {
    $header = $rheader;
  }
  else {
    $header = $detail == 2 ? $rheader : $header;
  }

  #---------------------------------------------------------------
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  #---------------------------------------------------------------

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }
  my ( $filepath, $itemlabel, $color );

  my $last_update_time = 0;
  my $itemcount        = 0;

  my $obj = "Host";

  $host   = "PowerCMC";    #Db2DataWrapper::get_alias($server);
  $server = $server;

  #---------------------------------------------------------------
  # ACL CHECK
  #---------------------------------------------------------------

  my $acl_check;
  if ( defined $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' ) {
    $acl_check = $ENV{HTTP_XORUX_APP};
  }
  else {
    $acl_check = 0;
  }

  #---------------------------------------------------------------
  # CMD PART
  #---------------------------------------------------------------
  #---------------------------------------------------------------
  # acl_check 0, server 0254, host PowerCMC, lpar pep2_pool, item powercmc_pep2_pool__cmc_pools
  #warn "PowercmcGraph::signpost ENTRY: ";
  #warn "acl_check $acl_check, server $server, host $host, lpar $lpar, item $item";
  my $acl_capsule = $acl_check;
  my $console_name;
  if ( $server =~ /^(.+)___(.+)$/ ) {
    $console_name = $1;
    $server       = $2;
  }
  $acl_check = $console_name;
  my ( $cmd_custom_part, $graph_entry ) = PowercmcGraph::signpost_new(
    $console_name, $server, $host,
    $lpar,         $item,   \@color, $type
  );
  $acl_check = $acl_capsule;
  my $vertical_label = '';
  $vertical_label = " --vertical-label=\" $graph_entry->{cmd_vlabel} \"";

  #warn "GRAPH ENTRY: ";
  #warn Dumper $graph_entry;
  #----------------------------------------------------------------
  # CMD START
  #---------------------------------------------------------------

  $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";

  #  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";

  #$cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  #warn " NOLEGEND: $no_legend";
  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_custom_part;

  # a trick for aggredgated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  #---------------------------------------------------------------
  # CMD DONE
  #---------------------------------------------------------------
  $filepath = $graph_entry->{filename};

  if ( !-f $filepath ) {
    error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
  }

  my $rrd_update_time = ( stat($filepath) )[9];

  if ( $rrd_update_time > $last_update_time ) {
    $last_update_time = $rrd_update_time;
  }

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  #---------------------------------------------------------------
  #---------------------------------------------------------------
  # cmd ret updated_label
  eval {
    #warn "CMD +++++++++++++++++++++++++++++++++++++++++++++++";
    #$cmd =~ s/\n//g;
    #warn "$cmd";
    #print STDERR "\n $cmd \n";
    #warn $cmd;
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;
    print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_powercmc_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #print STDERR "#rrrr " . Dumper($ret) ." upd.lab:$updated_label \n";
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_db2_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $dashboard  = shift;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $req_time   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph Db2 aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my ( $rrd_path, @uuids, $rrd, $time, $label, $header, $rheader );
  my $graph_type;
  $time = $detail == 2 ? "$text" : "last $text";

  if (1) {
    $graph_type = "ASD";
    $label      = "wait class";
    my $_page  = Db2DataWrapper::basename( $item, '__' );
    my $legend = Db2DataWrapper::graph_legend($_page);
    $header  = "$legend->{header}: ";
    $rheader = "$server - $legend->{header} : ";    #( ucfirst $1 ) . " aggr:$label:"
  }
  else {
    error( "Db2 $item aggregated graph does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }
  if ( $dashboard and $dashboard == 1 ) {
    $header = $rheader;
  }
  else {
    $header = $detail == 2 ? $rheader : $header;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  my $last_update_time = 0;
  my $itemcount        = 0;
  my $cmd_params       = '';
  my $vertical_label   = '';
  my $cmd_def          = '';
  my $cmd_cdef         = '';
  my $cmd_legend       = '';

  $cmd_params = " --lower-limit=0.00";
  $cmd_params .= " --units-exponent=1.00";
  $cmd_legend = " COMMENT:\" \"";

  #$cmd_legend     = " COMMENT:\"[]\"";

  my ( $filepath, $itemlabel, $color );
  my $obj = "Host";

  $host   = Db2DataWrapper::get_alias($server);
  $server = Db2DataWrapper::get_dbname($server);

  my $acl_check;
  if ( defined $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' ) {
    $acl_check = $ENV{HTTP_XORUX_APP};
  }
  else {
    $acl_check = 0;
  }

  my $graph_entry = Db2Graph::signpost( $acl_check, $server, $host, $lpar, $item, \@color );

  $vertical_label = " --vertical-label=\" $graph_entry->{cmd_vlabel} \"";

  #$vertical_label = $graph_entry->{cmd_vlabel};#" --vertical-label=\" Milliseconds \"";

  $filepath = $graph_entry->{filename};

  if ( !-f $filepath ) {
    error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
  }

  my $rrd_update_time = ( stat($filepath) )[9];

  # avoid old lpars which do not exist in the period
  #    if ( $rrd_update_time < $req_time ) {
  #      next;
  #    }
  if ( $rrd_update_time > $last_update_time ) {
    $last_update_time = $rrd_update_time;
  }

  $cmd_def    .= $graph_entry->{cmd_def};
  $cmd_cdef   .= $graph_entry->{cmd_cdef};
  $cmd_legend .= $graph_entry->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";

  #  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;

  # a trick for aggredgated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;
    print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_db2_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #print STDERR "#rrrr " . Dumper($ret) ." upd.lab:$updated_label \n";
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_postgres_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $dashboard  = shift;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $req_time   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph PostgreSQL aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my ( $rrd_path, @uuids, $rrd, $time, $label, $header, $rheader );
  my $graph_type;
  $time = $detail == 2 ? "$text" : "last $text";

  if (1) {
    $graph_type = "ASD";
    $label      = "wait class";
    my $_page  = PostgresDataWrapper::basename( $item, '__' );
    my $legend = PostgresDataWrapper::graph_legend($_page);
    $header  = "$legend->{header}: ";
    $rheader = "$server - $legend->{header} : ";    #( ucfirst $1 ) . " aggr:$label:"
  }
  else {
    error( "PostgreSQL $item aggregated graph does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }
  if ( $dashboard and $dashboard == 1 ) {
    $header = $rheader;
  }
  else {
    $header = $detail == 2 ? $rheader : $header;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  my $last_update_time = 0;
  my $itemcount        = 0;
  my $cmd_params       = '';
  my $vertical_label   = '';
  my $cmd_def          = '';
  my $cmd_cdef         = '';
  my $cmd_legend       = '';

  $cmd_params = " --lower-limit=0.00";
  $cmd_params .= " --units-exponent=1.00";
  $cmd_legend = " COMMENT:\" \"";

  #$cmd_legend     = " COMMENT:\"[]\"";

  my ( $filepath, $itemlabel, $color );
  my $obj = "Host";    #$1 eq 'vm' ? 'VM  ' : 'Host';

  $host   = PostgresDataWrapper::get_alias($server);
  $server = PostgresDataWrapper::get_dbname($server);

  my $acl_check;
  if ( defined $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' ) {
    $acl_check = $ENV{HTTP_XORUX_APP};
  }
  else {
    $acl_check = 0;
  }

  my $graph_entry = PostgresGraph::signpost( $acl_check, $server, $host, $lpar, $item, \@color );

  $vertical_label = " --vertical-label=\" $graph_entry->{cmd_vlabel} \"";

  #$vertical_label = $graph_entry->{cmd_vlabel};#" --vertical-label=\" Milliseconds \"";

  $filepath = $graph_entry->{filename};

  if ( !-f $filepath ) {
    error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
  }

  my $rrd_update_time = ( stat($filepath) )[9];

  # avoid old lpars which do not exist in the period
  #    if ( $rrd_update_time < $req_time ) {
  #      next;
  #    }
  if ( $rrd_update_time > $last_update_time ) {
    $last_update_time = $rrd_update_time;
  }

  $cmd_def    .= $graph_entry->{cmd_def};
  $cmd_cdef   .= $graph_entry->{cmd_cdef};
  $cmd_legend .= $graph_entry->{cmd_legend};

  # }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";

  #  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;

  # a trick for aggredgated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;
    print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_postgres_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #print STDERR "#rrrr " . Dumper($ret) ." upd.lab:$updated_label \n";
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_sqlserver_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $dashboard  = shift;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $req_time   = 0;

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph SQLServer aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my ( $rrd_path, @uuids, $rrd, $time, $label, $header, $rheader );
  my $graph_type;
  $time = $detail == 2 ? "$text" : "last $text";

  if (1) {
    $graph_type = "ASD";
    $label      = "wait class";
    my $_page  = SQLServerDataWrapper::basename( $item, '__' );
    my $legend = SQLServerDataWrapper::graph_legend($_page);
    $header  = "$legend->{header}: ";
    $rheader = "$server - $legend->{header} : ";    #( ucfirst $1 ) . " aggr:$label:"
  }
  else {
    error( "SQLServer $item aggregated graph does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }
  if ( $dashboard and $dashboard == 1 ) {
    $header = $rheader;
  }
  else {
    $header = $detail == 2 ? $rheader : $header;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  my $last_update_time = 0;
  my $itemcount        = 0;
  my $cmd_params       = '';
  my $vertical_label   = '';
  my $cmd_def          = '';
  my $cmd_cdef         = '';
  my $cmd_legend       = '';

  $cmd_params = " --lower-limit=0.00";
  if ( $lpar ne "Buffers" ) {
    $cmd_params .= " --units-exponent=0";
  }
  $cmd_legend = " COMMENT:\" \"";

  #$cmd_legend     = " COMMENT:\"[]\"";

  my ( $filepath, $itemlabel, $color );
  my $obj = "Host";

  $host   = SQLServerDataWrapper::get_alias($server);
  $server = SQLServerDataWrapper::get_dbname($server);

  my $acl_check;
  if ( defined $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' ) {
    $acl_check = $ENV{HTTP_XORUX_APP};
  }
  else {
    $acl_check = 0;
  }

  my $graph_entry = SQLServerGraph::signpost( $acl_check, $server, $host, $lpar, $item, \@color );

  $vertical_label = " --vertical-label=\" $graph_entry->{cmd_vlabel} \"";

  #$vertical_label = $graph_entry->{cmd_vlabel};#" --vertical-label=\" Milliseconds \"";

  $filepath = $graph_entry->{filename};

  if ( !-f $filepath ) {
    error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
  }

  my $rrd_update_time = ( stat($filepath) )[9];

  # avoid old lpars which do not exist in the period
  #    if ( $rrd_update_time < $req_time ) {
  #      next;
  #    }
  if ( $rrd_update_time > $last_update_time ) {
    $last_update_time = $rrd_update_time;
  }

  $cmd_def    .= $graph_entry->{cmd_def};
  $cmd_cdef   .= $graph_entry->{cmd_cdef};
  $cmd_legend .= $graph_entry->{cmd_legend};

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";

  #  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;

  # a trick for aggredgated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;
    print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_sqlserver_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #print STDERR "#rrrr " . Dumper($ret) ." upd.lab:$updated_label \n";
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_cpuqueue {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $item       = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $t          = "COMMENT:\" \"";
  my $t2         = "COMMENT:\"\\n\"";
  my $step_new   = $step;
  my $last       = "COMMENT: ";
  my $head       = "COMMENT:                            Average   Max\\n";

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST: %4.0lf";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_cpu_queue $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  if ( $lpar eq '' ) {
    return 0;                    # some workaround, it should not go here
  }

  my $rrd  = "$wrkdir/$server/$host/$lpar/queue_cpu.mmm";
  my $os_s = "";

  if ( $hyperv && ( $item eq "cpuqueue" || $item eq "cpu_process" ) ) {
    $rrd = "$wrkdir/$server/$host/CPUqueue.rrm";
  }

  if ( !-e $rrd ) {
    $rrd  = "$wrkdir/$server/$host/$lpar/queue_cpu_aix.mmm";
    $os_s = "AIX";
  }

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  my $nmon_detected   = 1 if index( $lpar_slash, "NMON" ) ne -1;
  $lpar_slash_nmon =~ s/$NMON//;
  my $lpar_slash_nmon_head = $lpar_slash_nmon;
  $lpar_slash_nmon_head = "$host" if $hyperv;

  my $last_txt      = " last ";
  my $header_prefix = "cpu queue:";
  $header_prefix = "process:" if $hyperv && $item eq "cpu_process";

  if ( $detail == 2 ) {
    $last_txt             = "";
    $header_prefix        = "CPU QUEUE";
    $lpar_slash_nmon_head = ""          if $server eq "Linux";
    $header_prefix        = "CPU QUEUE" if ( $wpar == 1 );
    $lpar_slash_nmon_head = ""          if $hyperv;
    $header_prefix        = "process"   if $hyperv && $item eq "cpu_process";
  }

  my $header = "$header_prefix $lpar_slash_nmon_head :$last_txt$text";

  # due to historical reports where is specific time passed
  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }

      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon_head : $start_human - $end_human";
    }
  }

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }

  if ( $type =~ "d" ) {

    # my $rrd_last = rrd_file_actual ("$rrd"); # no it is hard-linked through all HMCs
    my $rrd_last = $rrd;
    RRDp::cmd qq(last "$rrd_last");
    my $last_tt = RRDp::read;
    my $l       = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";

    # get LAST value from RRD
    my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
    RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
    my $row = RRDp::read;
    chomp($$row);
    my @row_arr = split( /\n/, $$row );
    my $m       = "";
    my $i       = 0;

    foreach $m (@row_arr) {
      chomp($m);
      $i++;
      if ( $i == 3 ) {
        my @m_arr = split( / /, $m );

        # go further only if it is a digit (avoid it when NaNQ (== no data) is there)
        if ( $m_arr[1] =~ /\d/ && $m_arr[2] =~ /\d/ ) {

          #print "m : $m\n" if $DEBUG ;
          #print "\n$m_arr[1] $m_arr[2]" if $DEBUG ;

          $last = "";

          #if ( $m_arr[2] > 0 ) {
          #  my $last_mem = sprintf( "%6.2d",$m_arr[2]) / 1024;
          #  my $last_mem_g = sprintf( "%.2f",$m_arr[2] / 1024);
          #  $last ="COMMENT:Last memory consumption in GB         $last_mem_g";
          #}
        }
      }
    }
  }

  #if ( $type =~ "y" ) {
  #  $step_new=86400;
  #}

  if ( !-f "$rrd" ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $vertical_label = "--vertical-label=";
  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
  }

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start \"$start_time\"";
  $cmd .= " --end \"$end_time\"";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " $no_minor";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step_new";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --upper-limit=0.1";
  $cmd .= " $vertical_label";
  $cmd .= " --units-exponent=1.00";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";
  $cmd .= " --base=1024";

  chomp($rrd);
  $rrd =~ s/:/\\:/g;

  if ( $os_s eq "AIX" ) {

    $cmd .= " DEF:loadcpu=\"$rrd\":load:AVERAGE";
    $cmd .= " DEF:virtualp=\"$rrd\":virtual_p:AVERAGE";
    $cmd .= " DEF:blockedp=\"$rrd\":blocked_p:AVERAGE";
    $cmd .= " DEF:blockedraw=\"$rrd\":blocked_raw:AVERAGE";
    $cmd .= " DEF:blockedIO=\"$rrd\":blocked_IO:AVERAGE";

    $cmd .= " COMMENT:\"                         Avrg      Max\\n\"";
    if ($nmon_detected) {
      $cmd .= " LINE1:loadcpu#FF0000:\" Run queue          \"";
    }
    else {
      $cmd .= " LINE1:loadcpu#FF0000:\" Load Avrg          \"";
    }
    $cmd .= " GPRINT:loadcpu:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:loadcpu:MAX:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:virtualp#000000:\" Logical Processors \"";
    $cmd .= " GPRINT:virtualp:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:virtualp:MAX:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:blockedp#0080FF:\" Blocked Processes  \"";
    $cmd .= " GPRINT:blockedp:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:blockedp:MAX:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:blockedraw#00A703:\" Blocked raw        \"";
    $cmd .= " GPRINT:blockedraw:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:blockedraw:MAX:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:blockedIO#785526:\" Blocked direct IO  \"";
    $cmd .= " GPRINT:blockedIO:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:blockedIO:MAX:\" %6.1lf\"";

    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";

  }
  elsif ( $hyperv && $item eq "cpuqueue" ) {

    $cmd .= " DEF:cpuqueue=\"$rrd\":CPU_queue:AVERAGE";

    $cmd .= " COMMENT:\"                           Avrg      Max\\n\"";
    $cmd .= " LINE1:cpuqueue#FF0000:\" CPU queue         \"";
    $cmd .= " GPRINT:cpuqueue:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:cpuqueue:MAX:\" %6.0lf\"";

    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";

  }
  elsif ( $hyperv && $item eq "cpu_process" ) {
    $cmd .= " DEF:cpuprocesses=\"$rrd\":CPU_processes:AVERAGE";
    $cmd .= " DEF:cputhreads=\"$rrd\":CPU_threads:AVERAGE";

    $cmd .= " COMMENT:\"                           Avrg      Max\\n\"";
    $cmd .= " LINE1:cpuprocesses#FF7777:\" Processes         \"";
    $cmd .= " GPRINT:cpuprocesses:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:cpuprocesses:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:cputhreads#0080FF:\" Threads           \"";
    $cmd .= " GPRINT:cputhreads:AVERAGE:\" %6.0lf\"";
    $cmd .= " GPRINT:cputhreads:MAX:\" %6.0lf\"";

    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";
  }
  else {

    $cmd .= " DEF:loadcpu=\"$rrd\":load:AVERAGE";
    $cmd .= " DEF:virtualp=\"$rrd\":virtual_p:AVERAGE";
    $cmd .= " DEF:blockedp=\"$rrd\":blocked_p:AVERAGE";

    # print STDERR "38241 \$server $server \$nmon_detected $nmon_detected\n";
    $cmd .= " COMMENT:\"                             Avrg      Max\\n\"";
    if ( lc($server) =~ "linux" && $nmon_detected ) {
      $cmd .= " LINE1:loadcpu#FF0000:\" Run queue            \"";
    }
    else {
      $cmd .= " LINE1:loadcpu#FF0000:\" Load Avrg            \"";
    }
    $cmd .= " GPRINT:loadcpu:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:loadcpu:MAX:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:virtualp#000000:\" Logical Processors   \"";
    $cmd .= " GPRINT:virtualp:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:virtualp:MAX:\" %6.1lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:blockedp#0080FF:\" Blocked Processes    \"";
    $cmd .= " GPRINT:blockedp:AVERAGE:\" %6.1lf\"";
    $cmd .= " GPRINT:blockedp:MAX:\" %6.1lf\"";

    $cmd .= " $t2";
    $cmd .= " $t";
    $cmd .= " HRULE:0#000000";
  }

  $cmd =~ s/\\"/"/g;

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_cpuqueue : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_oraclevm {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $req_time   = 0;

  my $oraclevm_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $oraclevm_metadata = OracleVmDataWrapperOOP->new( { acl_check => $oraclevm_acl } );
  my $skip_acl          = ($oraclevm_acl) ? 0 : 1;

  ## command options
  my $graph_info;
  if ( $item =~ m/^ovm_(vm|server)_cpu_core$/ ) {
    $graph_info = OracleVmGraph::graph_cpu_cores( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovm_(vm|server)_cpu_percent$/ ) {
    $graph_info = OracleVmGraph::graph_cpu_percent( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovm_(vm)_mem$/ ) {
    $graph_info = OracleVmGraph::graph_mem_vm( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovm_(server)_mem_server$/ ) {
    $graph_info = OracleVmGraph::graph_mem_server( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovm_(vm|server)_mem_percent$/ ) {
    $graph_info = OracleVmGraph::graph_mem_percent( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovm_(vm)_net_used$/ ) {
    $graph_info = OracleVmGraph::graph_vm_net( $1, $lpar, $skip_acl );
  }
  elsif ( $item =~ m/^ovm_(vm|server)_disk_used$/ ) {
    $graph_info = OracleVmGraph::graph_disk( $1, $lpar, $skip_acl );
  }

  my $rrd    = $graph_info->{filename};
  my $header = $detail == 2 ? $graph_info->{reduced_header} : $graph_info->{header};

  #print STDERR Dumper($graph_info) . "\n";
  if ( !-f $rrd ) {
    error( "$rrd does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  #my $last_update_time = 0;
  #my $rrd_update_time = ( stat( $rrd ) )[9];
  # avoid old lpars which do not exist in the period
  #if ( $rrd_update_time < $req_time ) {
  #  next;
  #}
  #if ( $rrd_update_time > $last_update_time ) {
  #  $last_update_time = $rrd_update_time;
  #}

  ## time settings

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph OracleVM stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  $time = $detail == 2 ? $text : "last $text";

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  $header .= " : $time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  ## graph options

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= $graph_info->{cmd_vlabel};
  }
  $cmd .= " HRULE:0#000000";
  $cmd .= $graph_info->{cmd_params};
  $cmd .= $graph_info->{cmd_def};
  $cmd .= $graph_info->{cmd_cdef};
  $cmd .= $graph_info->{cmd_legend};

  if ( $type =~ "d" ) {
    RRDp::cmd qq(last "$rrd");
    my $last_tt     = RRDp::read;
    my $last_update = localtime( time_from_last_tt($last_tt) );

    # following must be for RRD 1.2+
    $last_update =~ s/:/\\:/g;
    $cmd .= " COMMENT:\"Updated\\\: $last_update\"";
  }

  eval {
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;

    #  print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_oraclevm : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #print STDERR "#rrrr " . Dumper($ret) ." \n";
  $png_end_heading = ret_graph_param($ret);
  return 0;

}

sub graph_oraclevm_totals {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $act_time   = localtime();
  my $act_time_u = time();
  my $cmd        = "";
  my $req_time   = 0;

  print STDERR "#graph_oraclevm_totals# $host | $server | $lpar | $item\n";

  $start_unix = "" if !defined $start_unix;
  $end_unix   = "" if !defined $end_unix;

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  if ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  if ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);
  if ( $text eq '' || $lpar eq '' ) {
    error( "Graph rrdtool error : graph OracleVM_totals aggregated stats: ,$type, ,$text, ,$lpar, " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  my $oraclevm_acl      = ( $ENV{HTTP_XORUX_APP} && $ENV{HTTP_XORUX_APP} eq 'Xormon' );
  my $oraclevm_metadata = OracleVmDataWrapperOOP->new( { acl_check => $oraclevm_acl } );
  my $skip_acl          = ($oraclevm_acl) ? 0 : 1;

  my ( $rrd_path, @uuids, $rrd, $time, $label, $header, $rheader );
  my $graph_type;
  $time = $detail == 2 ? "$text" : "last $text";

  if ( $item =~ /^ovm_server_aggr_net$/ ) {
    $graph_type = 'ovm_server_aggr_net';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    opendir( DIR, "$oraclevm_dir/server/$lpar" );
    @uuids = grep /^lan-/, readdir(DIR);
    closedir(DIR);
    $label = $oraclevm_metadata->get_label( 'server', $lpar );

    #print STDERR "#graph_oraclevm_totals1# $graph_type,==@uuids==, $label, $graph_type\n";
    $header  = "Server LAN aggregated : $label : ";
    $rheader = "LAN aggr:$label:";
  }
  elsif ( $item =~ /^ovm_server_aggr_disk_used$/ ) {
    $graph_type = 'ovm_server_aggr_disk_used';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    opendir( DIR1, "$oraclevm_dir/server/$lpar" );
    @uuids = grep /^disk-/, readdir(DIR1);
    closedir(DIR1);
    $label = $oraclevm_metadata->get_label( 'server', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "Server disk aggregated : $label : ";
    $rheader = "Disk aggr:$label:";
  }
  elsif ( $item =~ /^ovm_vm_aggr_net$/ ) {
    $graph_type = 'ovm_vm_aggr_net';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    opendir( DIR2, "$oraclevm_dir/vm/$lpar" );
    @uuids = grep /^lan-/, readdir(DIR2);
    closedir(DIR2);
    $label = $oraclevm_metadata->get_label( 'vm', $lpar );

    #print STDERR "#graph_oraclevm_totals3# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "VM LAN aggregated : $label : ";
    $rheader = "Lan aggr:$label:";
  }
  elsif ( $item =~ /^ovm_vm_aggr_disk_used$/ ) {
    $graph_type = 'ovm_vm_aggr_disk_used';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    opendir( DIR3, "$oraclevm_dir/vm/$lpar" );
    @uuids = grep /^disk-/, readdir(DIR3);
    closedir(DIR3);
    $label = $oraclevm_metadata->get_label( 'vm', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "VM disk aggregated : $label : ";
    $rheader = "Disk aggr:$label:";
  }
  elsif ( $item =~ /^ovm_server_total_cpu$/ ) {
    $graph_type = 'ovm_server_total_cpu';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'server_pool', 'server' ) } ) {
      if ( -f "$oraclevm_dir/server/$server_uuid/sys.rrd" ) {

        #print STDERR"line22925- exist $oraclevm_dir/server/$server_uuid/sys.rrd\n";
        push @uuids, $server_uuid;
      }
    }
    $label = $oraclevm_metadata->get_label( 'server_pool', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "CPU server aggregated : $label : ";
    $rheader = "Server aggr:$label:";
  }
  elsif ( $item =~ /^ovm_server_total_mem$/ ) {
    $graph_type = 'ovm_server_total_mem';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'server_pool', 'server' ) } ) {
      if ( -f "$oraclevm_dir/server/$server_uuid/sys.rrd" ) {

        #print STDERR"line22925- exist $oraclevm_dir/server/$server_uuid/sys.rrd\n";
        push @uuids, $server_uuid;
      }
    }
    $label = $oraclevm_metadata->get_label( 'server_pool', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "MEM server aggregated : $label : ";
    $rheader = "Server aggr:$label:";

  }
  elsif ( $item =~ /^ovm_server_total_net$/ ) {
    $graph_type = 'ovm_server_total_net';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'server_pool', 'server' ) } ) {
      opendir( DIR3, "$oraclevm_dir/server/$server_uuid" );
      my @uuids_lan = grep /^lan-/, readdir(DIR3);
      closedir(DIR3);
      foreach my $uuid (@uuids_lan) {
        my $server_uuid_with_net = "$uuid/$server_uuid";
        push @uuids, $server_uuid_with_net;
      }
    }
    $label = $oraclevm_metadata->get_label( 'server_pool', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "NET server aggregated : $label : ";
    $rheader = "Server aggr:$label:";
  }
  elsif ( $item =~ /^ovm_serverpools_total_net$/ ) {
    $graph_type = 'ovm_serverpools_total_net';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'manager', 'server' ) } ) {
      opendir( DIR3, "$oraclevm_dir/server/$server_uuid" );
      my @uuids_lan = grep /^lan-/, readdir(DIR3);
      closedir(DIR3);
      foreach my $uuid (@uuids_lan) {
        my $server_uuid_with_net = "$uuid/$server_uuid";
        push @uuids, $server_uuid_with_net;
      }
    }
    $label = $oraclevm_metadata->get_label( 'manager', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "NET serverpool aggregated : $label : ";
    $rheader = "Server aggr:$label:";
  }
  elsif ( $item =~ /^ovm_serverpools_total_cpu$/ ) {
    $graph_type = 'ovm_serverpools_total_cpu';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'manager', 'server' ) } ) {
      if ( -f "$oraclevm_dir/server/$server_uuid/sys.rrd" ) {

        #print STDERR"line22925- exist $oraclevm_dir/server/$server_uuid/sys.rrd\n";
        push @uuids, $server_uuid;
      }

      #@uuids = $server_uuid;
    }
    $label = $oraclevm_metadata->get_label( 'manager', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "CPU server_pool aggregated : $label : ";
    $rheader = "Server pool aggr:$label:";
  }
  elsif ( $item =~ /^ovm_serverpools_total_mem$/ ) {
    $graph_type = 'ovm_serverpools_total_mem';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'manager', 'server' ) } ) {
      if ( -f "$oraclevm_dir/server/$server_uuid/sys.rrd" ) {

        #print STDERR"line22925- exist $oraclevm_dir/server/$server_uuid/sys.rrd\n";
        push @uuids, $server_uuid;
      }

      #@uuids = $server_uuid;
    }
    $label = $oraclevm_metadata->get_label( 'manager', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "MEM server_pool aggregated : $label : ";
    $rheader = "Server pool aggr:$label:";
  }
  elsif ( $item =~ /^ovm_vm_aggr_cpu_serverpool$/ ) {
    $graph_type = 'ovm_vm_aggr_cpu_serverpool';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $vm_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'manager', 'vm' ) } ) {
      if ( -f "$oraclevm_dir/vm/$vm_uuid/sys.rrd" ) {

        #print STDERR"line23025- exist $oraclevm_dir/vm/$vm_uuid/sys.rrd\n";
        push @uuids, $vm_uuid;
      }

      #@uuids = $server_uuid;
    }
    $label = $oraclevm_metadata->get_label( 'manager', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "VMs CPU aggregated : $label : ";
    $rheader = "Server pool VM aggr:$label:";
  }
  elsif ( $item =~ /^ovm_vm_aggr_cpu_server$/ ) {
    $graph_type = 'ovm_vm_aggr_cpu_server';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $vm_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'server_pool', 'vm' ) } ) {
      if ( -f "$oraclevm_dir/vm/$vm_uuid/sys.rrd" ) {

        #print STDERR"line23025- exist $oraclevm_dir/vm/$vm_uuid/sys.rrd\n";
        push @uuids, $vm_uuid;
      }

      #@uuids = $server_uuid;
    }
    $label = $oraclevm_metadata->get_label( 'server_pool', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "VMs CPU aggregated : $label : ";
    $rheader = "Server VM aggr:$label:";
  }
  elsif ( $item =~ /^ovm_server_total_disk$/ ) {
    $graph_type = 'ovm_server_total_disk';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'server_pool', 'server' ) } ) {
      opendir( DIR3, "$oraclevm_dir/server/$server_uuid" );
      my @uuids_lan = grep /^disk-/, readdir(DIR3);
      closedir(DIR3);
      foreach my $uuid (@uuids_lan) {
        my $server_uuid_with_net = "$uuid/$server_uuid";
        push @uuids, $server_uuid_with_net;
      }
    }
    $label = $oraclevm_metadata->get_label( 'server_pool', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "DISK server aggregated : $label : ";
    $rheader = "Server aggr:$label:";
  }
  elsif ( $item =~ /^ovm_serverpools_total_disk$/ ) {
    $graph_type = 'ovm_serverpools_total_disk';
    my $oraclevm_dir = "$basedir/data/OracleVM";
    foreach my $server_uuid ( @{ $oraclevm_metadata->get_arch( $lpar, 'manager', 'server' ) } ) {
      opendir( DIR3, "$oraclevm_dir/server/$server_uuid" );
      my @uuids_lan = grep /^disk-/, readdir(DIR3);
      closedir(DIR3);
      foreach my $uuid (@uuids_lan) {
        my $server_uuid_with_net = "$uuid/$server_uuid";
        push @uuids, $server_uuid_with_net;
      }
    }
    $label = $oraclevm_metadata->get_label( 'manager', $lpar );

    #print STDERR "#graph_oraclevm_totals2# $graph_type, ==@uuids==, $label, $graph_type!!\n";
    $header  = "DISK serverpools aggregated : $label : ";
    $rheader = "Server aggr:$label:";
  }
  else {
    error( "OracleVM $item aggregated graph does not exist " . __FILE__ . ":" . __LINE__ );
    return 0;
  }

  $header = $detail == 2 ? $rheader : $header;

  my $start_time = "now-1$type";
  my $end_time   = "now-1$type+1$type";
  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $end_time   = $end_unix;
    if ( $detail != 10 ) {
      $xgrid = "";    # just a trick
    }

    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
    $time = "$start_human - $end_human";
  }

  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  $header .= "$time";
  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    if ( $width < 700
      && $detail != 10
      && defined $start_unix
      && defined $end_unix
      && isdigit($start_unix) > 0
      && isdigit($end_unix) > 0 )
    {
      $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) );
    }
  }

  my $last_update_time = 0;
  my $itemcount        = 0;
  my $cmd_params       = '';
  my $vertical_label   = '';
  my $cmd_def          = '';
  my $cmd_cdef         = '';
  my $cmd_legend       = '';

  #print STDERR"before graph_type-$graph_type!!!\n";
  if ( $graph_type =~ /^ovm_server_aggr_net$/ ) {
    my ( $filepath, $itemlabel, $obj, $color_read, $color_write );
    my $cmd_legend_upper = my $cmd_legend_lower = "";

    $vertical_label = " --vertical-label=\"Read - Bytes/sec - Write\"";
    $cmd_legend     = " COMMENT:\"[MB/sec]\"";
    $obj            = "Net name";

    $cmd_legend .= " COMMENT:\\n";
    $cmd_legend .= " COMMENT:\"$obj               Read      Avrg       Max    Write      Avrg      Max\\n\"";
    $cmd_def = $cmd_cdef = "";

    foreach my $uuid (@uuids) {
      $color_read  = $color[ $itemcount % $#color ];
      $color_write = $color[ ( $itemcount + 1 ) % $#color ];

      my $graph_entry = OracleVmGraph::graph_double_sided_aggr(
        $uuid,       $lpar,        $item, $itemcount,
        $color_read, $color_write, $skip_acl
      );
      my $filepath = $graph_entry->{filepath};

      #print STDERR Dumper($graph_entry) . "\n";
      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $cmd_def          .= $graph_entry->{cmd_def};
      $cmd_cdef         .= $graph_entry->{cmd_cdef};
      $cmd_legend_lower .= $graph_entry->{cmd_legend_lower};
      $cmd_legend_upper .= $graph_entry->{cmd_legend_upper};

      $itemcount += 2;
    }

    $cmd_legend .= $cmd_legend_lower;
    $cmd_legend .= $cmd_legend_upper;

  }
  elsif ( $item =~ /^ovm_server_aggr_disk_used|^ovm_vm_aggr_disk_used$/ ) {
    my ( $filepath, $itemlabel, $obj, $color_read, $color_write );
    my $cmd_legend_upper = my $cmd_legend_lower = "";

    $vertical_label = " --vertical-label=\"Read - Bytes/sec - Write\"";
    $cmd_legend     = " COMMENT:\"[MB/sec]\"";
    $obj            = "Disk name";

    $cmd_legend .= " COMMENT:\\n";
    $cmd_legend .= " COMMENT:\"$obj                                                                  Read      Avrg       Max    Write      Avrg      Max\\n\"";
    $cmd_def = $cmd_cdef = "";

    foreach my $uuid (@uuids) {
      $color_read  = $color[ $itemcount % $#color ];
      $color_write = $color[ ( $itemcount + 1 ) % $#color ];

      my $graph_entry = OracleVmGraph::graph_double_sided_aggr(
        $uuid,       $lpar,        $item, $itemcount,
        $color_read, $color_write, $skip_acl
      );
      my $filepath = $graph_entry->{filepath};

      #print STDERR Dumper($graph_entry) . "\n";
      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }

      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $cmd_def          .= $graph_entry->{cmd_def};
      $cmd_cdef         .= $graph_entry->{cmd_cdef};
      $cmd_legend_lower .= $graph_entry->{cmd_legend_lower};
      $cmd_legend_upper .= $graph_entry->{cmd_legend_upper};

      $itemcount += 2;
    }

    $cmd_legend .= $cmd_legend_lower;
    $cmd_legend .= $cmd_legend_upper;
  }
  if ( $graph_type =~ /^ovm_vm_aggr_net$/ ) {
    my ( $filepath, $itemlabel, $obj, $color_read, $color_write );
    my $cmd_legend_upper = my $cmd_legend_lower = "";

    $vertical_label = " --vertical-label=\"Read - Bytes/sec - Write\"";
    $cmd_legend     = " COMMENT:\"[MB/sec]\"";
    $obj            = "IP net";

    $cmd_legend .= " COMMENT:\\n";
    $cmd_legend .= " COMMENT:\"$obj                 Read      Avrg       Max    Write      Avrg      Max\\n\"";
    $cmd_def = $cmd_cdef = "";

    foreach my $uuid (@uuids) {
      $color_read  = $color[ $itemcount % $#color ];
      $color_write = $color[ ( $itemcount + 1 ) % $#color ];

      #$uuid =~ s/===double-col===/:/g;
      my $graph_entry = OracleVmGraph::graph_double_sided_aggr(
        $uuid,       $lpar,        $item, $itemcount,
        $color_read, $color_write, $skip_acl
      );
      my $filepath = $graph_entry->{filepath};

      #print STDERR "$uuid, $lpar, $item, $itemcount, $color_read, $color_write, $filepath\n";
      #print STDERR Dumper($graph_entry) . "\n";
      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $filepath =~ s/:/\\:/g;
      $cmd_def          .= $graph_entry->{cmd_def};
      $cmd_cdef         .= $graph_entry->{cmd_cdef};
      $cmd_legend_lower .= $graph_entry->{cmd_legend_lower};
      $cmd_legend_upper .= $graph_entry->{cmd_legend_upper};

      $itemcount += 2;
    }

    $cmd_legend .= $cmd_legend_lower;
    $cmd_legend .= $cmd_legend_upper;

  }
  elsif ( $graph_type =~ /^ovm_server_total_cpu$|^ovm_server_total_mem$|^ovm_server_total_net$|^ovm_serverpools_total_cpu$|^ovm_serverpools_total_mem$|^ovm_serverpools_total_net$|^ovm_server_total_disk$|^ovm_serverpools_total_disk$/ ) {
    my ( $filepath, $itemlabel, $obj, $color_read, $color_write );
    my $cmd_legend_upper = my $cmd_legend_lower = "";

    if ( $graph_type =~ /^ovm_server_total_cpu|^ovm_serverpools_total_cpu$/ ) {
      $vertical_label = " --vertical-label=\"CPU in cores\"";
      $obj            = "Int ";
      $cmd_params     = " --lower-limit=0.00";
      $cmd_params .= " --units-exponent=1.00";
      $cmd_legend .= " COMMENT:\\n";
      $cmd_legend .= " COMMENT:\"$obj                                        Avrg      Max  \\n\"";
    }
    elsif ( $graph_type =~ /^ovm_server_total_mem$|^ovm_serverpools_total_mem$/ ) {
      $cmd_params = " --lower-limit=0.00";
      $cmd_params .= " --base=1024";
      $cmd_params .= " --units-exponent=1.00";
      $vertical_label = " --vertical-label=\"Memory in GBytes\"";
      $cmd_legend     = " COMMENT:\"[GB]\"";
      $obj            = "Int ";
      $cmd_legend .= " COMMENT:\\n";
      $cmd_legend .= " COMMENT:\"$obj                                        Avrg      Max  \\n\"";
    }
    elsif ( $graph_type =~ /^ovm_server_total_net$|^ovm_serverpools_total_net$|^ovm_server_total_disk$|^ovm_serverpools_total_disk$/ ) {
      $vertical_label = " --vertical-label=\"Read - Bytes/sec - Write\"";
      $cmd_legend     = " COMMENT:\"[MB/sec]\"";
      if ( $graph_type =~ /net/ ) {
        $obj = "Net name";
        $cmd_legend .= " COMMENT:\\n";
        $cmd_legend .= " COMMENT:\"$obj           Server                      Read      Avrg       Max    Write      Avrg      Max\\n\"";
      }
      else {
        $obj = "Disk name";
        $cmd_legend .= " COMMENT:\\n";
        $cmd_legend .= " COMMENT:\"$obj                               Server                             Read      Avrg       Max    Write      Avrg      Max\\n\"";
      }
    }

    $cmd_def = $cmd_cdef = "";
    foreach my $uuid (@uuids) {
      $color_read  = $color[ $itemcount % $#color ];
      $color_write = $color[ ( $itemcount + 1 ) % $#color ];

      #$uuid =~ s/===double-col===/:/g;
      my $graph_entry;
      if ( $graph_type !~ /^ovm_server_total_net$|^ovm_serverpools_total_net$|^ovm_server_total_disk$|^ovm_serverpools_total_disk$/ ) {
        $graph_entry = OracleVmGraph::graph_double_sided_aggr( $uuid, $lpar, $item, $itemcount, $color_read, $color_write );
      }
      else {
        my ( $net_name, $uuid_s ) = split /\//, $uuid;
        $graph_entry = OracleVmGraph::graph_double_sided_aggr( $net_name, $uuid_s, $item, $itemcount, $color_read, $color_write );
      }
      my $filepath = $graph_entry->{filepath};

      #print STDERR "$uuid, $lpar, $item, $itemcount, $color_read, $color_write, $filepath\n";
      #print STDERR Dumper($graph_entry) . "\n";
      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $filepath =~ s/:/\\:/g;
      $cmd_def          .= $graph_entry->{cmd_def};
      $cmd_cdef         .= $graph_entry->{cmd_cdef};
      $cmd_legend_lower .= $graph_entry->{cmd_legend_lower};
      $cmd_legend_upper .= $graph_entry->{cmd_legend_upper};

      $itemcount += 2;
    }

    $cmd_legend .= $cmd_legend_lower;
    $cmd_legend .= $cmd_legend_upper;

  }
  elsif ( $graph_type =~ /^ovm_vm_aggr_cpu_serverpool$|^ovm_vm_aggr_cpu_server$/ ) {
    my ( $filepath, $itemlabel, $obj, $color_read, $color_write );
    my $cmd_legend_upper = my $cmd_legend_lower = "";
    if ( $graph_type =~ /^ovm_vm_aggr_cpu_serverpool$|^ovm_vm_aggr_cpu_server$/ ) {
      $vertical_label = " --vertical-label=\"CPU in cores\"";
      $obj            = "VM ";
      $cmd_params     = " --lower-limit=0.00";
      $cmd_params .= " --units-exponent=1.00";
    }

    $cmd_legend .= " COMMENT:\\n";
    $cmd_legend .= " COMMENT:\"$obj                                             Avrg       Max   \\n\"";
    $cmd_def = $cmd_cdef = "";
    foreach my $uuid (@uuids) {
      $color_read  = $color[ $itemcount % $#color ];
      $color_write = $color[ ( $itemcount + 1 ) % $#color ];

      #$uuid =~ s/===double-col===/:/g;
      my $graph_entry;
      $graph_entry = OracleVmGraph::graph_double_sided_aggr( $uuid, $lpar, $item, $itemcount, $color_read, $color_write );
      my $filepath = $graph_entry->{filepath};

      #print STDERR "$uuid, $lpar, $item, $itemcount, $color_read, $color_write, $filepath\n";
      #print STDERR Dumper($graph_entry) . "\n";
      if ( !-f $filepath ) {
        error( "$filepath does not exist " . __FILE__ . ":" . __LINE__ );
        next;
      }
      my $rrd_update_time = ( stat($filepath) )[9];

      # avoid old lpars which do not exist in the period
      if ( $rrd_update_time < $req_time ) {
        next;
      }
      if ( $rrd_update_time > $last_update_time ) {
        $last_update_time = $rrd_update_time;
      }

      $filepath =~ s/:/\\:/g;
      $cmd_def          .= $graph_entry->{cmd_def};
      $cmd_cdef         .= $graph_entry->{cmd_cdef};
      $cmd_legend_lower .= $graph_entry->{cmd_legend_lower};
      $cmd_legend_upper .= $graph_entry->{cmd_legend_upper};

      $itemcount += 2;
    }

    $cmd_legend .= $cmd_legend_lower;
    $cmd_legend .= $cmd_legend_upper;

  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $xgrid";

  if ( $detail == 2 ) {
    $cmd .= " --interlaced";    # nope string
  }
  else {
    $cmd .= " $vertical_label";
  }

  $cmd .= " HRULE:0#000000";
  $cmd .= $cmd_params;
  $cmd .= $cmd_def;
  $cmd .= $cmd_cdef;
  $cmd .= $cmd_legend;

  # a trick for aggregated graphs, copied from graphing function for Power
  $cmd =~ s/COMMENT: //g;
  $cmd =~ s/\\"/"/g;

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);

    #    $RRDp::error_mode = 'catch';
    $ret = RRDp::read;

    #  print STDERR "##ERR $RRDp::error\n" if defined $RRDp::error;
  };
  if ($@) {
    error( "$lpar : Graph rrdtool error : graph_oraclevm_totals : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  #print STDERR "#rrrr " . Dumper($ret) ." \n";
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;

}

sub graph_linux_io {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $step_new   = $step;
  my $t          = "COMMENT:\" \"";
  my $t2         = "COMMENT:\\n";
  my $last       = "COMMENT:\" \"";
  my $head       = "COMMENT:\"                            Average   \\n\"";

  #$server =~ s/--unknown//;
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  #print STDERR "40637 \$host $host \$server $server \$lpar $lpar \$item $item \$type $type \n";

  my $last_update_time = 0;
  my $start_time       = "now-1$type";
  my $end_time         = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $type =~ m/d/ ) {
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_cpuos: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/\//&&1/g;         #slash workaround
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $header_prefix;
  my $last_txt       = " last ";
  my $vertical_label = "";
  if ( $item eq "total_iops" ) {
    $vertical_label = "--vertical-label=\"Read - IOPS - Write\"";
    $header_prefix  = "IOPS:";
  }
  elsif ( $item eq "total_data" ) {
    $vertical_label = "--vertical-label=\"Read - Bytes/sec - Write\"";
    $header_prefix  = "DATA:";
  }
  elsif ( $item eq "total_latency" ) {
    $vertical_label = "--vertical-label=\"Read - [ms] - Write\"";
    $header_prefix  = "LATENCY:";
  }
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $header = "$header_prefix$lpar_slash_nmon_head:$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      $header = "$header_prefix$lpar_slash_nmon_head : $start_human - $end_human" if $item eq "ds-vmiops";
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
      }
    }
  }

  my $rrd = "$wrkdir/$server/$host/$lpar_slash/disk-total.mmm";
  chomp($rrd);
  my $rrd_update_time = ( stat($rrd) )[9];
  if ( $rrd_update_time > $last_update_time ) {
    $last_update_time = $rrd_update_time;
  }
  $rrd =~ s/:/\\:/g;

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $g_format  = "6.2lf";
  my $divider   = 1000000;
  my $minus_one = -1;

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }
  ## graph options

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $vertical_label";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  $cmd .= " DEF:read_i=\"$rrd\":read_iops:AVERAGE";
  $cmd .= " DEF:read_d=\"$rrd\":read_data:AVERAGE";
  $cmd .= " DEF:read_l=\"$rrd\":read_latency:AVERAGE";
  $cmd .= " DEF:write_i=\"$rrd\":write_iops:AVERAGE";
  $cmd .= " DEF:write_d=\"$rrd\":write_data:AVERAGE";
  $cmd .= " DEF:write_l=\"$rrd\":write_latency:AVERAGE";

  # counting latency / IOPS (ms)
  #$cmd .= " CDEF:read_l1=read_l,read_i,/";
  #$cmd .= " CDEF:write_l1=write_l,write_i,/";
  $cmd .= " CDEF:read_i_neg=read_i,$minus_one,*";
  $cmd .= " CDEF:read_d_neg=read_d,$minus_one,*";
  $cmd .= " CDEF:read_l_neg=read_l,$minus_one,*";

  # iops
  if ( $item eq "total_iops" ) {
    $cmd .= " COMMENT:\"[IOPS]                     Avrg      Max\\n\"";
    $cmd .= " LINE1:write_i#77CCFF:\" Write    \"";
    $cmd .= " GPRINT:write_i:AVERAGE:\"           %6.0lf\"";
    $cmd .= " GPRINT:write_i:MAX:\" %6.0lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:read_i_neg#FF7777:\" Read            \"";
    $cmd .= " GPRINT:read_i:AVERAGE:\"    %6.0lf\"";
    $cmd .= " GPRINT:read_i:MAX:\" %6.0lf\"";
  }

  # data
  elsif ( $item eq "total_data" ) {
    $cmd .= " CDEF:write_in_mb1=write_d,1024,/";
    $cmd .= " CDEF:write_in_mb2=write_in_mb1,1024,/";
    $cmd .= " CDEF:write_in_mb3=write_in_mb2,1024,/";
    $cmd .= " CDEF:read_in_mb1=read_d,1024,/";
    $cmd .= " CDEF:read_in_mb2=read_in_mb1,1024,/";
    $cmd .= " CDEF:read_in_mb3=read_in_mb2,1024,/";
    $cmd .= " COMMENT:\"[MB/sec]                   Avrg      Max\\n\"";
    $cmd .= " LINE1:write_d#77CCFF:\" Write   \"";
    $cmd .= " GPRINT:write_in_mb2:AVERAGE:\"              %3.2lf\"";
    $cmd .= " GPRINT:write_in_mb2:MAX:\"     %3.2lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:read_d_neg#FF7777:\" Read            \"";
    $cmd .= " GPRINT:read_in_mb2:AVERAGE:\"      %3.2lf\"";
    $cmd .= " GPRINT:read_in_mb2:MAX:\"     %3.2lf\"";
  }

  # latency
  elsif ( $item eq "total_latency" ) {
    $cmd .= " COMMENT:\"[ms]                       Avrg      Max\\n\"";
    $cmd .= " LINE1:write_l#77CCFF:\" Write  \"";
    $cmd .= " GPRINT:write_l:AVERAGE:\"               %3.2lf\"";
    $cmd .= " GPRINT:write_l:MAX:\"   %3.2lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:read_l_neg#FF7777:\" Read    \"";
    $cmd .= " GPRINT:read_l:AVERAGE:\"              %3.2lf\"";
    $cmd .= " GPRINT:read_l:MAX:\"   %3.2lf\"";
  }
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";
  $cmd =~ s/\\"/"/g;

  #  "VRULE:0#000000"

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_linux_io : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_cpu_linux {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $step_new   = $step;
  my $t          = "COMMENT:\" \"";
  my $t2         = "COMMENT:\\n";
  my $last       = "COMMENT:\" \"";
  my $head       = "COMMENT:\"                            Average   \\n\"";

  #$server =~ s/--unknown//;
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  #print STDERR "40856 \$host $host \$server $server \$lpar $lpar \$item $item \$type $type \n";

  my $last_update_time     = 0;
  my $last_update_time_lin = 0;
  my $start_time           = "now-1$type";
  my $end_time             = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $type =~ m/d/ ) {
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_cpuos: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $header_prefix  = "CPU Core: ";
  my $last_txt       = " last ";
  my $vertical_label = "";
  if ( $item eq "total_iops" ) {
    $vertical_label = "--vertical-label=\"Read - IOPS - Write\"";
    $header_prefix  = "IOPS:";
  }

  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $header = "$header_prefix$lpar_slash_nmon_head:$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      $header = "$header_prefix$lpar_slash_nmon_head : $start_human - $end_human" if $item eq "ds-vmiops";
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
      }
    }
  }

  my $rrd = "$wrkdir/$server/$host/$lpar_slash/cpu.mmm";
  chomp($rrd);
  my $rrd_cpu_linux = "$wrkdir/$server/$host/$lpar_slash/linux_cpu.mmm";
  chomp($rrd_cpu_linux);

  my $form_dec = "%6.1lf";

  my $rrd_update_time = ( stat($rrd) )[9];
  if ( $rrd_update_time > $last_update_time ) {
    $last_update_time = $rrd_update_time;
  }
  $rrd =~ s/:/\\:/g;

  my $rrd_update_time_lin = ( stat($rrd_cpu_linux) )[9];
  if ( $rrd_update_time_lin > $last_update_time ) {
    $last_update_time_lin = $rrd_update_time_lin;
  }
  $rrd_cpu_linux =~ s/:/\\:/g;

  my $rrd_last = rrd_file_actual("$rrd_cpu_linux");
  RRDp::cmd qq(last "$rrd_last");
  my $last_tt = RRDp::read;
  my $l       = localtime( time_from_last_tt($last_tt) );

  # following must be for RRD 1.2+
  if ( $type =~ "d" ) {
    $l =~ s/:/\\:/g;
    $t = "COMMENT:Updated\\:\" $l \"";
  }

  # get LAST value from RRD
  my $last_tt_minus_step = time_from_last_tt($last_tt) - $step;
  RRDp::cmd qq(fetch "$rrd_last" "AVERAGE" "-s $last_tt_minus_step" "-e $last_tt_minus_step");
  my $row = RRDp::read;
  chomp($$row);
  my @row_arr = split( /\n/, $$row );

  # print STDERR "\@row_arr @row_arr\n";
  my $m            = "";
  my $i            = 0;
  my $one_core_hz  = 1;
  my $one_core_mhz = 1;
  my $one_core_ghz = 1;
  my $util_in_mhz  = 1;

  foreach $m (@row_arr) {
    my @m_arr = split( / /, $m );
    if (@m_arr) {
      if ( $m_arr[2] =~ /\d/ && $m_arr[3] =~ /\d/ ) {
        if ( $m_arr[2] =~ /\d/ ) {
          my $utiltot_mhz = 1;
          my $utiltot_ghz = 1;
          $utiltot_mhz = sprintf( "%e", $m_arr[2] );
          $utiltot_ghz = $utiltot_mhz / 1000;
          $one_core_hz = sprintf( "%e", $m_arr[3] );
          my $util = sprintf( "%5.2f", $utiltot_mhz / $one_core_hz * 1000000 );

          #        if ( $type !~ "d" ) {next} # no, let it for all times even hist rep
          my $util_mhz = sprintf( "%5.0f", $utiltot_mhz );
          $util_in_mhz = $util_mhz / 1000;
        }
        else { $util_in_mhz = "-nan"; }
      }
    }
  }

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $g_format  = "6.2lf";
  my $divider   = 1000000;
  my $minus_one = -1;

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 );
  }
  ## graph options

  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $vertical_label";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  # CPU OS % rrd
  $cmd .= " DEF:entitled=\"$rrd\":entitled:AVERAGE";
  $cmd .= " DEF:cpusy=\"$rrd\":cpu_sy:AVERAGE";
  $cmd .= " DEF:cpuus=\"$rrd\":cpu_us:AVERAGE";
  $cmd .= " DEF:cpuwa=\"$rrd\":cpu_wa:AVERAGE";

  # CPU linux new rrd
  $cmd .= " DEF:cpucount=\"$rrd_cpu_linux\":cpu_count:AVERAGE";
  $cmd .= " DEF:cpuinmhz=\"$rrd_cpu_linux\":cpu_in_mhz:AVERAGE";
  $cmd .= " DEF:threadscore=\"$rrd_cpu_linux\":threads_core:AVERAGE";
  $cmd .= " DEF:corespersocket=\"$rrd_cpu_linux\":cores_per_socket:AVERAGE";

  # cpu cores counting
  #$cmd .= " CDEF:cpu_cores=cpucount,threadscore,corespersocket,*,*";
  $cmd .= " CDEF:cpu_cores=cpucount,100,/";
  $cmd .= " CDEF:stog1=cpusy,cpuus,cpuwa,+,+";
  $cmd .= " CDEF:stog2=cpu_cores,stog1,*";

  # cpu Ghz counting
  $cmd .= " CDEF:cpughz=cpuinmhz,1000,/";
  $cmd .= " CDEF:cpughz1=cpughz,cpucount,*";
  $cmd .= " CDEF:cpu_ghz_one_perc=cpughz1,100,/";
  $cmd .= " CDEF:cpu_ghz_util=cpu_ghz_one_perc,stog1,*";

  $cmd .= " COMMENT:\" Average            cores              GHz (right axis)\\n\"";
  $cmd .= " LINE2:cpucount#888888:\"Total         \"";
  $cmd .= " GPRINT:cpucount:AVERAGE:\" $form_dec\"";
  $cmd .= " GPRINT:cpughz1:AVERAGE:\"         $form_dec\"";
  $cmd .= " $t2";
  $cmd .= " LINE1:stog2#FF0000:\"Utilization   \"";
  $cmd .= " GPRINT:stog2:AVERAGE:\" $form_dec\"";
  $cmd .= " GPRINT:cpu_ghz_util:AVERAGE:\"         $form_dec\"";

  if ($yes_right_axis) {
    $cmd .= " --right-axis $util_in_mhz:0";
    $cmd .= " --right-axis-format %1.1lf";
  }
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";
  $cmd =~ s/\\"/"/g;

  #  "VRULE:0#000000"

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_cpu_linux : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub graph_s2d_volumes {
  my $host        = shift;
  my $server      = shift;
  my $lpar        = shift;
  my $type        = shift;
  my $name_out    = shift;
  my $type_sam    = shift;
  my $detail      = shift;
  my $graph_hours = shift;
  my $entitle     = shift;
  my $start_unix  = shift;
  my $end_unix    = shift;
  my $t           = "COMMENT:\" \"";
  my $t2          = "COMMENT:\\n";
  my $step_new    = $step;
  my $last        = "COMMENT:\" \"";
  my $act_time_u  = time();
  my $req_time    = 0;

  my $text = text_set($type);

  my $head           = "Volumes capacity";
  my $vertical_label = "--vertical-label=\"Volume size in Bytes\"";
  my $header         = "$head : last $text";

  my $xgrid = xgrid_set( $type, $detail );

  if ( "$type" =~ "d" ) {
    $req_time = $act_time_u - 86400;
  }
  elsif ( "$type" =~ "w" ) {
    $req_time = $act_time_u - 604800;
  }
  elsif ( "$type" =~ "m" ) {
    $req_time = $act_time_u - 2764800;
  }

  # for daily, must be even type as for IVM/SDMC it is not in $type_sam =~ "d"
  if ( $type_sam =~ "d" || "$type" =~ "y" ) {
    $req_time = $act_time_u - 31536000;
  }

  # every case: start & end time is unix time
  my $start_time = $req_time;
  my $end_time   = $act_time_u;

  if ( $detail == 2 ) {
    $vertical_label = "--interlaced";    # nope string
    $header         = "$head :$text";
  }
  if ( ( $detail < 1 || $detail == 9 ) && $rrd_legend eq "table" ) {
    $no_legend = "--no-legend";
  }

  if ( isdigit($start_unix) && isdigit($end_unix) ) {
    $start_time = $start_unix;
    $req_time   = $start_time;           # set here too
    $end_time   = $end_unix;
    unless ( $detail == 10 ) {
      $xgrid = "";                       # just a trick
    }
    my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
    my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);

    # $header = "$head aggregated: $host : $start_human - $end_human";
    $header = "$head : $host : $start_human - $end_human";
  }

  if ( $type =~ m/d/ ) {
    $t    = "GPRINT:unrep:LAST:\" %4.0lf\"";
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  # print STDERR "19179 \$item $item \$type $type \$detail $detail \$xgrid $xgrid \$start_unix $start_unix \$end_unix $end_unix\n";
  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph frame_multi: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  # print STDERR "19152 $host $server $lpar\n";

  my $voldir = "$wrkdir/$server/$host/volumes";

  opendir( my $dh, $voldir ) || error( "can't opendir $voldir: $! :" . __FILE__ . ":" . __LINE__ );
  my @volume_rrd_files = grep { /^vol_/ && /\.rrm$/ } readdir($dh);
  closedir $dh;

  #print STDERR "rrd files @volume_rrd_files\n";

  my $i     = 0;
  my $j     = 0;
  my $cmd   = "";
  my $cmdq  = "";
  my $DEBUG = 1;
  my $cluster;

  # print STDERR "19226 creating cluster servers graph : $host:$type:@managednamelist \$no_legend $no_legend \$rrd_legend $rrd_legend\n" ;

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 && $detail != 10 );
  }

  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --lower-limit=0.00";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " $vertical_label";

  #$cmd .= " --base=1024";
  $cmd .= " --alt-y-grid";
  $cmd .= " $no_legend";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";

  #$cmd .= " --alt-autoscale-max";
  #$cmd .= " --upper-limit=0.1";
  #$cmd .= " --units-exponent=1";
  $cmd .= " $xgrid";

  $cmd .= " COMMENT:\\\"Used capacity[TB]\\:                     average   maximum\\l\\\"";

  my $gtype      = "AREA";
  my $color_indx = 0;
  my $divider    = 1024 * 1024 * 1024 * 1024;

  foreach my $vol_rrd_file (@volume_rrd_files) {

    my $vol_rrd = "$voldir/$vol_rrd_file";

    if ( -f "$vol_rrd" ) {

      # avoid old volumes
      my $rrd_upd_time = ( stat("$vol_rrd") )[9];
      if ( $rrd_upd_time < $req_time ) {
        next;
      }
    }
    else {
      # avoid non-existing
      next;
    }

    #print STDERR "volname $vol_name\n";

    my $vol_name = "$vol_rrd_file";
    $vol_name =~ s/^vol_//g;
    $vol_name =~ s/\.rrm$//g;
    my $vol_name_legend = $vol_name;

    #print STDERR "RRD PATH $vol_rrd\n";

    for ( my $k = length($vol_name); $k < 35; $k++ ) {
      $vol_name_legend .= " ";
    }
    $vol_name_legend = substr( $vol_name_legend, 0, 34 );

    $cmd .= " DEF:vol_size_b${i}=\"$vol_rrd\":Size_Total:AVERAGE";
    $cmd .= " DEF:vol_free_b${i}=\"$vol_rrd\":Size_Available:AVERAGE";
    $cmd .= " CDEF:vol_size_max${i}=vol_size_b${i}";
    $cmd .= " CDEF:vol_size_used_b${i}=vol_size_b${i},vol_free_b${i},-";
    $cmd .= " CDEF:vol_size_used${i}=vol_size_used_b${i}";

    $cmd .= " CDEF:vol_size_used_leg${i}=vol_size_used_b${i},$divider,/";

    $cmdq .= " $gtype:vol_size_used${i}$color[$color_indx]:\\\"$vol_name_legend\\\"";
    $cmdq .= " GPRINT:vol_size_used_leg${i}:AVERAGE:\\\"%6.2lf \\\"";
    $cmdq .= " GPRINT:vol_size_used_leg${i}:MAX:\\\"%6.2lf \\l\\\"";
    $gtype = "STACK";

    $cmd .= " PRINT:vol_size_used_leg${i}:AVERAGE:\"%6.2lf $delimiter s2d_vol_cap $delimiter $vol_name $delimiter $color[$color_indx++]\"";
    $cmd .= " PRINT:vol_size_used_leg${i}:MAX:\" %6.2lf $delimiter $host\"";
    $i++;

    if ( $color_indx > $color_max ) {
      $color_indx = 0;
    }
  }

  if ( $i > 0 ) {
    for ( $j = 0; $j < $i; $j++ ) {
      if ( $j == 0 ) {
        $cmd .= " CDEF:tvolmax${j}=vol_size_max${j}";
      }
      else {
        my $k = $j - 1;
        $cmd .= " CDEF:tvolmax${j}=tvolmax${k},vol_size_max${j},+";
      }
    }
    if ( $j > 0 ) {
      $j--;
    }
    my $max_vol_cap = "Max volume capacity";
    for ( my $k = length($max_vol_cap); $k < 35; $k++ ) {
      $max_vol_cap .= " ";
    }

    $cmd .= " CDEF:tcpun${j}=tvolmax${j},0,EQ,UNKN,tvolmax${j},IF";
    $cmd .= " CDEF:tcpun_leg${j}=tcpun${j},$divider,/";
    $cmd .= " LINE2:tcpun${j}#888888:\\\"$max_vol_cap         \\\"";

    # $cmd .= " GPRINT:tcpu${j}:AVERAGE:\\\"%6.2lf \\\"";
    # excluded as it is a bit misleading there there is any even small data gap
    $cmd .= " GPRINT:tcpun_leg${j}:MAX:\\\"%6.2lf \\l\\\"";
    $cmd .= $cmdq;
    $cmd .= " PRINT:tcpun_leg${j}:MAX:\\\"         %6.2lf MAXTCPU $delimiter\\\"";
  }    ## if ( $i > 0 )

  $cmd .= " HRULE:0#000000";

  # $cmd .= " VRULE:0#000000";  --> it is causing sigsegv on linuxeS
  $cmd =~ s/\\"/"/g;

  # print STDERR "19403 \$cmd $cmd\n";
  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Multi graph rrdtool error : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }

  $png_end_heading = ret_graph_param($ret);
  return 0;
}

sub graph_sanmon {
  my $host       = shift;
  my $server     = shift;
  my $lpar       = shift;
  my $type       = shift;
  my $name_out   = shift;
  my $type_sam   = shift;
  my $detail     = shift;
  my $start_unix = shift;
  my $end_unix   = shift;
  my $step_new   = $step;
  my $t          = "COMMENT:\" \"";
  my $t2         = "COMMENT:\\n";
  my $last       = "COMMENT:\" \"";
  my $head       = "COMMENT:\"                            Average   \\n\"";

  #$server =~ s/--unknown//;
  my $xgrid = xgrid_set( $type, $detail );
  my $text  = text_set($type);

  #print STDERR "40637 \$host $host \$server $server \$lpar $lpar \$item $item \$type $type | $name_out | $type_sam | $detail | --- $start_unix----$end_unix\n";

  my $last_update_time = 0;
  my $start_time       = "now-1$type";
  my $end_time         = "now-1$type+1$type";
  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {
      $start_time = $start_unix;
      $end_time   = $end_unix;
      if ( $detail != 10 ) {
        $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
      }
    }
  }

  if ( $type =~ m/d/ ) {
    $head = "COMMENT:\"                            Average   Last\\n\"";
  }

  if ( $type_sam =~ m/x/ ) {

    # historical reports --> no xgrid
    $xgrid = "COMMENT:\" \"";    # just a trick to place there something otherwise rrdtool complains
  }

  if ( $text eq '' ) {
    error( "Graph rrdtool error : graph_sanmon: $type " . __FILE__ . ":" . __LINE__ );
    return (0);
  }

  my $lpar_slash = $lpar;
  $lpar_slash =~ s/\&\&1/\//g;       # to show slash and not &&1 which is general replacement for it
  $lpar_slash =~ s/\//&&1/g;         #slash workaround
  $lpar_slash =~ s/--WPAR--/\//g;    # WPAR delimiter replace
  my $lpar_slash_nmon = $lpar_slash;
  $lpar_slash_nmon =~ s/$NMON//;

  my $header_prefix;
  my $last_txt       = " last ";
  my $vertical_label = "";
  if ( $item eq "sarmon_iops" ) {
    $vertical_label = "--vertical-label=\"Total IOPS\"";
    $header_prefix  = "IOPS:";
  }
  elsif ( $item eq "sarmon_san" ) {
    $vertical_label = "--vertical-label=\"Read - Bytes/sec - Write\"";
    $header_prefix  = "DATA:";
  }
  elsif ( $item eq "sarmon_latency" ) {
    $vertical_label = "--vertical-label=\"Read - [ms] - Write\"";
    $header_prefix  = "LATENCY:";
  }
  my $lpar_slash_nmon_head = $lpar_slash_nmon;

  my $header = "$header_prefix$lpar_slash_nmon_head:$last_txt$text";

  if ( !$start_unix eq '' && !$end_unix eq '' ) {
    if ( isdigit($start_unix) > 0 && isdigit($end_unix) > 0 ) {

      # historical reports
      my $start_human = strftime "%H:%M:%S %d.%m.%Y", localtime($start_unix);
      my $end_human   = strftime "%H:%M:%S %d.%m.%Y", localtime($end_unix);
      $header = "$header_prefix $lpar_slash_nmon : $start_human - $end_human";
      $header = "$header_prefix$lpar_slash_nmon_head : $start_human - $end_human" if $item eq "ds-vmiops";
      if ( $detail == 10 ) {
        $header = "$server : $header_prefix $lpar_slash_nmon : $start_human - $end_human";
      }
    }
  }

  my $rrd = "$wrkdir/Solaris--unknown/no_hmc/$lpar_slash/total-san.mmm";
  chomp($rrd);
  my $rrd_update_time = ( stat($rrd) )[9];
  if ( $rrd_update_time > $last_update_time ) {
    $last_update_time = $rrd_update_time;
  }
  $rrd =~ s/:/\\:/g;

  my $no_minor = "--no-minor";
  $no_minor = "" if $super_detail == 3;

  my $g_format  = "6.2lf";
  my $divider   = 1000000;
  my $minus_one = -1;

  if ( $detail == 9 ) {
    $html_heading = $header;
    $header       = "";
  }
  else {
    $header = strftime( "%H:%M:%S %d.%m.%Y", localtime($start_unix) ) . " - " . strftime( "%H:%M:%S %d.%m.%Y", localtime($end_unix) ) if ( $width < 700 && defined $start_unix && defined $end_unix && isdigit($start_unix) > 0 && isdigit($end_unix) > 0 && $detail != 10 );
  }

  ## graph options
  my $cmd = "";
  $cmd .= "$graph_cmd \"$name_out\"";
  $cmd .= " --title \"$header\"";
  $cmd .= " --start $start_time";
  $cmd .= " --end $end_time";
  $cmd .= " --imgformat PNG";
  $cmd .= " $disable_rrdtool_tag";
  $cmd .= " --slope-mode";
  $cmd .= " --width=$width";
  $cmd .= " --height=$height";
  $cmd .= " --step=$step";
  $cmd .= " --color=BACK#$pic_col";
  $cmd .= " --color=SHADEA#$pic_col";
  $cmd .= " --color=SHADEB#$pic_col";
  $cmd .= " --color=CANVAS#$pic_col";
  $cmd .= " --alt-autoscale-max";
  $cmd .= " --alt-y-grid";
  $cmd .= " $font_def";
  $cmd .= " $font_tit";
  $cmd .= " $vertical_label";
  $cmd .= " $no_legend";
  $cmd .= " $xgrid";

  $cmd .= " DEF:read_i=\"$rrd\":disk_iops:AVERAGE";
  $cmd .= " DEF:read_d=\"$rrd\":disk_read:AVERAGE";
  $cmd .= " DEF:write_d=\"$rrd\":disk_write:AVERAGE";
  $cmd .= " DEF:read_l=\"$rrd\":disk_latency:AVERAGE";

  # counting latency / IOPS (ms)
  $cmd .= " CDEF:read_d_neg=read_d,$minus_one,*";

  #$cmd .= " CDEF:read_l1=read_l,read_i,/";
  #$cmd .= " CDEF:write_l1=write_l,write_i,/";
  #$cmd .= " CDEF:read_i_neg=read_i,$minus_one,*";
  #$cmd .= " CDEF:read_l_neg=read_l,$minus_one,*";

  # iops
  if ( $item eq "sarmon_iops" ) {
    $cmd .= " COMMENT:\"[IOPS]                     Avrg      Max\\n\"";
    $cmd .= " LINE1:read_i#FF7777:\" Total            \"";
    $cmd .= " GPRINT:read_i:AVERAGE:\"    %6.1lf\"";
    $cmd .= " GPRINT:read_i:MAX:\" %6.1lf\"";
  }

  # data
  elsif ( $item eq "sarmon_san" ) {
    $cmd .= " CDEF:write_in_mb1=write_d,1024,/";
    $cmd .= " CDEF:write_in_mb2=write_in_mb1,1024,/";
    $cmd .= " CDEF:write_in_mb3=write_in_mb2,1024,/";
    $cmd .= " CDEF:read_in_mb1=read_d,1024,/";
    $cmd .= " CDEF:read_in_mb2=read_in_mb1,1024,/";
    $cmd .= " CDEF:read_in_mb3=read_in_mb2,1024,/";
    $cmd .= " COMMENT:\"[MB/sec]                   Avrg      Max\\n\"";
    $cmd .= " LINE1:write_d#77CCFF:\" Write   \"";
    $cmd .= " GPRINT:write_in_mb1:AVERAGE:\"              %3.2lf\"";
    $cmd .= " GPRINT:write_in_mb1:MAX:\"     %3.2lf\"";
    $cmd .= " $t2";
    $cmd .= " LINE1:read_d_neg#FF7777:\" Read            \"";
    $cmd .= " GPRINT:read_in_mb1:AVERAGE:\"      %3.2lf\"";
    $cmd .= " GPRINT:read_in_mb1:MAX:\"     %3.2lf\"";
  }

  # latency
  elsif ( $item eq "sarmon_latency" ) {
    $cmd .= " COMMENT:\"[ms]                       Avrg      Max\\n\"";
    $cmd .= " LINE1:read_l#FF7777:\" Total    \"";
    $cmd .= " GPRINT:read_l:AVERAGE:\"              %3.1lf\"";
    $cmd .= " GPRINT:read_l:MAX:\"  %3.1lf\"";
  }
  $cmd .= " $t2";
  $cmd .= " HRULE:0#000000";
  $cmd =~ s/\\"/"/g;

  #  "VRULE:0#000000"

  my $updated_label = "";
  if ( $type =~ "d" ) {
    $last_update_time = localtime($last_update_time);
    $last_update_time =~ s/:/\\\:/g;
    $updated_label = "COMMENT:\"Updated\\\: $last_update_time\"";
    $cmd .= " $updated_label";
    $updated_label = "COMMENT:Updated\\\: $last_update_time";
  }

  eval {
    RRDp::cmd qq($cmd);
    $ret = RRDp::read;
  };
  if ($@) {
    error( "$host : Graph rrdtool error : graph_sanmon : $@ " . __FILE__ . ":" . __LINE__ );
    return 1;
  }
  $png_end_heading = ret_graph_param( $ret, $updated_label );
  return 0;
}

sub time_from_last_tt {
  my $input = shift;
  my $in    = $$input;
  chomp($in);
  $in =~ s/\n.*//g;
  $in =~ s/\\n.*//g;
  return $in;
}

